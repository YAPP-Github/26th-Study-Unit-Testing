이번 장에서 이야기 할 내용은 아래와 같습니다.

1. 단위 테스트의 구조 (3A 패턴 등)
2. 단위 테스트의 네이밍

---

## 3A 패턴

가장 먼저 3A(=AAA) 패턴에 대해 이야기합니다. 가장 우리에게 익숙한 Act, Arrange, Assert 패턴입니다. 다른 이름으로는 Given, When, Then 패턴이 있죠.

저자는 해당 패턴을 사용함에 있어서 주의할 점을 여러 가지를 논하는데요.

1. 각 섹션은 단 한 번씩만 사용되어야 한다고 강조합니다. 
    
    **유닛 테스트는 하나의 단위를 검증하는 것**이므로 Act나 Assert가 여러 번 반복되는 것은 더 이상 유닛 테스트가 아니게 됩니다.
    
2. 테스트 안에서 분기를 만들지 말라고 강조합니다.
    
    테스트 내부에서 if와 같은 분기를 생성하는 것은 한 테스트에서 너무 많은 것을 검증한다는 증거입니다. 이런 경우 테스트를 분리해야 합니다. 통합 테스트도 예외 없이요.
    
3. Arrange는 크고, Act는 작고, Assert는 필요한 만큼 사용할 것을 강조합니다.
    
    정확히는 Arrange가 꼭 커야 하는 것은 아니지만, 어느 정도는 커져도 문제가 없다는 의미입니다. 단, Act는 두 줄 이상일 때 의심해야 합니다.
    

---

### Arrange가 없는(?) 경우

```swift
class FooTests: XCTestCase {
    var sut: FooService!

    override func setUp() {
        sut = FooService()
    }

    func test_bar() {
        // Act
        let result = sut.bar()
        // Assert
        XCTAssertEqual(result, expected)
    }
}
```

테스트를 작성하다 보면 이런 식으로 Arrange 섹션이 아예 비어버리는 경우가 생기곤 합니다. 하지만, Arrange가 비어도 될까요 ? 저는 개인적으로 이런 경우가 많았고 이래도 되는건가 하는 고민도 좀 해봤습니다.

결론적으로는 Arrange는 반드시 존재해야 합니다. 그 길이가 짧든 길든간에.

하지만 Arrange가 쉽게 드러나 있지 않을 수도 있습니다. 

```swift
/// setUp이 Arrange의 역할을 나눠 가지는 경우
override func setUp() {
    sut = FooService()
}

/// 인라인에 Arrange가 존재하는 경우
func test_addition() {
    // Act
    let result = 2 + 3
    // Assert
    XCTAssertEqual(result, 5)
}
```

결국 `test_bar(_:)`는 틀리지 않았습니다.

---

### 그 외의 경우들

Act가 여러 줄인 경우의 문제점은 책에서도 잘 설명하고 있습니다. 캡슐화 실패 하나로 어느정도 설명될 수 있습니다. 

`setUp()` 이야기를 했으니 `tearDown()` 이야기도 해야겠죠. 이 메소드는 단위 테스트에서 필요하지 않습니다. 통합 테스트를 진행하거나, E2E 테스트를 진행하는 등 실제 케이스에서는 물론 필요합니다. 

데이터베이스를 조작하는 어떤 기능을 테스트하고, 그 상태를 원래로 돌려놓는 작업을 하는 등 외부 의존성과 관련있는 테스트를 할 때는 분명히 필요한데요, 단위 테스트에서는 외부 부작용이 발생하지도 않고, 발생해서도 안되므로 생략하는 게 맞습니다.

---

### Test Fixture

간단하게 요약하면, 테스트 픽스처는 SUT 또는 테스트를 위한 의존성을 말합니다.

어떻게 테스트 픽스쳐를 초기화하고 설정할까요 ? 일반적으로 저희는 `setUp()` 또는 Arrange 섹션에서 하곤 했죠. 하지만, 많은 테스트에서 duplicate가 일어나게 되면 고민해야 할 것들이 있습니다. 재사용을 해야겠죠.

`setUp()`에서 미리 설정하고 다른 테스트들이 사용하는 것은 책에서도 설명했듯이 좋지 못한 방법입니다. 만약 모든 테스트가 같은 상태에서 실행된다면 문제는 안 되겠지만, SUT이 어떠한 설정 값을 받아 상태가 각자 다르다면 문제가 되겠죠.

그러므로, 유사한 코드 블럭들을 책에서는 private 메소드를 사용하라고 합니다. XCTestCase에서도 이름이 test로 시작하며 인터페이스가 노출되는 메소드에 한하여 작동되므로 충분히 활용할 여지가 있습니다.

---

### 테스트 네이밍

테스트 메소드를 작성할 때, 중요한 것이 있죠. 네이밍입니다. 잘 지어진 메소드의 이름은 어떤 작업을 하는지 유추하는 데에 도움이 되죠. 테스트도 마찬가지로 네이밍은 중요합니다.

`[MethodUnderTest]*[Scenario]*[ExpectedResult]`

책에서도 제시한 예시로, 위와 같은 패턴이 많이 쓰입니다. 예를 들어 `test_foo_when_bar_exist_returns_string_bar`과 같은 방식으로 길게 쓰일 수도 있습니다. 

하지만, 솔직히 이런 메소드를 작성하다 보면 억지가 아닌가 싶을 정도로 이해하기 어려워지는 경우가 있었습니다. 그래서 저자는 제안합니다. 엄격한 규칙을 적용하지 말라는 것, 표현의 자유를 허용하라는 것입니다. 자연어처럼 잘 읽히게 작성하라는 것이죠. 꼭 테스트 메소드 이름에 기존의 메소드 이름을 포함한다던지 하는 게 좋지 않다는 이야기와 함께요.

* 추가로, 테스트 클래스 네이밍에 대해서도 크게 신경을 쓸 필요가 없습니다. 테스트 클래스에 실제 존재하는 클래스의 이름을 사용했다고 하더라도, 테스트 대상이 꼭 그 클래스만이 아닙니다.

---

### 테스트 파라미터화

하나의 기능에 대해 하나의 테스트로는 그 기능을 완벽하게 커버할 수 없습니다. 여러 분기가 발생할 수도 있고, 예외 케이스도 있는 등 하나의 단위에 대해 여러 테스트를 진행해야 하기 때문이죠.

그렇다고 모든 경우에 대해서 메소드를 다 만들며 테스트 할 수는 없습니다. 단순히 같은 테스트에서 값만 조금 바뀌는 수준이라면, 충분히 라인 수를 줄일 수 있죠.

아쉽게도 XCTest는 파라미터화 테스팅을 기본적으로 지원하지는 않습니다. 책에서 설명하는 `[InlineData()]` 같은 어노테이션으로 파라미터화를 하는 것이 프레임워크가 제공하는 기능이겠죠.

```swift
func test_addition_withCases() {
    let testCases = [
        ("1 + 2 = 3", 1, 2, 3),
        ("5 + 5 = 10", 5, 5, 10)
    ]

    for (description, a, b, expected) in testCases {
        XCTContext.runActivity(named: description) { _ in
            XCTAssertEqual(add(a, b), expected)
        }
    }
}
```

흉내정도는 어떻게든 낼 수는 있습니다. 다만, 다른 파라미터화 테스팅처럼 별도의 메소드로 처리가 되지는 않는 다는 것이죠. 다만, 각 케이스의 결과를 runActivity의 이름으로 확인을 할 수는 있습니다.

저는 개인적으로 사용할만 하다고 생각합니다.저자는 긍정 케이스와 부정 케이스에 대해 메소드를 분리하라고 하는데요, 만약 이 케이스들이 섞인다면 확실하게 좋지 않은 방법이 될 수는 있겠습니다.

---

### Fluent-Style Assertion

`XCTAssertEqual(_:)`같은 메소드는 가독성이 그렇게 좋은 편은 아닙니다. 그래서 저자는 fluent한 assertion을 제안하는데요, 이건 결국 필요에 따라 선택하는 게 나을 거 같습니다. XCTest는 제공하지 않기 때문에 서드파티 라이브러리를 사용해야 하기 때문이죠.

`Nimble`, `Hamcrest-Swift`과 같은 라이브러리를 통해 fluent 하게 사용할 수 있습니다. 테스트가 점차 복잡해지고, 더 읽기 쉽게 리팩토링을 해야 한다거나 할 때 사용하는 편이 좋아보입니다.