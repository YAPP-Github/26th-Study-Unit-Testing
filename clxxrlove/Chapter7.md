이번 장에서는 리팩터링에 대해 이야기합니다. 프로덕션 코드가 리팩터링되면, 테스트 코드도 당연하게 리팩터링 되어야 할 수 밖에 없죠. 그럼 어떤 기준으로 코드가 변경되어야 할까요 ? 

프로덕션 코드는 아래 두 가지의 기준을 통해 나눌 수 있습니다.

1. 복잡도 또는 도메인 중요도
    1. 복잡도의 경우에는 사이클로매틱 복잡도를 통해 계산합니다. 분기 지점의 수를 가지고 계산됩니다.
    2. 도메인 중요도의 경우에는 복잡도가 중요하지 않습니다. 실제 문제와 얼마나 밀접한지를 신경써야 하며, 그러한 경우 코드가 아주 간단하더라도 반드시 테스트되어야 합니다.
2. 협력 객체의 수
    1. (Review) 협력 객체는 mutable, out-of-process 의존성을 의미합니다.
        1. 다만, static한 메서드를 제외하는 것은 아닙니다. 이는 암묵적인 협력 객체로 볼 수 있습니다. 실제 테스트 시 명시적으로 포함됩니다.
        2. Constant(단순 Value)나, VO 등 immutable한 의존성은 협력 객체로 취급하지 않습니다. 

그럼 이 두 가지의 속성을 통해 네 가지의 코드 유형이 나옵니다.

1. 도메인 모델 또는 알고리즘 (도메인 중요, 코드 단순)
2. 단순한 코드 (도메인 중요 X, 코드 단순)
3. 컨트롤러 (도메인 중요 X, 협력 객체 많음)
4. 복잡한 코드 (도메인 중요, 협력 객체 많음)

이를 통해 어떤 코드를 테스트할지, 테스트의 가치가 얼마나 될지 계산할 수 있습니다. 

도메인과 연관이 있는 코드들은 전부 테스트되어야 합니다. 

간단한 도메인 코드는 쉽게 테스트할 수 있습니다. 반면에, 아주 복잡하지만 도메인과 관련있는 코드는 테스트하기에 어렵습니다.

---

이게 리팩터링 신호라고 볼 수 있습니다. 알고리즘과 컨트롤러를 나눠야 합니다. 

말은 쉽지만, 어떻게 해야할지는 잘 모르겠습니다. 그럼 아주 현실적으로 생각해볼까요 ?

태초에 MVC가 있었습니다. 이 구조를 통해 많은 프로젝트들이 개발되었죠. 하지만 굉장히 불편한 요소가 많았습니다. ViewController와 같은 경우에는 컨트롤러의 역할도 해야 하지만, 비즈니스 로직이 섞여있는 경우도 굉장히 많았죠. 

지금은 어떤가요 ? 클린 아키텍처를 적용한다면 ViewController와 ViewModel을 나누고, UseCase를 통해 비즈니스 로직을 작성합니다. Repository나 Service는 이에 협력하고 있죠.

비즈니스의 핵심 규칙, 알고리즘 등은 Domain Layer로. 외부 의존성 등 구현적인 것들은 서로 다른 Implementation Layer로 구분해서 구현하고 있죠.

저자가 이야기한대로, 알고리즘과 컨트롤러를 나눴습니다. 이게 알고리즘과 컨트롤러를 나눈 구조의 예시입니다.

여기서 험블 객체에 대한 이야기가 나옵니다. 사실 위의 예시가 험블 객체의 예시입니다. 클린 아키텍처도 험블 객체를 이야기합니다. 헥사고날 아키텍처나, 함수형 아키텍처도 마찬가지로 험블 객체를 활용하고 있죠.

코드 목록 7.1번을 보면, `MessageBus`와 `Database`에 대한 이야기가 있습니다. 암묵적인 의존성이라고 나와있습니다. 싱글톤 객체 또는 정적 메서드로 보입니다.

---

이 암묵적인 의존성을 명시적으로 만들어야 한다고 하는데요:

```swift
public protocol NetworkRequestable {
    func data(for request: URLRequest) async throws -> (Data, URLResponse)
}

extension URLSession: NetworkRequestable {}
```

익숙한 예시입니다. 처음에 저는 당연하게 `URLSession.shared.data(_:)`로 써왔는데요, 언젠가 위와 같이 코드를 변경해보라는 제안을 받은 적이 있습니다.

잘 이해는 안됐죠. `URLSession.shared` 말고 `data(_:)`를 제공하는 것이 있을까 하며 무슨 의미가 있나 싶었습니다. 

정답은 위와 같이 변경하면 테스트가 용이해지고, 의존성 주입이 가능한 구조로 변하기에 가치가 있습니다.

---

이후 코드를 가지고 이야기하는 예시들은 대부분 객체지향 도서에서 이야기하는 것들과 크게 다르지는 않으므로 짧게 요약만 하겠습니다. 

1. (위 내용) DIP 준수
2. 레이어드 아키텍처와 마찬가지로 관심사에 따른 계층 분리 수행
3. SRP와 책임 분리. 낮은 결합도를 가지도록 리팩터링

---

이번 장을 읽다보면, 테스트 커버리지가 다시 고민입니다. 분명 초반에는 테스트 커버리지가 낮으면 좋지 않은 신호라는 이야기를 들었던 거 같은데, 어떤 테스트는 할 필요 없고 어떤 것은 반드시 해야 한다고 합니다.

결국 가성비를 따진다고 생각합니다. 테스트 작성에 드는 비용에 비해 얼마나 큰 가치를 얻을 수 있는가가 중점이라고 생각되는데요, 도메인과 관련이 있으면 반드시 다 테스트 해야합니다.

가성비는 그럼 또 어떻게 따질까요 ? 

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    if (Email == newEmail)
        return;

    UserType newType = company.IsEmailCorporate(newEmail)
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);
    }

    Email = newEmail;
    Type = newType;
}
```

책에 있던 예시인데요, 도메인과 아주 밀접합니다. 이런 코드가 가성비가 아주 좋다(테스트 ROI가 높다)고 이야기합니다. 

이 프로덕트 코드는 반드시 테스트해야 합니다. 분기가 존재하므로 완벽한 커버리지를 얻기 위해 parameterized 테스트로 편의를 얻는 부분도 있고요.

그럼 어떤 코드가 가성비가 낮을까요 ?

```csharp
public User(int userId, string email, UserType type)
{
    UserId = userId;
    Email = email;
    Type = type;
}
```

이 코드가 존재하는 layer가 어디가 됐든, 테스트할 가치가 없습니다. 도메인을 겨냥하지도 않고, 코드가 복잡해서 버그가 일어날 확률도 없습니다. 

Precondition을 테스트하는 것도 마찬가지입니다. 코드가 일반적으로 단순하죠. 그렇기에 비즈니스 규칙이나 도메인과 관련이 있다면 테스트를 하고, 그렇지 않다면 불필요한 테스트가 됩니다.

---

다음으로는 오케스트레이션에 대한 이야기를 합니다. 도메인과 외부 의존성을 분리하기 위한 방법을 이야기하죠.

그래서 처음에 이야기하는 것은, 외부 의존성과의 상호작용은 양 끝에서 수행하는 방식을 이야기하는데, 현실적인 이야기는 못 됩니다. 그래서 필요할 때 외부 의존성을 호출하는 방식을 이야기하기도 하지만 설계상 에러가 많죠.

그래서 판단은 도메인이, 외부 호출은 컨트롤러가 하는 방식을 결국 추천합니다. 

이걸 어떻게 해결해야 할까요. 그 방법으로 몇 가지를 이야기합니다.

1. CanExecute/Execute 패턴
2. 도메인 이벤트를 통해 변경 사항 추적

첫 번째 방법은 판단과 작업을 도메인 계층에 위임합니다. 컨트롤러는 어떠한 작업을 해도 되는지 자기 자신이 검증하는 것이 아니라, 도메인 레이어에게 물어보고 가능하다면 작업합니다. 테스트도 용이하고, 성능도 나쁘지 않죠.

다음 방법은 도메인 이벤트를 도입하는 방법입니다. 여긴 뭔가 ViewModel을 보는 거 같습니다. 도메인 내부에는 이벤트 객체만을 남겨두고, 외부 호출은 컨트롤러 또는 디스패처를 통해 후처리하는 방식으로 이벤트를 다룹니다.

---

마지막으로 이번 장을 아주 간략하게 요약해보겠습니다.

1. 외부 의존성은 도메인 밖으로 몰아낼 것
2. 비즈니스 판단은 도메인 레이어에서, 외부 호출은 컨트롤러에서 할 것
3. 위 방법에서 컨트롤러는 복잡해질 위험이 있으므로 이를 잘 제어할 것 (CanExecute/Execute 패턴 등)
4. 테스트는 관찰 가능한 행위 중심으로. 세부 구현은 신경쓰지 말 것
