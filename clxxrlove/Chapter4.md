이번 장은 좋은 테스트를 구성하는 요소들에 대해 논합니다.

1. 좋은 단위 테스트의 여러 측면 간의 이분법 탐구
2. 이상적은 테스트 정의
3. 테스트 피라미드 이해하기
4. 블랙박스 테스트와 화이트박스 테스트 사용하기 

---

### Regression으로부터의 보호

Regression은 회귀입니다. 왜 회귀인가 이해를 잘 하지 못했었는데요. 새로운 기능이 추가됐을 때 기존 기능이 깨지는 것을 의미합니다. 기능이 많아질수록 가능성이 더 높아지죠.

그러므로 저자는 코드를 부채라고 표현합니다. 기능이 추가됨에 따라 회귀 발생 확률이 지속적으로 발생하므로, 유지보수를 위해 테스트를 잘 작성해야 합니다. 

그래서 테스트가 코드베이스를 얼마나 커버할 수 있는지 고려해야 하며, 테스트 대상이 얼마나 복잡하며 얼마나 중요한 요소인지를 고려해야 합니다. 심지어는, 라이브러리나 프레임워크도 문제가 발생을 할 수 있습니다. 외부 시스템까지요. 

---

### 리팩토링에 대한 저항력

소프트웨어 생명 주기에서 리팩토링은 무지 중요합니다. 기능을 어느정도 완성하고, 테스트하고, 리팩토링을 하며 코드 품질을 높이기 위해 노력하겠죠. 하지만, 미리 작성해 둔 테스트에서 문제가 발생할 수 있습니다. 기능은 그대로 잘 동작하지만 테스트가 실패할 수 있죠.

저자는 거짓 양성을 설명하고, 이와 관련하여 위험성을 이야기합니다. 비유적으로 표현한 양치기 소년의 이야기가 딱 적합하죠. 기능이 잘 동작함을 알고 있으니 테스트가 실패해도 믿지 않는다는 것이죠.

> 거짓 양성은 잘 동작하는 코드에서 테스트가 실패하는 것을 말합니다.
> 

그럼, 리팩토링 이후 거짓 양성이 발생한다는 것은 설계가 잘못되었다거나, 테스트가 잘못 작성되었음을 시사한다고 볼 수 있습니다. 

설계가 잘못된 경우:

퍼블릭 인터페이스의 노출이 잘못된 경우. 즉 캡슐화에 실패한 경우가 확실하게 이 경우로 볼 수 있습니다.

테스트가 잘못된 경우:

원본 코드의 설계를 지나치게 잘 알고 있는 경우가 이 경우에 해당합니다. 또는, 테스트의 원칙을 잘 지키지 못해 하나의 단위만을 검증하는 것이 아닌 여러 동작을 묶는 경우가 이 경우에 해당됩니다. SRP를 제대로 지키지 못했다고 볼 수 있죠.

---

### 테스트의 정확도 극대화

테스트의 정확도는 위 두 파트를 통해서 확인할 수 있습니다:

- 버그의 존재를 얼마나 잘 나타내는가 (거짓 음성의 부재 - 회귀 방지 능력의 영역)
- 버그가 존재하지 않음을 얼마나 잘 나타내는가 (거짓 양성의 부재 - 리팩토링 저항성의 영역)

즉, 위 내용을 정리하면 테스트는 신호(버그를 찾아내는 능력)가 강하고, 잡음(거짓 경보)이 적을수록 정확도가 높다고 볼 수 있습니다.

그렇다면, 테스트의 정확도를 높이기 위해서는 버그를 더 잘 찾도록 테스트 케이스를 강력하게 작성하면 됩니다. 또한, 거짓 경보가 없도록 코드베이스에 너무 의존하지 않도록 작성해야 합니다. 위의 사례들을 통해 반면교사 삼아 테스트를 작성하면 된다는 이야기죠.

---

### 빠른 피드백과 유지보수성

피드백이 빠르다는 것은, 테스트가 더 빠르게 실행되어 테스트 결과를 바로 확인할 수 있게 한다는 것이죠. 더 자주 테스트를 수행하여 검증하고, 더 많은 테스트 스위트를 포함할 수 있게 합니다.

다음으로는 계속 강조되는 부분이기도 합니다. 테스트를 제외한 코드베이스도 유지보수가 가능하도록 작성되어야 하지만, 테스트 코드도 유지보수가 가능하도록 작성되어야 함을 다시 강조합니다.

테스트는 이해하기 쉬워야 합니다. 이 부분은 유지보수성의 측면 뿐만 아니라 테스트가 제대로 동작하지 않는 경우 등에서 문제가 발생할 확률이 높습니다. 

그리고 테스트는 실행하기 쉬워야 합니다. 테스트가 실행하기 어려운 경우 (외부 의존성을 설정해야 실행 가능한 경우, 또는 실행이 아주 느린 경우) 테스트 외적인 부분에서 시간을 들여야 할 수 있습니다. 

결국 빠른 피드백이나, 유지보수성이나 완전히 기술적인 이야기는 아닙니다. 개발자의 입장에서 테스트를 수행하는 데에 있어서 얼마나 편리한지, 아니면 유지보수하는 데 편리한지를 이야기합니다. 만약 불편한 요소가 생긴다면 테스트에 점점 손이 잘 안 가게 되어 큰 문제가 발생할 수 있다는 것입니다.

---

### 좋은 테스트를 정하는 척도

앞에서 이야기한 4가지 속성을 통하여 종합적으로 가치를 결정할 수 있습니다. 저자는 이 4가지 속성을 곱한다고 이야기하는데요, 이 의미는 하나라도 0이 된다면 테스트는 가치가 없어짐을 이야기합니다.

자격증 시험과 비슷하죠. 평균 점수가 높더라도 과락이 있으면 불합격이죠. 모든 속성에서 최소한 어느정도의 점수를 넘기겠다는 목표를 가지고 테스트를 작성해야 한다는 것입니다

---

**역설 발생**

위에서 말한 척도는 현실적이지는 못합니다. 회귀 방지와 리팩토링 저항성에서부터 상충되는 내용이 발생하죠. 

회귀 방지를 위해서는 코드베이스를 최대한 커버해야 한다고 했죠. 이 의미는 아주 상세한 구현을 알고 이를 테스트 가능해야 한다는 이야기죠.

반대로, 리팩토링 저항성에서는 상세한 구현을 알지 말라고 합니다. 블랙박스 테스트를 진행하라고 하죠. 이러면 버그를 감지하지 못 할수도 있습니다. 거짓 음성이 발생하게 되겠죠.

그리고 빠른 피드백의 경우에는 위 두 속성과 모두 상충됩니다. 빠른 테스팅을 위해 외부 의존성을 전부 제거하고 mocking 위주로 테스트를 하게 되겠죠 ? 그러면 회귀 방지도 깨집니다. 커버하는 코드베이스의 라인 수가 줄겠죠. 그리고 mock이 점차 많아지면서 리팩토링 저항성 마저도 깨지게 됩니다.

---

그럼 어떻게 해야 할까요 ?

테스트를 작성하다 보면 모든 속성에 대해 완벽하게 수행할 수는 없습니다. 완벽하게 하고자 하면 두 가지 속성정도는 가능합니다. 다른 하나의 속성은 0점에 가깝게 되겠지만요.

우선 상충되는 세 속성 중, 어떤 것이 가장 중요한지 논해야겠죠. 리팩토링 저항성이 가장 중요합니다. 그럼 코드의 성격에 따라 회귀 방지를 신경써야 할지, 빠른 피드백을 신경써야 할지 선택해야 합니다. 하나가 완벽해질수록 하나는 떨어집니다.

즉, 테스트의 특성에 따라 적절히 조절해야 합니다. 각 테스트의 성격에 따라서 특정한 속성에 대해 유불리가 존재합니다. 이를 참고하면 되겠죠.

E2E 테스트의 경우에는 많은 양의 코드를 커버해야 하기 때문에 회귀에 대한 큰 어드벤티지가 있죠. 이 경우에는 외부 라이브러리, 프레임워크 등 외부 코드에 대한 커버리지도 존재하죠. E2E의 특성 상 특정한 구현 방식에 의존하지 않으므로 리팩토링 저항성도 좋죠.

문제는 빠른 피드백입니다. 그렇다면 위의 내용에 따라, 테스트의 성능을 신경쓰면 되겠죠. 이렇게 중심을 맞춰나가면 된다는 것이죠. 

매우 사소한 테스트의 경우에도 조금 생각해보면 어떤 속성에서 유불리가 존재하는지 알 수 있습니다. 

![스크린샷 2025-06-05 14.14.25.png](attachment:4f6fe509-a683-4127-bc11-bddf99798b53:스크린샷_2025-06-05_14.14.25.png)

다만, 취약한 테스트에서는 조금 다릅니다. 책에서 이야기하는 예시를 보면 사실 테스트가 정확히 동작할지도 모르겠습니다. 저자는 가능하다고 하네요. 왜 가능할까요 ?

테스트가 상세한 구현을 아주 잘 알고 있기 때문이겠죠. SQL Statement를 어떻게 생성하는 지를 알고 있기 때문에 성공할 수 있죠. 그렇다는 것은 리팩토링 저항성이 크게 떨어짐을 이야기합니다. 그냥 나쁜 예시정도로 보면 될 듯 합니다.

정리하면, 테스트가 가벼울 수록 빠른 피드백에 신경을 쓰고, 테스트가 무거울수록 회귀 방지를 신경써야 합니다. 모든 경우에서 리팩토링 저항성은 신경써야 하고요.

---

### 블랙박스 테스트와 화이트박스 테스트

블랙박스 테스트와 화이트박스 테스트는 각자의 강점을 가집니다. 전자의 경우에는 리팩토링 저항성에서 강하며, 후자의 경우에는 회귀 방지에서 강합니다. 반대의 경우에는 약점이 되겠죠.

위에서 여러 번 이야기했듯이, 리팩토링 저항성은 타협할 속성이 아닙니다. 즉, 가급적이면 블랙박스 테스트가 옳다는 것이죠. 정확히는 테스트를 작성할 때 블랙박스 테스팅이 더 좋다는 것이겠죠. 반대로 분석을 할 땐 화이트박스 테스팅이 도움이 될 수 있습니다.