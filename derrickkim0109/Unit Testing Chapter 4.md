<h1><center> Unit Testing Chapter 4 - TIL </center></h1>

###### tags: `💻 TIL`
###### date: `2024-06-0617:21:33.284Z`

> [color=#724cd1][name=데릭]
> 
## Chapter 4 좋은 단위 테스트의 네 가지 핵심 기둥

- 회귀로부터의 보호: 변경된 코드가 기존 기능을 망가뜨릴 때 이를 감지.

- 리팩터링에 대한 저항성: 내부 구현이 바뀌더라도 테스트가 실패하지 않아야 함.
- 빠른 피드백: 테스트는 빠르게 실행되어야 함.
- 유지보수성: 읽기 쉽고, 외부 의존성이 적어야 유지비용이 낮음.

#### 테스트가 실행하는 코드의 양이 많을수록 좋은가?

-> 회귀로부터의 보호 지표를 극대화하려면, 테스트는 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.

#### 리팩터링 저항성을 가지려면 어떤 방식으로 테스트를 작성해야 하는가?
#### 테스트가 너무 빠르기만 하면 회귀 방지는 어떻게 보장하지?
#### 테스트가 작다고 꼭 유지보수가 쉬운가?

### 4.1.1 회귀로부터의 보호

- 회귀란 기존 동작이 새 코드 변경으로 인해 깨지는 것.
- 좋은 테스트는 도메인 중요도, 복잡도, 실행 코드량을 고려해 회귀를 감지해야 한다.

#### 사소한 코드(ex. getter/setter)도 테스트하는 게 의미 있을까?

### 4.1.2 리팩터링에 대한 저항력

- 리팩터링을 해도 테스트가 실패하지 않는 능력
- 테스트는 동작을 검증해야지, 내부 구현을 검사하면 안 된다.

#### 테스트가 내부 로직을 몰라도 되는 경우가 실제로 많을까?

### 4.1.3 거짓 양성의 원인

- 테스트가 구현 세부사항에 의존하면 거짓 양성이 발생.
- 테스트는 SUT의 관찰 가능한 결과만을 검증해야 하며, 내부 처리 방식은 신경 쓰지 않아야 한다.

#### 테스트가 내부 구현을 과도하게 검사하고 있지 않은가?

### 4.1.4 구현 대신 결과에 집중하라

- 테스트는 내부 구조가 아니라 최종 출력(예: HTML 문자열 등)을 검증해야 한다. 이렇게 하면 테스트는 리팩터링에 강하고 유지보수가 쉬워진다.

#### 4.2 첫 번째와 두 번째 속성의 연관성

- 회귀 방지(거짓 음성 최소화)와 리팩터링 저항성(거짓 양성 최소화)는 서로 다른 관점에서 테스트 정확도를 높인다.
- 정확도 = 신호 / (신호 + 잡음)

### 4.2.2 FP(False Positive)와 FN(False Negative)의 중요성 변화

- FP: 실제로는 문제가 없는데 테스트가 실패하는 경우
-  FN: 실제로는 문제가 있는데 테스트가 통과하는 경우 
- 프로젝트 초기에는 거짓 경고(FP)가 별로 중요하지 않지만, 시간이 지날수록 FP가 치명적으로 바뀜.
- 테스트는 장기적 유지보수 관점에서 설계해야 한다.

#### 초기에 FP를 무시해도 되는 기준이 있을까?

### 4.3 빠른 피드백과 유지보수성

- 빠른 피드백: 테스트가 빠르면 더 자주, 더 많이 실행 가능.

- 유지보수성: 코드가 읽기 쉽고 실행 환경이 단순해야 유지가 쉬움.

### 4.4 이상적인 테스트는 가능한가?

- 이상적인 테스트는 불가능.
- 리팩터링 저항성은 반드시 지켜야 하고,
- 회귀 방지와 빠른 피드백은 트레이드오프 관계이다.

### 4.4.2~4.4.4 극단적 사례들

- E2E 테스트: 회귀/리팩터링은 좋지만 느림.

- 사소한 테스트: 빠르고 안정적이지만 의미 없음.

- 취약한 테스트: 빠르고 예민하지만 너무 자주 깨짐.

### 4.5 테스트 피라미드와 테스트 방식 비교

- 테스트 피라미드는 단위 > 통합 > E2E 순으로 구성.

- 각 테스트는 리팩터링 저항성을 전제로 하며, 회귀 방지와 빠른 피드백 사이에서 역할 분담을 한다.

- 블랙박스 테스트를 선호해야 하며, 화이트박스는 분석용으로만 활용.

### 총정리 요약 팁

- 테스트는 네 가지 속성(회귀 방지, 리팩터링 저항성, 빠른 피드백, 유지보수성)을 조화롭게 갖춰야 한다.

- 이 속성 중 하나라도 0점이면 테스트 가치는 0이다.

- 리팩터링 저항성은 포기할 수 없는 기준이다.

- 테스트 피라미드를 따라 균형을 유지하되, 사소한/취약한 테스트는 과감히 제거해야 한다.

- 테스트는 결과 중심의 블랙박스 방식으로 작성하고, 구현 중심의 화이트박스 방식은 보조적으로 사용해야 함.

**💬 정리하면서 든 생각들**

테스트 커버리지 100% 같은 숫자에 집중하기보다는, 어떤 테스트가 정말 가치 있는가? 이 테스트가 없으면 무엇이 위험해지는가? 라는 질문이 더 중요하다는 생각이 듬.