# Part 2. 당신의 테스트가 당신을 위해 일하게 만들기
이제 단위 테스트의 목적에 대한 지식을 갖추었으니, 좋은 테스트를 만드는 핵심에 본격적으로 뛰어들고, 테스트를 더 가치 있게 리팩터링하는 방법을 배울 준비가 되었습니다. 4장에서는 좋은 단위 테스트를 구성하는 네 가지 핵심 기둥에 대해 배웁니다. 이 네 가지 기둥은 앞으로 단위 테스트와 테스트 접근 방식을 분석할 때 사용할 기초이자 공통된 기준점을 제공합니다.

5장에서는 4장에서 확립한 기준점을 바탕으로 목(mock)의 필요성과 테스트의 취약성과의 관계에 대해 설명합니다.

6장에서는 동일한 기준점을 사용하여 단위 테스트의 세 가지 스타일을 살펴봅니다. 그리고 이 중 어떤 스타일이 가장 높은 품질의 테스트를 만들어내는 경향이 있는지, 그리고 그 이유는 무엇인지 보여줍니다.

7장에서는 4장부터 6장까지의 지식을 실제로 적용하여 복잡하고 비대한 테스트에서 벗어나, 최소의 유지보수 비용으로 최대의 가치를 제공하는 테스트로 리팩터링하는 방법을 가르쳐줍니다.

# Ch 4. 좋은 단위 테스트의 네 가지 핵심 기둥
이번 장에서는 다음 내용을 다룹니다
- 좋은 단위 테스트의 여러 측면 간의 이분법 탐구
- 이상적인 테스트 정의
- 테스트 피라미드 이해하기
- 블랙박스 테스트와 화이트박스 테스트 사용하기

이제 본격적인 핵심 주제로 들어갑니다. 1장에서 여러분은 좋은 단위 테스트 슈트의 특성을 살펴보았습니다:
- 그것은 개발 주기에 통합되어 있습니다. 테스트는 적극적으로 사용할 때에만 가치가 있습니다. 그렇지 않으면 작성할 이유가 없습니다.
- 그것은 코드베이스에서 가장 중요한 부분만을 대상으로 합니다. 모든 프로덕션 코드가 동일한 주의를 받을 필요는 없습니다. 애플리케이션의 핵심(도메인 모델)과 그 외의 부분을 구분하는 것이 중요합니다. 이 주제는 7장에서 다룹니다.
- 그것은 최소한의 유지보수 비용으로 최대의 가치를 제공합니다. 이 마지막 속성을 달성하려면 다음을 할 수 있어야 합니다:
	- 가치 있는 테스트(그리고 확장하여 가치가 낮은 테스트)를 인식할 수 있어야 합니다
	- 가치 있는 테스트를 작성할 수 있어야 합니다

1장에서 논의했듯이, 가치 있는 테스트를 인식하는 것과 가치 있는 테스트를 작성하는 것은 서로 다른 두 가지 기술입니다. 그러나 후자는 전자를 필요로 합니다. 따라서 이 장에서는 가치 있는 테스트를 인식하는 방법을 보여드리겠습니다. 여러분은 테스트 스위트(suite)의 어떤 테스트든 분석할 수 있는 보편적인 참조 프레임을 보게 될 것입니다. 그 후, 이 참조 프레임을 사용하여 테스트 피라미드(Test Pyramid)와 블랙박스 테스트(black-box testing) 대 화이트박스 테스트(white-box testing) 같은 인기 있는 단위 테스트 개념들을 살펴보겠습니다.

자, 이제 시작합니다.

## 4.1 좋은 단위 테스트의 네 가지 핵심 기둥 깊이 파고들기
좋은 단위 테스트는 다음의 네 가지 속성을 갖습니다:
- 회귀로부터의 보호
- 리팩토링에 대한 저항성
- 빠른 피드백
- 유지보수성

이 네 가지 속성은 기초적입니다. 단위 테스트든, 통합 테스트든, 엔드 투 엔드 테스트든 모든 자동화 테스트는 이 네 가지 속성을 어느 정도씩 가지고 있습니다. 이 절에서는 처음 두 가지 속성을 정의하고, 4.2절에서는 그들 사이의 본질적인 연관성에 대해 설명합니다.

## 4.1.1 첫 번째 기둥: 회귀로부터의 보호
좋은 단위 테스트의 첫 번째 속성인 회귀로부터의 보호부터 살펴보겠습니다. 1장에서 다룬 바와 같이, 회귀(regression)란 소프트웨어 버그를 의미하며, 일반적으로 새로운 기능을 추가한 뒤 코드가 수정되면서 기존 기능이 의도대로 작동하지 않게 되는 현상을 말합니다.

이러한 회귀는 매우 성가시지만, 더 큰 문제는 따로 있습니다. 기능이 많아질수록 새 릴리스를 통해 기존 기능이 깨질 가능성도 함께 높아진다는 점입니다. 프로그래밍에서 불편한 진실은 코드가 자산이 아니라 부채라는 것입니다. 코드베이스가 커질수록 버그가 발생할 수 있는 위험도 그만큼 커지게 됩니다. 그렇기 때문에 회귀로부터의 확실한 보호 수단을 마련하는 것이 매우 중요합니다. 이러한 보호 없이는 프로젝트의 지속적인 성장을 기대할 수 없으며, 시간이 지날수록 점점 더 많은 버그로 인해 프로젝트가 무너질 수 있습니다.

회귀로부터의 보호라는 기준에서 테스트가 얼마나 잘 작동하는지를 평가하기 위해서는 다음과 같은 요소들을 고려해야 합니다:
- 테스트 중에 실행되는 코드의 양
- 해당 코드의 복잡도
- 해당 코드의 도메인 중요도

일반적으로 실행되는 코드의 양이 많을수록, 해당 테스트가 회귀를 발견할 가능성도 높아집니다. 물론 이는 테스트에 적절한 표명(assertion)이 포함되어 있다는 전제하에 해당하는 이야기입니다. 단순히 코드를 실행하는 것만으로는 충분하지 않습니다. 예외가 발생하지 않고 코드가 실행되는 것도 도움이 되지만, 그 코드가 실제로 어떤 결과를 만들어내는지를 검증하는 것도 중요합니다.

중요한 것은 코드의 양뿐만 아니라, 그 복잡성과 도메인 상의 중요성도 함께 고려해야 한다는 점입니다. 복잡한 비즈니스 로직을 포함한 코드는 단순 반복적인 보일러 플레이트 코드보다 훨씬 중요합니다. 비즈니스에 중요한 기능에서 발생하는 버그는 가장 큰 피해를 유발하기 때문입니다.

반면, 사소한 코드를 테스트하는 것은 거의 가치가 없습니다. 이런 코드는 짧고, 실질적인 비즈니스 로직을 거의 포함하지 않기 때문입니다. 사소한 코드를 다루는 테스트는 회귀 오류를 찾아낼 가능성이 낮습니다. 왜냐하면 실수할 수 있는 여지가 거의 없기 때문입니다. 다음은 그런 사소한 코드의 예시입니다:

```c#
public class User
{
	public string Name { get; set; }
}
```

게다가 여러분이 작성한 코드뿐만 아니라, 직접 작성하지 않은 코드도 중요합니다. 예를 들어, 라이브러리, 프레임워크, 그리고 프로젝트에서 사용하는 외부 시스템들이 여기에 해당합니다. 이러한 코드들은 여러분의 소프트웨어 동작에 거의 동일한 수준으로 영향을 미칩니다. 최상의 회귀 방지를 위해서는 테스트 범위에 이러한 라이브러리, 프레임워크, 외부 시스템까지 포함되어야 합니다. 그래야만 여러분의 소프트웨어가 이러한 의존성들에 대해 갖고 있는 가정들이 올바른지 확인할 수 있습니다.

> **TIP)** 회귀로부터의 보호 지표를 극대화하려면, 테스트는 가능한 한 많은 코드를 실행하는 것을 목표로 해야 합니다.

## 4.1.2 두 번째 기둥: 리팩터링에 대한 저항력
좋은 단위 테스트의 두 번째 속성은 리팩터링에 대한 저항력입니다. 이는 테스트가 기반이 되는 애플리케이션 코드를 리팩터링하더라도 실패하지 않고(빨갛게 변하지 않고) 견딜 수 있는 정도를 말합니다.

> **DEFINITION)** 리팩터링이란 기존 코드를 외부에서 보이는 동작을 변경하지 않고 수정하는 것을 의미합니다. 일반적으로 리팩터링의 목적은 코드의 비기능적 특성을 개선하는 데 있으며, 가독성을 높이고 복잡성을 줄이는 것이 그 예입니다. 메서드 이름을 바꾸거나 코드 일부를 새로운 클래스로 추출하는 것 등이 리팩터링의 예입니다.

이런 상황을 상상해 보세요. 새로운 기능을 개발했고, 모든 것이 잘 작동합니다. 기능 자체는 제 역할을 하고 있고, 모든 테스트도 통과했습니다. 이제 코드를 정리하고 싶어졌습니다. 여기저기 리팩터링을 조금씩 하고 나니, 모든 것이 전보다 훨씬 좋아 보입니다. 단 한 가지를 제외하고는 말이죠—테스트가 실패합니다. 무엇을 망가뜨렸는지 확인하려고 자세히 들여다보지만, 실제로는 아무 것도 망가뜨리지 않았다는 것을 알게 됩니다. 기능은 여전히 완벽하게 작동합니다. 문제는 테스트가 기저 코드를 조금만 수정해도 실패하도록 작성되어 있다는 점입니다. 그리고 이는 실제 기능이 망가졌는지 여부와 상관없이 발생합니다.

이런 상황을 가리켜 거짓 양성(false positive)이라고 합니다. 거짓 양성이란 잘못된 경고, 즉 테스트가 실패했다고 표시하지만, 실제로는 해당 기능이 의도한 대로 잘 작동하고 있는 경우를 말합니다. 이러한 거짓 양성은 보통 코드를 리팩터링할 때 발생합니다—즉, 구현을 수정하지만 눈에 보이는 동작은 그대로 유지하는 경우입니다. 그래서 좋은 단위 테스트의 속성 중 하나가 리팩터링에 대한 저항력(resistance to refactoring)인 것입니다.

테스트가 리팩터링에 대한 저항력이라는 지표에서 얼마나 좋은 점수를 받을 수 있는지를 평가하려면, 그 테스트가 얼마나 자주 거짓 양성을 발생시키는지를 살펴봐야 합니다. 거짓 양성이 적을수록 더 좋은 테스트입니다.

왜 거짓 양성(false positive)에 그렇게 많은 주의를 기울여야 할까요? 그 이유는 거짓 양성이 전체 테스트 스위트에 심각한 영향을 줄 수 있기 때문입니다. 1장에서 언급했듯이, 단위 테스트의 목표는 프로젝트의 지속 가능한 성장을 가능하게 하는 것입니다. 테스트가 이러한 성장을 가능하게 하는 메커니즘은, 새로운 기능을 추가하거나 정기적인 리팩터링을 수행해도 회귀가 발생하지 않도록 해주는 것입니다. 여기에는 두 가지 구체적인 이점이 있습니다:
- 테스트는 기존 기능이 깨졌을 때 조기에 경고를 제공합니다. 이러한 조기 경고 덕분에 문제가 있는 코드를 실제 운영 환경에 배포하기 훨씬 전에 수정할 수 있습니다. 운영 환경에서 문제를 처리하는 것보다 훨씬 적은 노력으로 해결할 수 있습니다.
- 코드 변경이 회귀로 이어지지 않을 것이라는 확신을 얻게 됩니다. 이런 확신이 없다면 리팩터링을 주저하게 되고, 결국 코드베이스가 점점 더 악화될 가능성이 높아집니다.

거짓 양성(false positive)은 이러한 두 가지 이점을 모두 방해합니다:

- 테스트가 특별한 이유 없이 실패한다면, 코드상의 문제에 반응하려는 능력과 의지를 약화시킵니다. 시간이 지나면 이러한 실패에 익숙해지고, 점차 주의를 기울이지 않게 됩니다. 결국에는 실제로 문제가 있는 실패조차도 무시하게 되어, 그 문제가 운영 환경까지 넘어가게 됩니다.
- 반대로, 거짓 양성이 자주 발생하면 테스트 스위트에 대한 신뢰를 잃게 됩니다. 테스트 스위트를 더 이상 신뢰할 수 있는 안전망으로 인식하지 않게 되며, 반복되는 허위 경고 때문에 그 신뢰가 약화됩니다. 이러한 신뢰 부족은 리팩터링의 감소로 이어지며, 회귀를 피하기 위해 코드 변경을 가능한 한 최소화하려는 경향이 생깁니다.


> **현장에서 있었던 이야기**

> 제가 한 프로젝트에서 일한 적이 있었습니다. 그 프로젝트는 그렇게 오래되지는 않았지만, 약 2~3년 정도의 이력이 있었습니다. 그 사이에 경영진은 프로젝트의 방향을 크게 바꾸었고, 개발 역시 그에 따라 방향을 전환하게 되었습니다. 이 변화 과정에서 하나의 문제가 발생했습니다. 코드베이스에 더 이상 사용되지 않는 많은 양의 코드가 남게 되었고, 아무도 그 코드를 삭제하거나 리팩터링하려 하지 않았습니다. 회사는 더 이상 해당 코드가 제공하는 기능을 필요로 하지 않았지만, 그 코드의 일부는 새로운 기능에서도 사용되고 있었기 때문에 완전히 제거하는 것이 불가능했습니다.

> 그 프로젝트는 테스트 커버리지가 잘 되어 있는 편이었습니다. 그러나 누군가가 오래된 기능을 리팩터링하려 하거나, 여전히 사용 중인 부분을 나머지 코드와 분리하려고 시도할 때마다 테스트가 실패하곤 했습니다. 그것도 단지 오래된 테스트만이 아니라, 최근에 작성된 테스트들조차 실패했습니다. 일부 실패는 정당했지만, 대부분은 그렇지 않았습니다. 거짓 양성이었습니다.

> 처음에는 개발자들이 이러한 테스트 실패에 대응하려고 노력했습니다. 하지만 대부분이 허위 경고였기 때문에, 결국에는 테스트 실패를 무시하게 되었고, 실패한 테스트를 비활성화시키는 상황에 이르렀습니다. 개발자들 사이에서는 “그 오래된 코드 때문이면 그냥 테스트 꺼버려요. 나중에 확인하죠.”라는 태도가 일반적이었습니다.

> 모든 것이 한동안은 잘 작동하는 듯했습니다. 그러다 결국 심각한 버그가 운영 환경에 반영되고 말았습니다. 사실 그 버그는 테스트 중 하나가 정확히 찾아낸 것이었지만, 그 테스트는 다른 테스트들과 함께 이미 비활성화된 상태였기 때문에 아무도 신경 쓰지 않았습니다. 그 사고 이후로 개발자들은 아예 그 오래된 코드에 손을 대지 않게 되었습니다.

이 이야기는 취약한 테스트를 가진 대부분의 프로젝트에서 흔히 볼 수 있는 유형입니다. 처음에는 개발자들이 테스트 실패를 그대로 받아들이고 적절히 대응합니다. 하지만 시간이 지나면서 테스트가 계속해서 “늑대가 나타났다”고 외치자, 사람들은 점점 이를 무시하게 됩니다. 결국 어느 순간, 실제 버그들이 무더기로 운영 환경에 배포되는 일이 발생합니다. 왜냐하면 개발자들이 거짓 양성과 함께 진짜 실패까지 모두 무시하게 되었기 때문입니다.

이런 상황에 대한 반응으로 모든 리팩터링을 중단하는 것은 올바른 방법이 아닙니다. 올바른 대응은 테스트 스위트(suite)를 재평가하고, 그 취약성을 줄이기 시작하는 것입니다. 이 주제는 7장에서 다루겠습니다.

## 4.1.3 거짓 양성(False Positive)은 무엇 때문에 발생할까요?
그렇다면 거짓 양성(false positive)은 무엇 때문에 발생할까요? 그리고 이를 어떻게 피할 수 있을까요?

테스트가 만들어내는 거짓 양성의 수는 테스트가 시스템의 구현 세부사항(시스템 언더 테스트, SUT)에 얼마나 밀접하게 결합되어 있는지와 직접적인 관련이 있습니다. 테스트가 SUT의 구현 방식에 더 많이 의존할수록, 거짓 경고를 더 많이 만들어냅니다. 거짓 양성의 가능성을 줄이는 유일한 방법은 테스트를 이러한 구현 세부사항으로부터 분리하는 것입니다. 테스트는 SUT가 제공하는 최종 결과, 즉 외부에서 관찰 가능한 동작만을 검증해야 합니다. 그 과정에서 어떤 단계를 거치는지는 중요하지 않습니다. 테스트는 SUT의 동작을 최종 사용자 관점에서 바라보고, 사용자에게 의미 있는 결과만을 검증해야 합니다. 그 외의 모든 것은 무시해야 합니다 (이 주제는 5장에서 더 자세히 다룹니다).

테스트를 구성하는 가장 좋은 방법은 문제 도메인에 관한 이야기를 들려주는 방식으로 만드는 것입니다. 이런 테스트가 실패할 경우, 그 실패는 이야기와 실제 애플리케이션 동작 사이에 불일치가 있음을 의미합니다. 이러한 종류의 실패는 항상 본질적인 문제를 지적해 주며, 무엇이 잘못되었는지를 빠르게 이해하는 데 도움을 줍니다. 그 외의 실패들은 단지 잡음(noise)에 불과하며, 중요한 것에서 주의를 빼앗는 원인이 됩니다.

다음은 예시입니다. 이 예시에서 `MessageRenderer` 클래스는 메시지의 HTML 표현을 생성합니다. 메시지는 헤더, 본문, 그리고 푸터로 구성됩니다.

---
### Listing 4.1 Generating an HTML representation of a message
```c#
public class Message
{
	public string Header { get; set; }
	public string Body { get; set; }
	public string Footer { get; set; }
}

public interface IRenderer
{
	string Render(Message message);
}

public class MessageRenderer : IRenderer
{
	public IReadOnlyList<IRenderer> SubRenderers { get; }

	public MessageRenderer()
	{
		SubRenderers = new List<IRenderer>
		{
			new HeaderRenderer(),
			new BodyRenderer(),
			new FooterRenderer()
		};
	}

	public string Render(Message message)
	{
		return SubRenderers
			.Select(x => x.Render(message))
			.Aggregate("", (str1, str2) => str1 + str2);
	}
}
```

`MessageRenderer` 클래스는 여러 하위 렌더러(sub-renderer)를 포함하고 있으며, 메시지의 각 부분에 대한 실제 작업을 이 하위 렌더러들에게 위임합니다. 그런 다음 `MessageRenderer`는 이 결과들을 하나로 결합하여 HTML 문서를 만듭니다. 하위 렌더러들은 원시 텍스트(raw text)를 HTML 태그와 함께 구성합니다. 예를 들어 다음과 같습니다:

```c#
public class BodyRenderer : IRenderer
{
	public string Render(Message message)
	{
		return $"<b>{message.Body}</b>";
	}
}
```

`MessageRenderer`는 어떻게 테스트할 수 있을까요? 하나의 가능한 접근 방식은 이 클래스가 따르는 알고리즘을 분석하는 것입니다.

---
### Listing 4.2 Verifying that `MessageRenderer` has the correct structure
```c#
public void MessageRenderer_uses_correct_sub_renderers()
{

	var sut = new MessageRenderer();

	IReadOnlyList<IRenderer> renderers = sut.SubRenderers;

	Assert.Equal(3, renderers.Count);

	Assert.IsAssignableFrom<HeaderRenderer>(renderers[0]);
	Assert.IsAssignableFrom<BodyRenderer>(renderers[1]);
  Assert.IsAssignableFrom<FooterRenderer>(renderers[2]);
}
```

이 테스트는 하위 렌더러들이 모두 예상된 타입인지, 그리고 올바른 순서로 나타나는지를 확인합니다. 이는 `MessageRenderer`가 메시지를 처리하는 방식 또한 올바르다는 전제를 가집니다. 이 테스트는 처음에는 좋아 보일 수 있지만, 실제로 `MessageRenderer`의 관찰 가능한 동작을 검증하고 있을까요? 하위 렌더러의 순서를 바꾸거나, 그 중 하나를 새로운 것으로 대체하면 어떻게 될까요? 과연 그런 변화가 버그로 이어질까요?

꼭 그렇지는 않습니다. 하위 렌더러 구성을 바꾸더라도, 생성되는 HTML 문서가 동일하게 유지될 수 있습니다. 예를 들어, `BodyRenderer`를 `BoldRenderer`로 교체할 수 있으며, 이 두 렌더러가 같은 역할을 수행할 수도 있습니다. 또는 모든 하위 렌더러를 제거하고, 렌더링 작업을 `MessageRenderer` 내부에서 직접 구현할 수도 있습니다.

그러나 이러한 변경을 하면 테스트는 실패하게 됩니다. 비록 최종 결과는 바뀌지 않았더라도 말입니다. 그 이유는 이 테스트가 SUT의 구현 세부사항에 결합되어 있고, SUT가 생성하는 결과 자체에는 관심이 없기 때문입니다. 이 테스트는 알고리즘을 들여다보며, 특정한 구현 방식만을 기대합니다. 동등하게 적용 가능한 다른 구현 방식은 고려하지 않습니다 (그림 4.1 참고).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 02 32" src="https://github.com/user-attachments/assets/a42e6681-f3b0-4d2d-a0d3-3111b3b68aff" />

> _**그림 4.1)**_ SUT의 알고리즘에 결합된 테스트. 이러한 테스트는 특정한 구현 방식(SUT가 결과를 생성하기 위해 반드시 따라야 하는 구체적인 단계들)을 기대하기 때문에 취약합니다. SUT의 구현을 리팩터링하면 테스트는 실패하게 됩니다.

`MessageRenderer` 클래스의 주요 리팩터링이 이루어지면, 해당 테스트는 실패하게 됩니다. 리팩터링이란 애플리케이션의 관찰 가능한 동작에는 영향을 주지 않으면서 구현을 변경하는 과정입니다. 그리고 바로 그 구현 세부사항에 대해 테스트가 신경을 쓰기 때문에, 그 세부사항을 변경할 때마다 테스트가 실패하게 됩니다.

따라서, 시스템의 구현 세부사항에 결합된 테스트는 리팩터링에 강하지 않습니다. 이러한 테스트는 앞서 설명한 모든 단점을 그대로 드러냅니다:
- 회귀가 발생했을 때 조기 경고를 제공하지 못합니다. 왜냐하면 해당 경고들이 실제와 거의 관련이 없기 때문에 무시되기 때문입니다.
- 리팩터링에 대한 개발자의 능력과 의지를 방해합니다. 테스트가 버그를 제대로 감지하지 못하는데, 누가 리팩터링을 하고 싶어 하겠습니까?

다음 목록은 제가 본 테스트 중 가장 심각한 수준의 취약성을 가진 예시로, `MessageRenderer` 클래스의 소스 코드를 읽고 이를 "올바른" 구현과 비교합니다.

---
### Listing 4.3 Verifying the source code of the `MessageRenderer` class
```c#
public void MessageRenderer_is_implemented_correctly()
{
    string sourceCode = File.ReadAllText(@"[path]\MessageRenderer.cs");
    Assert.Equal(@"
public class MessageRenderer : IRenderer
{
    public IReadOnlyList<IRenderer> SubRenderers { get; }

    public MessageRenderer()
    {
        SubRenderers = new List<IRenderer>
        {
            new HeaderRenderer(),
            new BodyRenderer(),
            new FooterRenderer()
        };
    }

    public string Render(Message message) { /* ... */ }
}", sourceCode);
}
```

물론 이 테스트는 말도 안 되게 터무니없습니다. `MessageRenderer` 클래스를 아주 조금만 수정해도 실패하게 됩니다. 동시에, 앞서 언급한 테스트와 그리 다르지도 않습니다. 두 테스트 모두 SUT의 관찰 가능한 동작은 고려하지 않고 특정 구현 방식만을 고집합니다. 그리고 구현을 변경할 때마다 두 테스트 모두 실패하게 됩니다. 물론 인정하자면, 리스트 4.3의 테스트가 리스트 4.2의 테스트보다 더 자주 깨질 것입니다.

## 4.1.4 구현 세부사항 대신 최종 결과를 목표로 하라
앞서 언급했듯이, 테스트의 취약성을 피하고 리팩터링에 대한 저항력을 높이는 유일한 방법은 테스트를 시스템의 구현 세부사항에서 분리하는 것입니다. 테스트와 코드 내부 동작 사이에 가능한 한 많은 거리를 두고, 대신 최종 결과를 검증하는 데 집중해야 합니다. 그럼 그렇게 해봅시다. listing 4.2에 있는 테스트를 훨씬 덜 취약하게 리팩터링해 보겠습니다.

먼저, 다음과 같은 질문을 스스로에게 던져야 합니다. `MessageRenderer`로부터 얻는 최종 결과는 무엇인가요? 그것은 메시지의 HTML 표현입니다. 그리고 그 HTML 표현만이 확인할 가치가 있는 유일한 것이며, 클래스에서 얻을 수 있는 유일한 관찰 가능한 결과입니다. 이 HTML 표현이 동일하게 유지되는 한, 그것이 어떻게 생성되는지는 걱정할 필요가 없습니다. 그런 구현 세부사항은 무관한 것입니다. 다음 코드는 새롭게 작성된 테스트 버전입니다.

---
### Listing 4.4 Verifying the outcome that `MessageRenderer` produces
```c#
public void Rendering_a_message()
{
	var sut = new MessageRenderer();
	var message = new Message
	{
	Header = "h",
	Body = "b",
	Footer = "f"
	};

	string html = sut.Render(message);

	Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);

}
```
이 테스트는 `MessageRenderer`를 블랙박스로 다루며, 오직 그 관찰 가능한 동작에만 관심을 둡니다. 그 결과, 이 테스트는 리팩터링에 훨씬 더 강한 저항력을 가지게 됩니다. HTML 출력이 동일하게 유지되는 한, 시스템 내부 코드에 어떤 변경을 가하든지 상관하지 않습니다(그림 4.2 참고).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 10 54" src="https://github.com/user-attachments/assets/5e94884e-4713-4594-9d6b-50c28af137ab" />

> _**그림 4.2)**_ 왼쪽에 있는 테스트는 SUT의 구현 세부사항이 아니라 관찰 가능한 동작에 결합되어 있습니다. 이러한 테스트는 리팩토링에 강하며, 거짓 양성을 거의 발생시키지 않습니다.

이 테스트가 원래 버전보다 현저히 개선된 점을 주목해 주십시오. 이 테스트는 비즈니스 요구에 부합하게, 최종 사용자에게 의미 있는 유일한 결과—즉, 메시지가 브라우저에 어떻게 표시되는지를 검증합니다. 이러한 테스트의 실패는 항상 본질적인 의미를 가지며, 고객에게 영향을 줄 수 있는 애플리케이션 동작의 변화를 전달하므로 반드시 개발자의 주의를 환기시켜야 합니다. 이 테스트는 거짓 양성(false positive)을 거의 발생시키지 않습니다.

그렇다면 왜 “전혀 없다”가 아니라 “거의 없다”고 표현할까요? 그것은 MessageRenderer에 가해진 변경 사항이 여전히 테스트를 깨뜨릴 수 있기 때문입니다. 예를 들어, Render() 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있습니다. 기술적으로 이러한 오류도 거짓 양성으로 간주됩니다. 결국, 테스트가 실패하는 이유는 애플리케이션의 동작 변화 때문이 아니라 컴파일 오류 때문입니다.

하지만 이러한 유형의 거짓 양성은 쉽게 수정할 수 있습니다. 컴파일러의 지시에 따라 Render() 메서드를 호출하는 모든 테스트에 새 매개변수를 추가하면 됩니다. 더 문제 되는 거짓 양성은 컴파일 오류로 이어지지 않는 경우입니다. 이 경우는 실제 버그처럼 보이기 때문에 문제를 파악하고 해결하는 데 훨씬 더 많은 시간이 소요됩니다.

## 4.2 첫 번째와 두 번째 속성 간의 본질적인 연관성
앞서 말씀드렸듯이, 좋은 단위 테스트의 첫 번째와 두 번째 핵심 요소—회귀 방지와 리팩터링 저항성—사이에는 본질적인 연관성이 있습니다. 이 두 속성은 서로 반대되는 관점에서 테스트 슈트의 정확도를 높이는 데 기여합니다. 또한 이 두 속성은 시간이 지남에 따라 프로젝트에 서로 다른 방식으로 영향을 미칩니다. 프로젝트가 시작된 직후에는 회귀 방지가 매우 중요하지만, 리팩터링 저항성의 필요성은 즉각적으로 나타나지는 않습니다.

이번 섹션에서는 다음 주제에 대해 설명합니다:
- 테스트 정확도 극대화
- 거짓 양성(false positive) 및 거짓 음성(false negative)의 중요성

## 4.2.1 테스트 정확도 극대화하기
잠시 한 걸음 물러나 테스트 결과와 코드의 정확성에 대한 더 넓은 관점을 살펴보겠습니다. 코드의 정확성과 테스트 결과를 기준으로 할 때, 가능한 결과는 네 가지입니다. 이는 그림 4.3에서 볼 수 있습니다. 테스트는 통과하거나 실패할 수 있으며(표의 행), 기능 자체는 올바르거나 문제가 있을 수 있습니다(표의 열).

기능이 올바르게 작동하고 테스트가 통과할 때의 상황은 정확한 추론입니다. 즉, 테스트가 시스템의 상태(버그가 없다는 것)를 정확하게 추론한 것입니다. 이처럼 기능이 정상이고 테스트가 통과하는 조합을 "참 음성(true negative: TN)"이라고 합니다.

마찬가지로, 기능에 문제가 있고 테스트가 실패하는 경우에도 이것은 정확한 추론입니다. 기능이 제대로 작동하지 않을 때 테스트가 실패하기를 기대하는 것이 바로 단위 테스트의 핵심 목적이기 때문입니다. 이러한 상황을 "참 양성(true positive: TP)"이라고 합니다.

<img width="1080" alt="스크린샷 2025-06-03 오전 1 17 35" src="https://github.com/user-attachments/assets/1e8d1d54-482e-400e-bc5e-d9ae3288f7c7" />

> _**그림 4.3)**_ 회귀 방지 능력과 리팩터링 저항성 간의 관계는 다음과 같습니다. 회귀 방지 능력은 거짓 음성(Type II 오류)을 방지해주며, 리팩터링 저항성은 거짓 양성(Type I 오류)의 수를 최소화해줍니다.

하지만 테스트가 오류를 잡아내지 못할 때, 문제가 발생합니다. 이것은 우측 상단 사분면, 즉 거짓 음성(false negative: FN)의 경우입니다. 그리고 이것이 바로 좋은 테스트의 첫 번째 속성인 회귀 방지 능력(protection against regressions)이 피하려고 하는 상황입니다. 회귀 방지 능력이 좋은 테스트는 거짓 음성(Type II 오류)의 수를 최소화하는 데 도움을 줍니다.

반면, 기능에는 아무 문제가 없지만 테스트가 실패하는 경우도 있습니다. 이것은 거짓 양성(false positive:FP), 즉 잘못된 경고입니다. 이것이 바로 두 번째 속성인 리팩토링에 대한 저항성(resistance to refactoring)이 도움을 주는 부분입니다.

이러한 용어들(거짓 양성, Type I 오류 등)은 원래 통계학에서 비롯되었지만, 테스트 스위트를 분석할 때도 적용할 수 있습니다. 이 개념들을 이해하기 가장 좋은 방법은 독감 검사를 예로 드는 것입니다. 독감 검사는 검사자가 독감에 걸렸을 때 양성(positive)으로 나옵니다. 여기서 “양성”이라는 용어는 혼란스러울 수 있는데, 독감에 걸린 것이 결코 좋은 일이 아니기 때문입니다. 하지만 테스트는 상황 전체를 평가하는 것이 아니라, 특정 조건이 참인지 여부만을 판단합니다. 이 예에서 테스트가 반응하도록 설정된 조건은 “독감에 걸려 있음”입니다. 반대로, 독감이 없을 경우 테스트 결과는 음성(negative)으로 나옵니다.

이러한 정확성이야말로 좋은 단위 테스트의 첫 번째와 두 번째 핵심 속성이 지향하는 바입니다. 회귀 방지 능력과 리팩토링에 대한 저항성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 합니다. 이 정확도 지표는 다음 두 가지 요소로 구성됩니다:
- 버그가 존재함을 얼마나 잘 나타내는가 (거짓 음성의 부재 — 회귀 방지 능력의 영역)
- 버그가 존재하지 않음을 얼마나 잘 나타내는가 (거짓 양성의 부재 — 리팩토링 저항성의 영역)

<img width="1080" alt="스크린샷 2025-06-03 오전 1 21 07" src="https://github.com/user-attachments/assets/06b565c3-6e64-44be-91ac-164529d7f919" />

> _**그림 4.4)**_ 테스트는 신호(버그를 찾아내는 능력)가 강하고, 잡음(거짓 경보)이 적을수록 정확도가 높습니다.

거짓 긍정과 거짓 부정을 이해하는 또 다른 방법은 신호 대 잡음 비율(signal-to-noise ratio)의 관점에서 생각하는 것입니다. 그림 4.4의 수식에서 볼 수 있듯이, 테스트 정확도를 향상시키는 방법에는 두 가지가 있습니다. 첫 번째는 분자, 즉 신호(signal)를 증가시키는 것입니다. 이는 테스트가 회귀 버그를 더 잘 찾아내도록 만드는 것을 의미합니다. 두 번째는 분모, 즉 잡음(noise)을 줄이는 것입니다. 이는 테스트가 거짓 경보를 덜 발생시키도록 만드는 것입니다.

두 가지 모두 매우 중요합니다. 거짓 경보가 전혀 없다고 하더라도 버그를 찾아내지 못하는 테스트는 쓸모가 없습니다. 마찬가지로, 코드의 모든 버그를 찾아낼 수 있다고 해도, 잡음이 너무 많아진다면 테스트의 정확도는 0에 수렴하게 됩니다. 그런 유용한 정보들조차 무의미한 정보의 바다 속에 묻혀 버리기 때문입니다.

## 4.2.2 거짓 양성(false positive)과 거짓 음성(false negative)의 중요성: 동적 변화

단기적으로는 거짓 양성(false positive:FP)이  거짓음성(false negative:FN)만큼 나쁘지는 않습니다. 프로젝트 초반에는 잘못된 경고를 받는 것이, 경고를 전혀 받지 못해 버그가 프로덕션에 반영될 위험을 감수하는 것보다는 그다지 큰 문제가 되지 않습니다. 그러나 프로젝트가 성장함에 따라, 거짓 양성은 테스트 스위트(suite)에 점점 더 큰 영향을 미치기 시작합니다 (그림 4.5 참조).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 23 45" src="https://github.com/user-attachments/assets/ed96f405-1b2e-497b-a27f-125fd0e5f68d" />

> _**그림 4.5)**_ 거짓 양성(잘못된 경고)은 초기에는 그다지 부정적인 영향을 미치지 않습니다. 그러나 프로젝트가 커질수록 그 영향은 점점 더 커지며, 결국 거짓 음성(발견되지 않은 버그)만큼이나 중요해집니다.

왜 거짓 양성(잘못된 경고)이 초반에는 그렇게 중요하지 않을까요? 그것은 코드 리팩터링의 중요성 또한 프로젝트 초기에는 크지 않기 때문입니다. 프로젝트 초기에 많은 코드 정리를 수행할 필요는 없습니다. 새로 작성된 코드는 대개 깔끔하고 결함이 없으며, 또한 그 코드가 아직 기억에 생생하기 때문에 테스트가 잘못된 경고를 보내더라도 쉽게 리팩터링할 수 있습니다.

하지만 시간이 지나면서 코드베이스는 점점 열화됩니다. 복잡해지고 구조가 흐트러지죠. 이런 경향을 완화하기 위해서는 주기적으로 리팩터링을 수행해야 합니다. 그렇지 않으면 새로운 기능을 도입하는 데 드는 비용이 점점 감당할 수 없을 정도로 커지게 됩니다.

리팩터링의 필요성이 커짐에 따라, 테스트의 리팩터링 저항성 또한 점점 더 중요해집니다. 앞서 설명했듯이, 테스트가 자꾸 거짓 경고를 보내고, 실제로는 존재하지 않는 버그에 대해 경고한다면 리팩터링을 진행할 수 없습니다. 그런 테스트는 신뢰를 잃게 되고, 더 이상 신뢰할 수 있는 피드백 수단으로 보지 않게 됩니다.

코드가 거짓 양성으로부터 보호받을 수 있도록 하는 것은 프로젝트 후반부에 특히 중요하지만, 대부분의 개발자들은 이를 그렇게 인식하지 않습니다. 많은 사람들이 좋은 유닛 테스트의 첫 번째 속성인 회귀 방지 능력(버그를 놓치지 않는 능력) 개선에만 집중합니다. 그러나 이것만으로는 프로젝트 성장을 지속적으로 지원할 수 있는 가치 있고 정확한 테스트 스위트를 만들 수 없습니다.

그 이유는 대부분의 프로젝트가 후반 단계에 도달하지 않기 때문입니다. 대부분 소규모 프로젝트이며, 프로젝트가 너무 커지기 전에 개발이 끝나기 때문입니다. 따라서 개발자들은 잘못된 경고보다 놓친 버그 문제를 더 자주 겪게 됩니다. 그래서 이에 맞춰 테스트를 최적화하는 것이죠.

하지만 여러분이 중간 규모 이상, 혹은 장기적인 프로젝트에 참여하고 있다면, 거짓음성(놓친 버그)과 거짓 양성(잘못된 경고) 모두에 똑같은 수준의 주의를 기울여야 합니다.

## 4.3 세 번째와 네 번째 핵심 요소: 빠른 피드백과 유지 보수성
이 섹션에서는 좋은 단위 테스트의 나머지 두 가지 핵심 요소에 대해 다룹니다:  
- 빠른 피드백  
- 유지 보수성
2장에서 언급했듯이, 빠른 피드백은 단위 테스트의 필수 속성입니다. 테스트가 빠를수록 더 많은 테스트를 테스트 스위트에 포함할 수 있고, 더 자주 실행할 수 있습니다.

테스트가 빠르게 실행되면 피드백 루프를 획기적으로 단축할 수 있어서, 코드를 망가뜨리자마자 테스트가 바로 버그를 경고해 주고, 결과적으로 해당 버그를 수정하는 비용을 거의 0에 가깝게 줄일 수 있습니다. 반면, 느린 테스트는 피드백을 지연시키고, 그로 인해 버그가 인지되지 않은 채로 남아 있는 기간이 길어질 수 있어 수정 비용이 증가합니다.

이는 느린 테스트가 자주 실행되는 것을 꺼리게 만들기 때문이며, 결국 잘못된 방향으로 개발을 진행하는 데 더 많은 시간을 낭비하게 만듭니다.

마지막으로, 좋은 단위 테스트의 네 번째 핵심 요소인 유지 보수성 척도는 테스트의 유지 비용을 평가합니다. 이 척도는 두 가지 주요 요소로 구성됩니다:
- 테스트를 이해하기 얼마나 어려운가 — 이 요소는 테스트의 크기와 관련이 있습니다. 테스트 코드의 줄 수가 적을수록 더 읽기 쉬운 테스트가 됩니다. 또한, 테스트가 작을수록 필요할 때 수정하기도 더 쉽습니다. 물론, 줄 수를 줄이기 위해 테스트 코드를 인위적으로 압축하지 않는다는 전제하에 그렇습니다. 테스트 코드의 품질도 실제 코드만큼 중요합니다. 테스트를 작성할 때 절대로 대충하지 마시고, 테스트 코드도 주요 코드와 동등하게 취급하셔야 합니다.
- 테스트를 실행하기 얼마나 어려운가 — 테스트가 프로세스 외부의 의존성과 함께 작동하는 경우, 해당 의존성을 유지하기 위해 시간을 들여야 합니다. 예를 들어, 데이터베이스 서버를 재시작하거나 네트워크 연결 문제를 해결하는 등의 작업이 필요할 수 있습니다.

## 4.4 이상적인 테스트를 찾아서
다시 한 번, 좋은 단위 테스트의 네 가지 속성은 다음과 같습니다:
- 회귀 방지
- 리팩터링에 대한 저항성
- 빠른 피드백
- 유지 보수성

이 네 가지 속성은 곱셈처럼 서로 결합되어 테스트의 가치를 결정합니다. 여기서 "곱셈"이라는 말은 수학적인 의미로, 어느 한 속성이라도 0점을 받는다면 해당 테스트의 전체 가치도 0이 된다는 뜻입니다.

> **TIP)** 테스트가 가치 있으려면 네 가지 항목 모두에서 최소한의 점수는 받아야 합니다.

물론 이러한 속성들을 정확하게 측정하는 것은 불가능합니다. 테스트를 어떤 코드 분석 도구에 연결해서 정확한 수치를 얻는 방법은 없습니다. 그러나 여전히 테스트가 네 가지 속성에 대해 어느 정도 위치에 있는지 꽤 정확하게 평가할 수는 있습니다. 이러한 평가는 테스트의 가치 추정치를 제공하며, 이를 통해 해당 테스트를 테스트 스위트(Suite)에 유지할지 여부를 결정할 수 있습니다.

기억하세요, 테스트 코드를 포함한 모든 코드는 부채입니다. 최소 요구 가치를 위한 기준을 꽤 높게 설정하고, 이 기준을 충족하는 테스트만 스위트(Suite)에 포함시키세요. 소수의 매우 가치 있는 테스트들이 수많은 보통 수준의 테스트들보다 프로젝트 성장을 지속시키는 데 훨씬 더 효과적입니다.

곧 몇 가지 예시를 보여드리겠습니다. 지금은 이상적인 테스트를 만드는 것이 가능한지부터 살펴보겠습니다.

## 4.4.1 이상적인 테스트를 만드는 것이 가능할까요?
이상적인 테스트란 네 가지 속성 모두에서 최고 점수를 받은 테스트를 말합니다. 각 속성의 최소값과 최대값을 0과 1로 본다면, 이상적인 테스트는 모든 항목에서 1점을 받아야 합니다.

하지만 불행히도, 그런 이상적인 테스트를 만드는 것은 불가능합니다. 그 이유는 첫 번째 세 가지 속성—회귀 방지, 리팩터링에 대한 저항성, 빠른 피드백—이 서로 상충되기 때문입니다. 이 세 가지를 모두 극대화하는 것은 불가능하며, 나머지 두 가지를 극대화하려면 하나를 희생해야 합니다.

게다가 앞서 언급한 곱셈 원칙 때문에 균형을 유지하는 것이 더욱 까다롭습니다. 단순히 하나의 속성을 포기하고 나머지에 집중한다고 해서 해결되는 것이 아닙니다. 앞서 언급했듯이, 네 가지 항목 중 하나라도 0점을 받으면 그 테스트는 무가치해집니다. 따라서 어떤 속성도 지나치게 낮아지지 않도록 조심하면서 이 속성들을 최대한 끌어올려야 합니다.

다음은 세 가지 속성 중 두 가지를 극대화하려고 하다가 세 번째를 희생하게 되고, 결국 가치가 거의 0에 가까워진 테스트의 예시들입니다.

## 4.4.2 극단적인 사례 #1: 엔드 투 엔드(E2E) 테스트
첫 번째 예시는 엔드 투 엔드(end-to-end, E2E) 테스트입니다. 앞서 2장에서 배운 것처럼, 엔드 투 엔드 테스트는 시스템을 최종 사용자 관점에서 바라보는 테스트입니다. 일반적으로 이 테스트는 사용자 인터페이스(UI), 데이터베이스, 외부 애플리케이션을 포함한 시스템의 모든 구성 요소를 통과합니다.

엔드 투 엔드 테스트는 많은 코드를 실행하기 때문에 회귀(regression)에 대한 최고의 보호 기능을 제공합니다. 사실, 모든 종류의 테스트 중에서 엔드 투 엔드 테스트가 가장 많은 코드를 실행합니다—자신이 작성한 코드뿐만 아니라 외부 라이브러리, 프레임워크, 서드파티 애플리케이션처럼 프로젝트에서 사용하는 외부 코드까지 포함해서요.

또한 엔드 투 엔드 테스트는 false positive(거짓 양성)에도 강하기 때문에 리팩터링에 대한 저항성도 뛰어납니다. 리팩터링이 올바르게 수행된다면 시스템의 외부 행동은 변하지 않으며, 따라서 엔드 투 엔드 테스트에도 영향을 미치지 않습니다. 이것은 엔드 투 엔드 테스트의 또 다른 장점인데요, 이러한 테스트는 특정한 구현 방식에 의존하지 않습니다. 엔드 투 엔드 테스트가 보는 유일한 것은 기능이 최종 사용자 관점에서 어떻게 동작하는가입니다. 이 테스트들은 구현 세부 사항에서 가능한 한 멀리 떨어져 있습니다.

하지만 이러한 장점에도 불구하고, 엔드 투 엔드 테스트에는 치명적인 단점이 있습니다. 그것은 바로 느리다는 것입니다. 이러한 테스트는 빠른 피드백을 얻기 어렵기 때문에, 오직 엔드 투 엔드 테스트에만 의존하는 시스템은 개발 속도가 현저히 느려질 수밖에 없습니다. 그렇기 때문에 코드베이스 전체를 오직 엔드 투 엔드 테스트로만 커버하는 것은 사실상 불가능합니다.

그림 4.6은 엔드 투 엔드 테스트가 단위 테스트의 세 가지 핵심 지표—회귀 방지, 리팩터링 저항성, 빠른 피드백—에서 어느 위치에 있는지를 보여줍니다. 이러한 테스트는 회귀 오류와 거짓 경고에 대해 훌륭한 보호 기능을 제공하지만, 속도 면에서는 부족합니다.

<img width="1080" alt="스크린샷 2025-06-04 오전 12 22 48" src="https://github.com/user-attachments/assets/11250b8e-82d9-4a33-8ef4-233a8da2bf59" />

> _**그림 4.6)**_ 엔드 투 엔드 테스트는 회귀 오류와 거짓 양성에 대해 훌륭한 보호 기능을 제공하지만, 빠른 피드백이라는 측면에서는 실패합니다.

## 4.4.3 극단적인 사례 #2: 사소한 테스트
또 다른 예는 사소한 테스트입니다. 이러한 테스트는 너무 단순해서 깨질 가능성이 거의 없는 간단한 코드 조각을 검사합니다. 다음 예시와 같이 말이죠.
<img width="1080" alt="스크린샷 2025-06-04 오전 12 23 59" src="https://github.com/user-attachments/assets/0a8cd05f-02cc-42b4-b385-d389a21ddd70" />

엔드 투 엔드 테스트와 달리, 사소한 테스트는 빠른 피드백을 제공합니다—실행 속도가 매우 빠르기 때문입니다. 또한, 거짓 양성(false positive)을 발생시킬 가능성도 낮기 때문에 리팩토링에 대한 저항력도 좋습니다.  
하지만 사소한 테스트는 회귀 오류를 발견할 가능성이 거의 없습니다. 이는 해당 코드 자체가 너무 단순하여 실수할 여지가 거의 없기 때문입니다.

사소한 테스트를 극단적으로 수행하면 동어 반복 테스트(tautology tests)가 됩니다. 이러한 테스트는 항상 통과하거나 의미 없는 단언(assertion)을 포함하고 있어서 실제로 아무 것도 테스트하지 않습니다.

<img width="1080" alt="스크린샷 2025-06-04 오전 12 24 27" src="https://github.com/user-attachments/assets/943fb4c7-05c1-4729-ba05-901c29d56628" />

> _**그림 4.7)**_ 사소한 테스트는 리팩토링에 대한 저항력이 좋고 빠른 피드백을 제공하지만, 회귀로부터 보호해 주지는 않습니다.

그림 4.7은 사소한 테스트의 위치를 보여줍니다. 이러한 테스트는 리팩토링에 대한 저항력이 뛰어나고 빠른 피드백을 제공하지만, 회귀로부터는 보호하지 못합니다.

## 4.4.4 극단적인 사례 #3: 취약한 테스트
마찬가지로, 빠르게 실행되며 회귀(regression)를 잡아낼 가능성도 높은 테스트를 작성하는 것은 꽤 쉽습니다. 하지만 이러한 테스트가 수많은 거짓 양성(false positive)을 발생시키는 경우가 있습니다. 이러한 테스트를 취약한 테스트(brittle test)라고 합니다. 이 테스트는 리팩토링을 견디지 못하고, 기본 기능이 제대로 작동하고 있는지 여부와 상관없이 실패하게 됩니다.

Listing 4.2에서 이미 취약한 테스트의 예시를 보셨습니다. 다음은 또 다른 예시입니다.
<img width="1080" alt="스크린샷 2025-06-04 오전 12 25 53" src="https://github.com/user-attachments/assets/d60fa84a-edc8-4eda-9de3-9a0e8ce65e7c" />

이 테스트는 `UserRepository` 클래스가 데이터베이스에서 사용자를 가져올 때 올바른 SQL 문을 생성하는지 확인합니다. 이 테스트가 버그를 잡아낼 수 있을까요? 가능합니다. 예를 들어, 개발자가 SQL 코드 생성 중 실수로 `UserID` 대신 `ID`를 사용하는 경우, 이 테스트는 실패를 발생시켜 해당 문제를 알려줄 수 있습니다. 하지만 이 테스트가 리팩토링에 대한 저항력이 뛰어난가요? 전혀 그렇지 않습니다. 동일한 결과를 도출하는 SQL 문에는 다음과 같은 다양한 변형이 있을 수 있습니다:

```mysql
SELECT * FROM dbo.[User] WHERE UserID = 5

SELECT * FROM dbo.User WHERE UserID = 5

SELECT UserID, Name, Email FROM dbo.[User] WHERE UserID = 5

SELECT * FROM dbo.[User] WHERE UserID = @UserID
```

Listing 4.6에 나온 테스트는 SQL 스크립트를 위에 언급된 어떤 변형으로 바꾸더라도 실패하게 됩니다. 이는 기능 자체는 그대로 작동하더라도 마찬가지입니다. 다시 말해, 이 테스트는 시스템의 내부 구현 세부 사항에 결합되어 있는 또 하나의 사례입니다. 테스트가 무엇을 하는지를 확인하기보다는 어떻게 하는지를 검사하고 있기 때문에, 시스템의 구현 방식에 고착되어 리팩토링을 방해하게 됩니다.

그림 4.8은 이러한 취약한 테스트가 세 번째 범주에 속함을 보여줍니다. 이런 테스트는 실행 속도가 빠르고 회귀 오류에 대한 보호는 잘해주지만, 리팩토링에 대한 저항력이 거의 없습니다.

<img width="1080" alt="스크린샷 2025-06-04 오전 12 27 24" src="https://github.com/user-attachments/assets/66bfe0e3-1e73-40dd-b2ed-b621fa304bb1" />

> _**그림 4.8)**_ 취약한 테스트는 실행 속도가 빠르고 회귀 오류에 대한 좋은 보호를 제공하지만, 리팩토링에 대한 저항력은 거의 없습니다.

## 4.4.5 이상적인 테스트를 찾아서: 그 결과
좋은 단위 테스트의 첫 세 가지 속성(회귀 방지, 리팩터링에 대한 저항성, 빠른 피드백)은 서로 양립할 수 없습니다. 이 중 세 가지 속성 중 두 가지를 극대화하는 테스트를 만드는 것은 비교적 쉽지만, 그렇게 하려면 나머지 한 가지 속성을 희생해야 합니다. 하지만 곱셈 규칙 때문에 그러한 테스트는 거의 0에 가까운 가치를 갖게 됩니다. 안타깝게도 이 세 가지 속성에서 모두 완벽한 점수를 받은 이상적인 테스트를 만드는 것은 불가능합니다(그림 4.9 참조).

<img width="1080" alt="스크린샷 2025-06-04 오전 12 28 37" src="https://github.com/user-attachments/assets/64509e7f-6b5b-4d45-b9a3-7ca8273fd8ec" />

> _**그림 4.9)**_ 세 가지 속성 모두에서 완벽한 점수를 갖는 이상적인 테스트를 만드는 것은 불가능합니다.

네 번째 속성인 유지보수성은 처음 세 가지 속성과는 상관관계가 없습니다. 단, 예외적으로 엔드 투 엔드 테스트(end-to-end tests)는 예외입니다. 엔드 투 엔드 테스트는 해당 테스트가 접근하는 모든 의존성을 설정해야 하기 때문에 일반적으로 크기가 더 큽니다. 또한 이러한 의존성들을 운영 가능한 상태로 유지하는 데 추가적인 노력이 필요합니다. 따라서 엔드 투 엔드 테스트는 유지보수 비용 측면에서 더 비싼 경향이 있습니다.

좋은 테스트의 속성 간 균형을 유지하는 것은 어렵습니다. 테스트가 처음 세 가지 범주 각각에서 최대 점수를 가질 수는 없고, 테스트가 적당히 짧고 단순하게 유지될 수 있도록 유지보수성 측면도 주의 깊게 살펴야 합니다. 따라서 트레이드오프가 필요합니다. 그리고 이러한 트레이드오프는 어떤 특정 속성도 0점이 되지 않도록 전략적이고 부분적으로 이뤄져야 합니다.

이러한 희생은 어떤 모습이어야 할까요? 리그레션 방지(protection against regressions), 리팩토링 저항성(resistance to refactoring), 빠른 피드백(fast feedback)이 상호 배타적이라는 점 때문에, 세 가지 속성 모두를 수용할 수 있도록 각 속성을 조금씩 희생하는 것이 가장 좋은 전략이라고 생각할 수도 있습니다.

하지만 실제로는 리팩토링에 대한 저항성은 양보할 수 없는 속성입니다. 테스트가 합리적인 속도로 실행되며, 엔드 투 엔드 테스트에만 의존하지 않는 한, 가능한 한 많은 리팩토링 저항성을 확보해야 합니다. 트레이드오프는 결국 테스트가 얼마나 잘 버그를 찾아내느냐와 얼마나 빠르게 그것을 수행하느냐 사이의 선택으로 귀결됩니다. 즉, 리그레션 방지와 빠른 피드백 사이의 선택입니다. 이 선택은 슬라이더처럼 생각할 수 있으며, 한 속성을 더 많이 얻으면 다른 속성을 더 잃게 됩니다(그림 4.10 참조).

<img width="1080" alt="스크린샷 2025-06-04 오전 12 29 58" src="https://github.com/user-attachments/assets/16dc84e6-8b85-4a5c-9ee3-ebcb008c6891" />

> **_그림 4.10)_** 최고의 테스트는 최대한의 유지 보수성과 리팩토링에 대한 저항성을 보여줍니다. 이 두 속성은 항상 최대화하려고 노력해야 합니다. 트레이드오프는 리그레션 방지와 빠른 피드백 중 어떤 것을 선택할지에 관한 문제입니다.

리팩토링에 대한 저항성이 양보할 수 없는 속성인 이유는, 이 속성을 테스트가 갖고 있는지의 여부가 대부분 이진적인 선택이기 때문입니다. 즉, 테스트는 리팩토링 저항성을 가지거나 가지지 않거나 둘 중 하나입니다. 그 사이에 중간 단계는 거의 존재하지 않습니다. 따라서 리팩토링 저항성을 조금만 양보하는 것은 불가능하며, 양보하는 순간 전부를 잃게 됩니다.

반면, 리그레션 방지와 빠른 피드백이라는 지표는 더 유연합니다. 다음 섹션에서는 이 두 속성 중 하나를 선택할 때 어떤 종류의 트레이드오프가 가능한지에 대해 살펴보겠습니다.

> **TIP)** 테스트의 견고한 테스트 스위트를 구축하기 위한 첫 번째 우선순위는 테스트의 취약성(거짓 양성)을 제거하는 것입니다.

> **CAP 이론**
> 좋은 단위 테스트의 첫 세 가지 속성 간의 트레이드오프는 CAP 이론과 유사합니다.  
> CAP 이론은 분산 데이터 저장소가 다음 세 가지 보장 중 두 가지만 동시에 제공할 수 있다고 말합니다:
> - **일관성(Consistency)**: 모든 읽기 작업은 가장 최근의 쓰기 작업을 받거나 오류를 반환합니다.
> - **가용성(Availability)**: 모든 요청은 응답을 받습니다(시스템의 모든 노드에 영향을 미치는 중단 상황은 제외).
> - **파티션 허용성(Partition tolerance)**: 네트워크 파티셔닝(네트워크 노드 간의 연결 끊김)에도 불구하고 시스템이 계속 작동합니다.

> 이 유사점은 두 가지입니다:
> - 첫째, '세 가지 중 두 가지'라는 트레이드오프가 존재합니다.
> - 둘째, 대규모 분산 시스템에서 파티션 허용성은 협상의 여지가 없습니다. 예를 들어, Amazon 웹사이트와 같은 대규모 애플리케이션은 단일 머신에서 운영될 수 없습니다. 일관성과 가용성을 확보하기 위해 파티션 허용성을 희생하는 선택지는 존재하지 않습니다. 아무리 큰 서버라도 Amazon이 저장해야 할 데이터를 모두 처리할 수는 없습니다.

> 결국 선택은 일관성과 가용성 사이의 트레이드오프로 귀결됩니다. 시스템의 일부에서는 일관성을 약간 희생하고 더 높은 가용성을 확보하는 것이 바람직합니다. 예를 들어, 제품 카탈로그를 표시할 때 일부 내용이 최신 정보가 아니더라도 일반적으로 괜찮습니다. 이 경우 가용성이 더 중요합니다. 반면, 제품 설명을 업데이트할 때는 일관성이 가용성보다 더 중요합니다. 네트워크 노드 간에 가장 최근 버전에 대해 합의가 있어야 병합 충돌을 피할 수 있기 때문입니다.

## 4.5 잘 알려진 테스트 자동화 개념 탐색하기
앞서 살펴본 좋은 단위 테스트의 네 가지 속성은 기본적인 토대입니다. 현재 존재하는 잘 알려진 테스트 자동화 개념들은 모두 이 네 가지 속성으로 거슬러 올라갈 수 있습니다. 이 절에서는 그러한 개념 중 두 가지, 즉 테스트 피라미드(Test Pyramid)와 화이트박스(White-box) 대 블랙박스(Black-box) 테스트에 대해 살펴보겠습니다.

## 4.5.1 테스트 피라미드 분석하기
테스트 피라미드는 테스트 스위트 내에서 서로 다른 유형의 테스트들 간의 특정 비율을 권장하는 개념입니다(그림 4.11 참조):

- 단위 테스트(Unit tests)
- 통합 테스트(Integration tests)
- 엔드 투 엔드 테스트(End-to-end tests)

<img width="1080" alt="스크린샷 2025-06-04 오전 12 33 07" src="https://github.com/user-attachments/assets/dd056945-d4f6-4384-bcff-73e0bc7db247" />

> **_그림 4.11)_** 테스트 피라미드는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트 간의 특정 비율을 권장합니다.

테스트 피라미드는 일반적으로 이 세 가지 유형의 테스트를 포함하는 피라미드 형태로 시각적으로 표현됩니다. 피라미드 층의 너비는 해당 유형의 테스트가 스위트 내에서 얼마나 많이 존재하는지를 나타냅니다. 층이 넓을수록 테스트의 개수가 많다는 뜻입니다. 층의 높이는 이러한 테스트가 최종 사용자의 행동을 얼마나 잘 모방하는지를 측정하는 기준입니다. 엔드 투 엔드 테스트는 피라미드의 가장 꼭대기에 위치하며, 사용자 경험을 가장 밀접하게 모방합니다.

피라미드 내의 서로 다른 테스트 유형들은 빠른 피드백과 회귀 방지 사이의 트레이드오프에서 서로 다른 선택을 합니다. 피라미드의 상단에 위치한 테스트일수록 회귀 방지에 중점을 두며, 하단에 위치한 테스트일수록 실행 속도(빠른 피드백)를 더 중시합니다(그림 4.12 참조).

<img width="1080" alt="스크린샷 2025-06-04 오전 12 33 47" src="https://github.com/user-attachments/assets/dbba5ce6-039e-4b26-894e-7275140acd7e" />

> **_그림 4.12)_** 피라미드에 있는 다양한 테스트 유형들은 빠른 피드백과 회귀 방지 사이에서 서로 다른 선택을 합니다. 엔드 투 엔드 테스트는 회귀 방지를 중시하고, 단위 테스트는 빠른 피드백을 강조하며, 통합 테스트는 그 중간에 위치합니다.

각 계층 중 어느 것도 리팩터링 저항성을 포기하지 않는다는 점에 주목하십시오. 물론 엔드 투 엔드 테스트와 통합 테스트가 단위 테스트보다 이 측면에서 더 높은 점수를 받기는 하지만, 이는 프로덕션 코드와 더 멀리 떨어져 있기 때문에 발생하는 부수적인 효과일 뿐입니다. 그럼에도 불구하고 단위 테스트조차도 리팩터링 저항성을 양보해서는 안 됩니다. 모든 테스트는 프로덕션 코드와 직접적으로 작동하더라도 가능한 한 적은 수의 false positive를 생성하는 것을 목표로 해야 합니다. (이를 어떻게 달성할지는 다음 장에서 다룹니다.)

각 팀과 프로젝트에 따라 테스트 유형의 정확한 구성은 달라질 수 있습니다. 그러나 일반적으로 피라미드 형태를 유지해야 합니다. 즉, 엔드 투 엔드 테스트는 소수여야 하고, 단위 테스트는 다수를 차지해야 하며, 통합 테스트는 그 중간 정도의 수를 가져야 합니다.

엔드 투 엔드 테스트가 소수여야 하는 이유는 4.4절에서 설명한 곱셈 규칙에 다시 기인합니다. 엔드 투 엔드 테스트는 빠른 피드백 속성에서 매우 낮은 점수를 받습니다. 또한 유지보수성도 낮습니다. 이 테스트들은 보통 크기가 크고, 관련된 외부 프로세스 종속성을 유지하기 위해 추가적인 노력이 필요하기 때문입니다. 따라서 엔드 투 엔드 테스트는 가장 중요한 기능—즉, 결코 버그가 발생해서는 안 되는 기능—에만 사용되어야 하며, 단위 테스트나 통합 테스트로는 동일한 수준의 보호를 제공할 수 없는 경우에만 사용되어야 합니다. 그 외의 용도로 사용하는 것은 최소 가치 기준을 통과하지 못해야 합니다. 단위 테스트는 일반적으로 더 균형 잡힌 속성들을 갖기 때문에 보통 더 많은 수로 작성됩니다.

테스트 피라미드에는 예외도 존재합니다. 예를 들어, 애플리케이션이 단순히 기본적인 생성(create), 조회(read), 수정(update), 삭제(delete) 작업(CRUD)만 수행하고, 비즈니스 규칙이나 기타 복잡성이 거의 없다면, 이 경우 테스트 "피라미드"는 대체로 유닛 테스트와 통합 테스트가 비슷한 수를 갖고 엔드 투 엔드 테스트는 없는 '직사각형' 형태일 가능성이 큽니다.

이러한 환경에서는 알고리즘적이거나 비즈니스적인 복잡성이 없기 때문에 단위 테스트는 그다지 유용하지 않으며, 금방 사소한(trivial) 테스트 수준으로 전락하게 됩니다. 반면에 통합 테스트는 여전히 가치를 유지합니다. 코드가 아무리 단순하더라도, 데이터베이스 같은 다른 하위 시스템과의 통합이 잘 작동하는지 검증하는 것은 여전히 중요하기 때문입니다. 그 결과, 단위 테스트보다 통합 테스트의 수가 더 많아질 수도 있습니다. 가장 단순한 예제에서는 통합 테스트의 수가 단위 테스트보다 많아지는 경우도 생깁니다.

테스트 피라미드의 또 다른 예외는 단 하나의 외부 프로세스 종속성—예를 들어 데이터베이스—에만 접근하는 API입니다. 이런 애플리케이션의 경우, 엔드 투 엔드 테스트의 수가 더 많은 것도 충분히 실행 가능한 선택이 될 수 있습니다. 사용자 인터페이스가 없기 때문에, 엔드 투 엔드 테스트도 비교적 빠르게 실행되며, 외부 종속성이 데이터베이스 하나뿐이므로 유지보수 비용도 그리 높지 않습니다. 이런 환경에서는 엔드 투 엔드 테스트와 통합 테스트의 구분이 사실상 사라지게 됩니다. 유일한 차이는 진입점(entry point)입니다. 엔드 투 엔드 테스트는 최종 사용자를 완전히 모방하기 위해 애플리케이션이 어딘가에 호스팅되어 있어야 하는 반면, 통합 테스트는 일반적으로 애플리케이션을 동일한 프로세스 내에서 호스팅합니다. 통합 테스트에 대해 다룰 8장에서 다시 테스트 피라미드로 돌아올 것입니다.

## 4.5.2 블랙박스 테스트와 화이트박스 테스트 중 선택하기
다른 잘 알려진 테스트 자동화 개념은 블랙박스 테스트와 화이트박스 테스트입니다. 이 섹션에서는 두 가지 접근 방식을 언제 사용해야 하는지 설명합니다:

- 블랙박스 테스트는 시스템의 내부 구조를 알지 못한 채 시스템의 기능을 검사하는 소프트웨어 테스트 방법입니다.  
    이러한 테스트는 일반적으로 명세서와 요구사항을 기반으로 하여, 애플리케이션이 "어떻게 작동하는지"가 아니라 "무엇을 해야 하는지"를 확인합니다.
- 화이트박스 테스트는 그 반대입니다. 애플리케이션의 내부 동작을 검증하는 테스트 방법이며,  
    테스트는 요구사항이나 명세서가 아닌 소스 코드로부터 도출됩니다.

이 두 가지 방식에는 각각 장단점이 있습니다. 화이트박스 테스트는 일반적으로 더 철저합니다. 소스 코드를 분석함으로써 외부 명세서에만 의존할 경우 놓칠 수 있는 많은 오류를 발견할 수 있습니다. 하지만 화이트박스 테스트로부터 나온 테스트는 코드의 특정 구현에 밀접하게 결합되는 경향이 있어 테스트가 쉽게 깨지며 많은 수의 false positive(거짓 경고)를 발생시킵니다. 이로 인해 리팩터링에 대한 저항성이 부족한 경우가 많습니다. 또한 이러한 테스트는 비즈니스 담당자에게 의미 있는 동작으로 추적되지 않는 경우가 많아, 이러한 테스트는 깨지기 쉬우며 큰 가치를 제공하지 못한다는 강력한 신호가 됩니다.

블랙박스 테스트는 이와 반대되는 장단점을 가지고 있습니다 (표 4.1 참조).

<img width="1080" alt="스크린샷 2025-06-04 오전 12 37 08" src="https://github.com/user-attachments/assets/20828b09-394d-484c-914c-848785f1c6b4" />

4.4.5절에서 기억하시겠지만, 리팩터링에 대한 저항성은 타협할 수 있는 항목이 아닙니다. 테스트는 리팩터링에 대한 저항성을 갖고 있거나, 아예 갖고 있지 않거나 둘 중 하나입니다. 따라서 기본적으로는 화이트박스 테스트보다 블랙박스 테스트를 선택하셔야 합니다. 단위 테스트이든, 통합 테스트이든, 또는 엔드 투 엔드 테스트이든 관계없이, 모든 테스트는 시스템을 블랙박스로 간주하고 문제 도메인에 의미 있는 동작을 검증하도록 작성해야 합니다. 테스트가 어떤 비즈니스 요구사항으로부터 유래되었는지를 추적할 수 없다면, 그 테스트는 깨지기 쉬운 테스트라는 신호입니다. 그런 테스트는 구조를 바꾸거나 삭제해야 하며, 현재 상태 그대로 테스트 스위트에 포함시키면 안 됩니다. 단 하나의 예외는 높은 알고리즘 복잡도를 가진 유틸리티 코드에 대한 테스트입니다.(이에 대해서는 7장에서 더 자세히 다룹니다).

참고로, 테스트를 작성할 때는 블랙박스 방식이 더 낫지만, 테스트를 분석할 때는 화이트박스 방식을 사용할 수 있습니다. 코드 커버리지 도구를 사용해 어떤 코드 분기가 테스트되지 않았는지 확인한 다음, 그 코드의 내부 구조를 모른다고 가정하고 블랙박스 방식으로 테스트를 작성하면 됩니다. 이처럼 화이트박스 방식과 블랙박스 방식을 결합해서 사용하는 것이 가장 효과적입니다.

## Summary
- 좋은 단위 테스트는 네 가지 핵심 속성을 갖고 있으며, 이는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트를 포함한 모든 자동화 테스트를 분석하는 데 사용할 수 있습니다:  
	- 회귀에 대한 보호  
	- 리팩터링에 대한 저항성  
	- 빠른 피드백  
	- 유지보수성
- 회귀에 대한 보호는 테스트가 버그(회귀)를 얼마나 잘 감지하는지를 측정하는 지표입니다. 해당 테스트가 실행하는 코드가 많을수록(자신이 작성한 코드뿐 아니라 프로젝트에서 사용하는 라이브러리 및 프레임워크의 코드까지 포함), 해당 테스트가 버그를 찾아낼 가능성은 더 높아집니다.
- 리팩터링에 대한 저항성은 테스트가 애플리케이션 코드의 리팩터링 이후에도 거짓 실패 없이 얼마나 잘 견디는지를 의미합니다.
- 거짓 실패(False Positive)는 잘못된 경고입니다. 즉, 테스트는 실패했지만 실제 기능은 의도대로 작동하는 경우를 말합니다. 거짓 실패는 테스트 스위트에 치명적인 영향을 줄 수 있습니다:  
	- 이러한 경고에 익숙해지면 실제 코드의 문제에 대해 반응할 수 있는 능력과 의지가 약화됩니다.  
	- 테스트를 신뢰할 수 있는 안전망으로 인식하지 못하게 되어 테스트 스위트에 대한 신뢰를 잃게 됩니다.
- 거짓 실패는 테스트와 테스트 대상 시스템(SUT)의 내부 구현 세부사항 간의 강한 결합에서 비롯됩니다. 이러한 결합을 피하려면, 테스트는 SUT가 수행한 과정이 아니라 SUT가 생성한 최종 결과를 검증해야 합니다.  
- 회귀에 대한 보호와 리팩터링에 대한 저항성은 테스트의 정확도에 기여합니다.  
- 테스트는 강력한 신호(버그를 찾을 수 있는 능력, 회귀에 대한 보호의 영역)를 생성하면서, 잡음(거짓 실패, 리팩터링 저항성의 영역)을 최소화할수록 더 정확합니다.  
- 거짓 실패는 프로젝트 초기에 그다지 큰 부정적 영향을 주지 않지만, 프로젝트가 성장함에 따라 점점 더 중요해지며, 나중에는 놓친 버그(거짓 부정)만큼이나 중요해집니다.  
- 빠른 피드백은 테스트가 얼마나 빨리 실행되는지를 측정하는 지표입니다.  
- 유지보수성은 두 가지 요소로 구성됩니다:  
	- 테스트를 이해하기 얼마나 어려운가: 테스트가 작을수록 가독성이 높습니다.  
	- 테스트를 실행하기 얼마나 어려운가: 외부 프로세스 의존성이 적을수록 해당 의존성을 운영 상태로 유지하기 쉽습니다.
- 테스트의 가치 평가는 테스트가 네 가지 속성 각각에서 얻는 점수의 곱입니다. 테스트가 어느 하나의 속성에서 0점을 받으면, 전체 가치도 0이 됩니다.  
- 네 가지 속성 모두에서 최고 점수를 받는 테스트를 만드는 것은 불가능합니다. 그 이유는 첫 세 가지 속성—회귀에 대한 보호, 리팩터링에 대한 저항성, 빠른 피드백—이 상호 배타적이기 때문입니다. 테스트는 이 중 두 가지만 최대화할 수 있습니다.  
- 리팩터링에 대한 저항성은 협상의 대상이 될 수 없습니다. 이 속성은 대부분 이진적인 특성으로, 테스트가 저항성을 가지거나 가지지 않거나 둘 중 하나이기 때문입니다. 속성 간의 균형은 회귀에 대한 보호와 빠른 피드백 중 어느 것을 선택하느냐의 문제입니다.  
- 테스트 피라미드는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트 간의 특정 비율을 권장합니다: 엔드 투 엔드 테스트는 가장 적게, 단위 테스트는 가장 많게, 통합 테스트는 그 중간 정도로 유지해야 합니다.  
- 피라미드 내의 테스트 유형마다 빠른 피드백과 회귀에 대한 보호 사이에서 다른 선택을 합니다. 엔드 투 엔드 테스트는 회귀에 대한 보호를, 단위 테스트는 빠른 피드백을 중시합니다.  
- 테스트를 작성할 때는 블랙박스 테스트 방식을 사용하십시오. 테스트를 분석할 때는 화이트박스 방식을 활용하십시오.
