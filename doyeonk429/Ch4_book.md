# Part 2. 당신의 테스트가 당신을 위해 일하게 만들기
이제 단위 테스트의 목적에 대한 지식을 갖추었으니, 좋은 테스트를 만드는 핵심에 본격적으로 뛰어들고, 테스트를 더 가치 있게 리팩터링하는 방법을 배울 준비가 되었습니다. 4장에서는 좋은 단위 테스트를 구성하는 네 가지 핵심 기둥에 대해 배웁니다. 이 네 가지 기둥은 앞으로 단위 테스트와 테스트 접근 방식을 분석할 때 사용할 기초이자 공통된 기준점을 제공합니다.

5장에서는 4장에서 확립한 기준점을 바탕으로 목(mock)의 필요성과 테스트의 취약성과의 관계에 대해 설명합니다.

6장에서는 동일한 기준점을 사용하여 단위 테스트의 세 가지 스타일을 살펴봅니다. 그리고 이 중 어떤 스타일이 가장 높은 품질의 테스트를 만들어내는 경향이 있는지, 그리고 그 이유는 무엇인지 보여줍니다.

7장에서는 4장부터 6장까지의 지식을 실제로 적용하여 복잡하고 비대한 테스트에서 벗어나, 최소의 유지보수 비용으로 최대의 가치를 제공하는 테스트로 리팩터링하는 방법을 가르쳐줍니다.

# Ch 4. 좋은 단위 테스트의 네 가지 핵심 기둥
이번 장에서는 다음 내용을 다룹니다
- 좋은 단위 테스트의 여러 측면 간의 이분법 탐구
- 이상적인 테스트 정의
- 테스트 피라미드 이해하기
- 블랙박스 테스트와 화이트박스 테스트 사용하기

이제 본격적인 핵심 주제로 들어갑니다. 1장에서 여러분은 좋은 단위 테스트 슈트의 특성을 살펴보았습니다:
- 그것은 개발 주기에 통합되어 있습니다. 테스트는 적극적으로 사용할 때에만 가치가 있습니다. 그렇지 않으면 작성할 이유가 없습니다.
- 그것은 코드베이스에서 가장 중요한 부분만을 대상으로 합니다. 모든 프로덕션 코드가 동일한 주의를 받을 필요는 없습니다. 애플리케이션의 핵심(도메인 모델)과 그 외의 부분을 구분하는 것이 중요합니다. 이 주제는 7장에서 다룹니다.
- 그것은 최소한의 유지보수 비용으로 최대의 가치를 제공합니다. 이 마지막 속성을 달성하려면 다음을 할 수 있어야 합니다:
	- 가치 있는 테스트(그리고 확장하여 가치가 낮은 테스트)를 인식할 수 있어야 합니다
	- 가치 있는 테스트를 작성할 수 있어야 합니다

1장에서 논의했듯이, 가치 있는 테스트를 인식하는 것과 가치 있는 테스트를 작성하는 것은 서로 다른 두 가지 기술입니다. 그러나 후자는 전자를 필요로 합니다. 따라서 이 장에서는 가치 있는 테스트를 인식하는 방법을 보여드리겠습니다. 여러분은 테스트 스위트(suite)의 어떤 테스트든 분석할 수 있는 보편적인 참조 프레임을 보게 될 것입니다. 그 후, 이 참조 프레임을 사용하여 테스트 피라미드(Test Pyramid)와 블랙박스 테스트(black-box testing) 대 화이트박스 테스트(white-box testing) 같은 인기 있는 단위 테스트 개념들을 살펴보겠습니다.

자, 이제 시작합니다.

## 4.1 좋은 단위 테스트의 네 가지 핵심 기둥 깊이 파고들기
좋은 단위 테스트는 다음의 네 가지 속성을 갖습니다:
- 회귀로부터의 보호
- 리팩토링에 대한 저항성
- 빠른 피드백
- 유지보수성

이 네 가지 속성은 기초적입니다. 단위 테스트든, 통합 테스트든, 엔드 투 엔드 테스트든 모든 자동화 테스트는 이 네 가지 속성을 어느 정도씩 가지고 있습니다. 이 절에서는 처음 두 가지 속성을 정의하고, 4.2절에서는 그들 사이의 본질적인 연관성에 대해 설명합니다.

## 4.1.1 첫 번째 기둥: 회귀로부터의 보호
좋은 단위 테스트의 첫 번째 속성인 회귀로부터의 보호부터 살펴보겠습니다. 1장에서 다룬 바와 같이, 회귀(regression)란 소프트웨어 버그를 의미하며, 일반적으로 새로운 기능을 추가한 뒤 코드가 수정되면서 기존 기능이 의도대로 작동하지 않게 되는 현상을 말합니다.

이러한 회귀는 매우 성가시지만, 더 큰 문제는 따로 있습니다. 기능이 많아질수록 새 릴리스를 통해 기존 기능이 깨질 가능성도 함께 높아진다는 점입니다. 프로그래밍에서 불편한 진실은 코드가 자산이 아니라 부채라는 것입니다. 코드베이스가 커질수록 버그가 발생할 수 있는 위험도 그만큼 커지게 됩니다. 그렇기 때문에 회귀로부터의 확실한 보호 수단을 마련하는 것이 매우 중요합니다. 이러한 보호 없이는 프로젝트의 지속적인 성장을 기대할 수 없으며, 시간이 지날수록 점점 더 많은 버그로 인해 프로젝트가 무너질 수 있습니다.

회귀로부터의 보호라는 기준에서 테스트가 얼마나 잘 작동하는지를 평가하기 위해서는 다음과 같은 요소들을 고려해야 합니다:
- 테스트 중에 실행되는 코드의 양
- 해당 코드의 복잡도
- 해당 코드의 도메인 중요도

일반적으로 실행되는 코드의 양이 많을수록, 해당 테스트가 회귀를 발견할 가능성도 높아집니다. 물론 이는 테스트에 적절한 표명(assertion)이 포함되어 있다는 전제하에 해당하는 이야기입니다. 단순히 코드를 실행하는 것만으로는 충분하지 않습니다. 예외가 발생하지 않고 코드가 실행되는 것도 도움이 되지만, 그 코드가 실제로 어떤 결과를 만들어내는지를 검증하는 것도 중요합니다.

중요한 것은 코드의 양뿐만 아니라, 그 복잡성과 도메인 상의 중요성도 함께 고려해야 한다는 점입니다. 복잡한 비즈니스 로직을 포함한 코드는 단순 반복적인 보일러 플레이트 코드보다 훨씬 중요합니다. 비즈니스에 중요한 기능에서 발생하는 버그는 가장 큰 피해를 유발하기 때문입니다.

반면, 사소한 코드를 테스트하는 것은 거의 가치가 없습니다. 이런 코드는 짧고, 실질적인 비즈니스 로직을 거의 포함하지 않기 때문입니다. 사소한 코드를 다루는 테스트는 회귀 오류를 찾아낼 가능성이 낮습니다. 왜냐하면 실수할 수 있는 여지가 거의 없기 때문입니다. 다음은 그런 사소한 코드의 예시입니다:

```c#
public class User
{
	public string Name { get; set; }
}
```

게다가 여러분이 작성한 코드뿐만 아니라, 직접 작성하지 않은 코드도 중요합니다. 예를 들어, 라이브러리, 프레임워크, 그리고 프로젝트에서 사용하는 외부 시스템들이 여기에 해당합니다. 이러한 코드들은 여러분의 소프트웨어 동작에 거의 동일한 수준으로 영향을 미칩니다. 최상의 회귀 방지를 위해서는 테스트 범위에 이러한 라이브러리, 프레임워크, 외부 시스템까지 포함되어야 합니다. 그래야만 여러분의 소프트웨어가 이러한 의존성들에 대해 갖고 있는 가정들이 올바른지 확인할 수 있습니다.

> **TIP)** 회귀로부터의 보호 지표를 극대화하려면, 테스트는 가능한 한 많은 코드를 실행하는 것을 목표로 해야 합니다.

## 4.1.2 두 번째 기둥: 리팩터링에 대한 저항력
좋은 단위 테스트의 두 번째 속성은 리팩터링에 대한 저항력입니다. 이는 테스트가 기반이 되는 애플리케이션 코드를 리팩터링하더라도 실패하지 않고(빨갛게 변하지 않고) 견딜 수 있는 정도를 말합니다.

> **DEFINITION)** 리팩터링이란 기존 코드를 외부에서 보이는 동작을 변경하지 않고 수정하는 것을 의미합니다. 일반적으로 리팩터링의 목적은 코드의 비기능적 특성을 개선하는 데 있으며, 가독성을 높이고 복잡성을 줄이는 것이 그 예입니다. 메서드 이름을 바꾸거나 코드 일부를 새로운 클래스로 추출하는 것 등이 리팩터링의 예입니다.

이런 상황을 상상해 보세요. 새로운 기능을 개발했고, 모든 것이 잘 작동합니다. 기능 자체는 제 역할을 하고 있고, 모든 테스트도 통과했습니다. 이제 코드를 정리하고 싶어졌습니다. 여기저기 리팩터링을 조금씩 하고 나니, 모든 것이 전보다 훨씬 좋아 보입니다. 단 한 가지를 제외하고는 말이죠—테스트가 실패합니다. 무엇을 망가뜨렸는지 확인하려고 자세히 들여다보지만, 실제로는 아무 것도 망가뜨리지 않았다는 것을 알게 됩니다. 기능은 여전히 완벽하게 작동합니다. 문제는 테스트가 기저 코드를 조금만 수정해도 실패하도록 작성되어 있다는 점입니다. 그리고 이는 실제 기능이 망가졌는지 여부와 상관없이 발생합니다.

이런 상황을 가리켜 거짓 양성(false positive)이라고 합니다. 거짓 양성이란 잘못된 경고, 즉 테스트가 실패했다고 표시하지만, 실제로는 해당 기능이 의도한 대로 잘 작동하고 있는 경우를 말합니다. 이러한 거짓 양성은 보통 코드를 리팩터링할 때 발생합니다—즉, 구현을 수정하지만 눈에 보이는 동작은 그대로 유지하는 경우입니다. 그래서 좋은 단위 테스트의 속성 중 하나가 리팩터링에 대한 저항력(resistance to refactoring)인 것입니다.

테스트가 리팩터링에 대한 저항력이라는 지표에서 얼마나 좋은 점수를 받을 수 있는지를 평가하려면, 그 테스트가 얼마나 자주 거짓 양성을 발생시키는지를 살펴봐야 합니다. 거짓 양성이 적을수록 더 좋은 테스트입니다.

왜 거짓 양성(false positive)에 그렇게 많은 주의를 기울여야 할까요? 그 이유는 거짓 양성이 전체 테스트 스위트에 심각한 영향을 줄 수 있기 때문입니다. 1장에서 언급했듯이, 단위 테스트의 목표는 프로젝트의 지속 가능한 성장을 가능하게 하는 것입니다. 테스트가 이러한 성장을 가능하게 하는 메커니즘은, 새로운 기능을 추가하거나 정기적인 리팩터링을 수행해도 회귀가 발생하지 않도록 해주는 것입니다. 여기에는 두 가지 구체적인 이점이 있습니다:
- 테스트는 기존 기능이 깨졌을 때 조기에 경고를 제공합니다. 이러한 조기 경고 덕분에 문제가 있는 코드를 실제 운영 환경에 배포하기 훨씬 전에 수정할 수 있습니다. 운영 환경에서 문제를 처리하는 것보다 훨씬 적은 노력으로 해결할 수 있습니다.
- 코드 변경이 회귀로 이어지지 않을 것이라는 확신을 얻게 됩니다. 이런 확신이 없다면 리팩터링을 주저하게 되고, 결국 코드베이스가 점점 더 악화될 가능성이 높아집니다.

거짓 양성(false positive)은 이러한 두 가지 이점을 모두 방해합니다:

- 테스트가 특별한 이유 없이 실패한다면, 코드상의 문제에 반응하려는 능력과 의지를 약화시킵니다. 시간이 지나면 이러한 실패에 익숙해지고, 점차 주의를 기울이지 않게 됩니다. 결국에는 실제로 문제가 있는 실패조차도 무시하게 되어, 그 문제가 운영 환경까지 넘어가게 됩니다.
- 반대로, 거짓 양성이 자주 발생하면 테스트 스위트에 대한 신뢰를 잃게 됩니다. 테스트 스위트를 더 이상 신뢰할 수 있는 안전망으로 인식하지 않게 되며, 반복되는 허위 경고 때문에 그 신뢰가 약화됩니다. 이러한 신뢰 부족은 리팩터링의 감소로 이어지며, 회귀를 피하기 위해 코드 변경을 가능한 한 최소화하려는 경향이 생깁니다.


> **현장에서 있었던 이야기**

> 제가 한 프로젝트에서 일한 적이 있었습니다. 그 프로젝트는 그렇게 오래되지는 않았지만, 약 2~3년 정도의 이력이 있었습니다. 그 사이에 경영진은 프로젝트의 방향을 크게 바꾸었고, 개발 역시 그에 따라 방향을 전환하게 되었습니다. 이 변화 과정에서 하나의 문제가 발생했습니다. 코드베이스에 더 이상 사용되지 않는 많은 양의 코드가 남게 되었고, 아무도 그 코드를 삭제하거나 리팩터링하려 하지 않았습니다. 회사는 더 이상 해당 코드가 제공하는 기능을 필요로 하지 않았지만, 그 코드의 일부는 새로운 기능에서도 사용되고 있었기 때문에 완전히 제거하는 것이 불가능했습니다.

> 그 프로젝트는 테스트 커버리지가 잘 되어 있는 편이었습니다. 그러나 누군가가 오래된 기능을 리팩터링하려 하거나, 여전히 사용 중인 부분을 나머지 코드와 분리하려고 시도할 때마다 테스트가 실패하곤 했습니다. 그것도 단지 오래된 테스트만이 아니라, 최근에 작성된 테스트들조차 실패했습니다. 일부 실패는 정당했지만, 대부분은 그렇지 않았습니다. 거짓 양성이었습니다.

> 처음에는 개발자들이 이러한 테스트 실패에 대응하려고 노력했습니다. 하지만 대부분이 허위 경고였기 때문에, 결국에는 테스트 실패를 무시하게 되었고, 실패한 테스트를 비활성화시키는 상황에 이르렀습니다. 개발자들 사이에서는 “그 오래된 코드 때문이면 그냥 테스트 꺼버려요. 나중에 확인하죠.”라는 태도가 일반적이었습니다.

> 모든 것이 한동안은 잘 작동하는 듯했습니다. 그러다 결국 심각한 버그가 운영 환경에 반영되고 말았습니다. 사실 그 버그는 테스트 중 하나가 정확히 찾아낸 것이었지만, 그 테스트는 다른 테스트들과 함께 이미 비활성화된 상태였기 때문에 아무도 신경 쓰지 않았습니다. 그 사고 이후로 개발자들은 아예 그 오래된 코드에 손을 대지 않게 되었습니다.

이 이야기는 취약한 테스트를 가진 대부분의 프로젝트에서 흔히 볼 수 있는 유형입니다. 처음에는 개발자들이 테스트 실패를 그대로 받아들이고 적절히 대응합니다. 하지만 시간이 지나면서 테스트가 계속해서 “늑대가 나타났다”고 외치자, 사람들은 점점 이를 무시하게 됩니다. 결국 어느 순간, 실제 버그들이 무더기로 운영 환경에 배포되는 일이 발생합니다. 왜냐하면 개발자들이 거짓 양성과 함께 진짜 실패까지 모두 무시하게 되었기 때문입니다.

이런 상황에 대한 반응으로 모든 리팩터링을 중단하는 것은 올바른 방법이 아닙니다. 올바른 대응은 테스트 스위트(suite)를 재평가하고, 그 취약성을 줄이기 시작하는 것입니다. 이 주제는 7장에서 다루겠습니다.

## 4.1.3 거짓 양성(False Positive)은 무엇 때문에 발생할까요?
그렇다면 거짓 양성(false positive)은 무엇 때문에 발생할까요? 그리고 이를 어떻게 피할 수 있을까요?

테스트가 만들어내는 거짓 양성의 수는 테스트가 시스템의 구현 세부사항(시스템 언더 테스트, SUT)에 얼마나 밀접하게 결합되어 있는지와 직접적인 관련이 있습니다. 테스트가 SUT의 구현 방식에 더 많이 의존할수록, 거짓 경고를 더 많이 만들어냅니다. 거짓 양성의 가능성을 줄이는 유일한 방법은 테스트를 이러한 구현 세부사항으로부터 분리하는 것입니다. 테스트는 SUT가 제공하는 최종 결과, 즉 외부에서 관찰 가능한 동작만을 검증해야 합니다. 그 과정에서 어떤 단계를 거치는지는 중요하지 않습니다. 테스트는 SUT의 동작을 최종 사용자 관점에서 바라보고, 사용자에게 의미 있는 결과만을 검증해야 합니다. 그 외의 모든 것은 무시해야 합니다 (이 주제는 5장에서 더 자세히 다룹니다).

테스트를 구성하는 가장 좋은 방법은 문제 도메인에 관한 이야기를 들려주는 방식으로 만드는 것입니다. 이런 테스트가 실패할 경우, 그 실패는 이야기와 실제 애플리케이션 동작 사이에 불일치가 있음을 의미합니다. 이러한 종류의 실패는 항상 본질적인 문제를 지적해 주며, 무엇이 잘못되었는지를 빠르게 이해하는 데 도움을 줍니다. 그 외의 실패들은 단지 잡음(noise)에 불과하며, 중요한 것에서 주의를 빼앗는 원인이 됩니다.

다음은 예시입니다. 이 예시에서 `MessageRenderer` 클래스는 메시지의 HTML 표현을 생성합니다. 메시지는 헤더, 본문, 그리고 푸터로 구성됩니다.

---
### Listing 4.1 Generating an HTML representation of a message
```c#
public class Message
{
	public string Header { get; set; }
	public string Body { get; set; }
	public string Footer { get; set; }
}

public interface IRenderer
{
	string Render(Message message);
}

public class MessageRenderer : IRenderer
{
	public IReadOnlyList<IRenderer> SubRenderers { get; }

	public MessageRenderer()
	{
		SubRenderers = new List<IRenderer>
		{
			new HeaderRenderer(),
			new BodyRenderer(),
			new FooterRenderer()
		};
	}

	public string Render(Message message)
	{
		return SubRenderers
			.Select(x => x.Render(message))
			.Aggregate("", (str1, str2) => str1 + str2);
	}
}
```

`MessageRenderer` 클래스는 여러 하위 렌더러(sub-renderer)를 포함하고 있으며, 메시지의 각 부분에 대한 실제 작업을 이 하위 렌더러들에게 위임합니다. 그런 다음 `MessageRenderer`는 이 결과들을 하나로 결합하여 HTML 문서를 만듭니다. 하위 렌더러들은 원시 텍스트(raw text)를 HTML 태그와 함께 구성합니다. 예를 들어 다음과 같습니다:

```c#
public class BodyRenderer : IRenderer
{
	public string Render(Message message)
	{
		return $"<b>{message.Body}</b>";
	}
}
```

`MessageRenderer`는 어떻게 테스트할 수 있을까요? 하나의 가능한 접근 방식은 이 클래스가 따르는 알고리즘을 분석하는 것입니다.

---
### Listing 4.2 Verifying that `MessageRenderer` has the correct structure
```c#
public void MessageRenderer_uses_correct_sub_renderers()
{

	var sut = new MessageRenderer();

	IReadOnlyList<IRenderer> renderers = sut.SubRenderers;

	Assert.Equal(3, renderers.Count);

	Assert.IsAssignableFrom<HeaderRenderer>(renderers[0]);
	Assert.IsAssignableFrom<BodyRenderer>(renderers[1]);
  Assert.IsAssignableFrom<FooterRenderer>(renderers[2]);
}
```

이 테스트는 하위 렌더러들이 모두 예상된 타입인지, 그리고 올바른 순서로 나타나는지를 확인합니다. 이는 `MessageRenderer`가 메시지를 처리하는 방식 또한 올바르다는 전제를 가집니다. 이 테스트는 처음에는 좋아 보일 수 있지만, 실제로 `MessageRenderer`의 관찰 가능한 동작을 검증하고 있을까요? 하위 렌더러의 순서를 바꾸거나, 그 중 하나를 새로운 것으로 대체하면 어떻게 될까요? 과연 그런 변화가 버그로 이어질까요?

꼭 그렇지는 않습니다. 하위 렌더러 구성을 바꾸더라도, 생성되는 HTML 문서가 동일하게 유지될 수 있습니다. 예를 들어, `BodyRenderer`를 `BoldRenderer`로 교체할 수 있으며, 이 두 렌더러가 같은 역할을 수행할 수도 있습니다. 또는 모든 하위 렌더러를 제거하고, 렌더링 작업을 `MessageRenderer` 내부에서 직접 구현할 수도 있습니다.

그러나 이러한 변경을 하면 테스트는 실패하게 됩니다. 비록 최종 결과는 바뀌지 않았더라도 말입니다. 그 이유는 이 테스트가 SUT의 구현 세부사항에 결합되어 있고, SUT가 생성하는 결과 자체에는 관심이 없기 때문입니다. 이 테스트는 알고리즘을 들여다보며, 특정한 구현 방식만을 기대합니다. 동등하게 적용 가능한 다른 구현 방식은 고려하지 않습니다 (그림 4.1 참고).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 02 32" src="https://github.com/user-attachments/assets/a42e6681-f3b0-4d2d-a0d3-3111b3b68aff" />

_**그림 4.1)**_ SUT의 알고리즘에 결합된 테스트. 이러한 테스트는 특정한 구현 방식(SUT가 결과를 생성하기 위해 반드시 따라야 하는 구체적인 단계들)을 기대하기 때문에 취약합니다. SUT의 구현을 리팩터링하면 테스트는 실패하게 됩니다.

`MessageRenderer` 클래스의 주요 리팩터링이 이루어지면, 해당 테스트는 실패하게 됩니다. 리팩터링이란 애플리케이션의 관찰 가능한 동작에는 영향을 주지 않으면서 구현을 변경하는 과정입니다. 그리고 바로 그 구현 세부사항에 대해 테스트가 신경을 쓰기 때문에, 그 세부사항을 변경할 때마다 테스트가 실패하게 됩니다.

따라서, 시스템의 구현 세부사항에 결합된 테스트는 리팩터링에 강하지 않습니다. 이러한 테스트는 앞서 설명한 모든 단점을 그대로 드러냅니다:
- 회귀가 발생했을 때 조기 경고를 제공하지 못합니다. 왜냐하면 해당 경고들이 실제와 거의 관련이 없기 때문에 무시되기 때문입니다.
- 리팩터링에 대한 개발자의 능력과 의지를 방해합니다. 테스트가 버그를 제대로 감지하지 못하는데, 누가 리팩터링을 하고 싶어 하겠습니까?

다음 목록은 제가 본 테스트 중 가장 심각한 수준의 취약성을 가진 예시로, `MessageRenderer` 클래스의 소스 코드를 읽고 이를 "올바른" 구현과 비교합니다.

---
### Listing 4.3 Verifying the source code of the `MessageRenderer` class
```c#
public void MessageRenderer_is_implemented_correctly()
{
    string sourceCode = File.ReadAllText(@"[path]\MessageRenderer.cs");
    Assert.Equal(@"
public class MessageRenderer : IRenderer
{
    public IReadOnlyList<IRenderer> SubRenderers { get; }

    public MessageRenderer()
    {
        SubRenderers = new List<IRenderer>
        {
            new HeaderRenderer(),
            new BodyRenderer(),
            new FooterRenderer()
        };
    }

    public string Render(Message message) { /* ... */ }
}", sourceCode);
}
```

물론 이 테스트는 말도 안 되게 터무니없습니다. `MessageRenderer` 클래스를 아주 조금만 수정해도 실패하게 됩니다. 동시에, 앞서 언급한 테스트와 그리 다르지도 않습니다. 두 테스트 모두 SUT의 관찰 가능한 동작은 고려하지 않고 특정 구현 방식만을 고집합니다. 그리고 구현을 변경할 때마다 두 테스트 모두 실패하게 됩니다. 물론 인정하자면, 리스트 4.3의 테스트가 리스트 4.2의 테스트보다 더 자주 깨질 것입니다.

## 4.1.4 구현 세부사항 대신 최종 결과를 목표로 하라
앞서 언급했듯이, 테스트의 취약성을 피하고 리팩터링에 대한 저항력을 높이는 유일한 방법은 테스트를 시스템의 구현 세부사항에서 분리하는 것입니다. 테스트와 코드 내부 동작 사이에 가능한 한 많은 거리를 두고, 대신 최종 결과를 검증하는 데 집중해야 합니다. 그럼 그렇게 해봅시다. listing 4.2에 있는 테스트를 훨씬 덜 취약하게 리팩터링해 보겠습니다.

먼저, 다음과 같은 질문을 스스로에게 던져야 합니다. `MessageRenderer`로부터 얻는 최종 결과는 무엇인가요? 그것은 메시지의 HTML 표현입니다. 그리고 그 HTML 표현만이 확인할 가치가 있는 유일한 것이며, 클래스에서 얻을 수 있는 유일한 관찰 가능한 결과입니다. 이 HTML 표현이 동일하게 유지되는 한, 그것이 어떻게 생성되는지는 걱정할 필요가 없습니다. 그런 구현 세부사항은 무관한 것입니다. 다음 코드는 새롭게 작성된 테스트 버전입니다.

---
### Listing 4.4 Verifying the outcome that `MessageRenderer` produces
```c#
public void Rendering_a_message()
{
	var sut = new MessageRenderer();
	var message = new Message
	{
	Header = "h",
	Body = "b",
	Footer = "f"
	};

	string html = sut.Render(message);

	Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);

}
```
이 테스트는 `MessageRenderer`를 블랙박스로 다루며, 오직 그 관찰 가능한 동작에만 관심을 둡니다. 그 결과, 이 테스트는 리팩터링에 훨씬 더 강한 저항력을 가지게 됩니다. HTML 출력이 동일하게 유지되는 한, 시스템 내부 코드에 어떤 변경을 가하든지 상관하지 않습니다(그림 4.2 참고).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 10 54" src="https://github.com/user-attachments/assets/5e94884e-4713-4594-9d6b-50c28af137ab" />

_**그림 4.2)**_ 왼쪽에 있는 테스트는 SUT의 구현 세부사항이 아니라 관찰 가능한 동작에 결합되어 있습니다. 이러한 테스트는 리팩토링에 강하며, 거짓 양성을 거의 발생시키지 않습니다.

이 테스트가 원래 버전보다 현저히 개선된 점을 주목해 주십시오. 이 테스트는 비즈니스 요구에 부합하게, 최종 사용자에게 의미 있는 유일한 결과—즉, 메시지가 브라우저에 어떻게 표시되는지를 검증합니다. 이러한 테스트의 실패는 항상 본질적인 의미를 가지며, 고객에게 영향을 줄 수 있는 애플리케이션 동작의 변화를 전달하므로 반드시 개발자의 주의를 환기시켜야 합니다. 이 테스트는 거짓 양성(false positive)을 거의 발생시키지 않습니다.

그렇다면 왜 “전혀 없다”가 아니라 “거의 없다”고 표현할까요? 그것은 MessageRenderer에 가해진 변경 사항이 여전히 테스트를 깨뜨릴 수 있기 때문입니다. 예를 들어, Render() 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있습니다. 기술적으로 이러한 오류도 거짓 양성으로 간주됩니다. 결국, 테스트가 실패하는 이유는 애플리케이션의 동작 변화 때문이 아니라 컴파일 오류 때문입니다.

하지만 이러한 유형의 거짓 양성은 쉽게 수정할 수 있습니다. 컴파일러의 지시에 따라 Render() 메서드를 호출하는 모든 테스트에 새 매개변수를 추가하면 됩니다. 더 문제 되는 거짓 양성은 컴파일 오류로 이어지지 않는 경우입니다. 이 경우는 실제 버그처럼 보이기 때문에 문제를 파악하고 해결하는 데 훨씬 더 많은 시간이 소요됩니다.

## 4.2 첫 번째와 두 번째 속성 간의 본질적인 연관성
앞서 말씀드렸듯이, 좋은 단위 테스트의 첫 번째와 두 번째 핵심 요소—회귀 방지와 리팩터링 저항성—사이에는 본질적인 연관성이 있습니다. 이 두 속성은 서로 반대되는 관점에서 테스트 슈트의 정확도를 높이는 데 기여합니다. 또한 이 두 속성은 시간이 지남에 따라 프로젝트에 서로 다른 방식으로 영향을 미칩니다. 프로젝트가 시작된 직후에는 회귀 방지가 매우 중요하지만, 리팩터링 저항성의 필요성은 즉각적으로 나타나지는 않습니다.

이번 섹션에서는 다음 주제에 대해 설명합니다:
- 테스트 정확도 극대화
- 거짓 양성(false positive) 및 거짓 음성(false negative)의 중요성

## 4.2.1 테스트 정확도 극대화하기
잠시 한 걸음 물러나 테스트 결과와 코드의 정확성에 대한 더 넓은 관점을 살펴보겠습니다. 코드의 정확성과 테스트 결과를 기준으로 할 때, 가능한 결과는 네 가지입니다. 이는 그림 4.3에서 볼 수 있습니다. 테스트는 통과하거나 실패할 수 있으며(표의 행), 기능 자체는 올바르거나 문제가 있을 수 있습니다(표의 열).

기능이 올바르게 작동하고 테스트가 통과할 때의 상황은 정확한 추론입니다. 즉, 테스트가 시스템의 상태(버그가 없다는 것)를 정확하게 추론한 것입니다. 이처럼 기능이 정상이고 테스트가 통과하는 조합을 "참 음성(true negative: TN)"이라고 합니다.

마찬가지로, 기능에 문제가 있고 테스트가 실패하는 경우에도 이것은 정확한 추론입니다. 기능이 제대로 작동하지 않을 때 테스트가 실패하기를 기대하는 것이 바로 단위 테스트의 핵심 목적이기 때문입니다. 이러한 상황을 "참 양성(true positive: TP)"이라고 합니다.

<img width="1080" alt="스크린샷 2025-06-03 오전 1 17 35" src="https://github.com/user-attachments/assets/1e8d1d54-482e-400e-bc5e-d9ae3288f7c7" />

_**그림 4.3)**_ 회귀 방지 능력과 리팩터링 저항성 간의 관계는 다음과 같습니다. 회귀 방지 능력은 거짓 음성(Type II 오류)을 방지해주며, 리팩터링 저항성은 거짓 양성(Type I 오류)의 수를 최소화해줍니다.

하지만 테스트가 오류를 잡아내지 못할 때, 문제가 발생합니다. 이것은 우측 상단 사분면, 즉 거짓 음성(false negative: FN)의 경우입니다. 그리고 이것이 바로 좋은 테스트의 첫 번째 속성인 회귀 방지 능력(protection against regressions)이 피하려고 하는 상황입니다. 회귀 방지 능력이 좋은 테스트는 거짓 음성(Type II 오류)의 수를 최소화하는 데 도움을 줍니다.

반면, 기능에는 아무 문제가 없지만 테스트가 실패하는 경우도 있습니다. 이것은 거짓 양성(false positive:FP), 즉 잘못된 경고입니다. 이것이 바로 두 번째 속성인 리팩토링에 대한 저항성(resistance to refactoring)이 도움을 주는 부분입니다.

이러한 용어들(거짓 양성, Type I 오류 등)은 원래 통계학에서 비롯되었지만, 테스트 스위트를 분석할 때도 적용할 수 있습니다. 이 개념들을 이해하기 가장 좋은 방법은 독감 검사를 예로 드는 것입니다. 독감 검사는 검사자가 독감에 걸렸을 때 양성(positive)으로 나옵니다. 여기서 “양성”이라는 용어는 혼란스러울 수 있는데, 독감에 걸린 것이 결코 좋은 일이 아니기 때문입니다. 하지만 테스트는 상황 전체를 평가하는 것이 아니라, 특정 조건이 참인지 여부만을 판단합니다. 이 예에서 테스트가 반응하도록 설정된 조건은 “독감에 걸려 있음”입니다. 반대로, 독감이 없을 경우 테스트 결과는 음성(negative)으로 나옵니다.

이러한 정확성이야말로 좋은 단위 테스트의 첫 번째와 두 번째 핵심 속성이 지향하는 바입니다. 회귀 방지 능력과 리팩토링에 대한 저항성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 합니다. 이 정확도 지표는 다음 두 가지 요소로 구성됩니다:
- 버그가 존재함을 얼마나 잘 나타내는가 (거짓 음성의 부재 — 회귀 방지 능력의 영역)
- 버그가 존재하지 않음을 얼마나 잘 나타내는가 (거짓 양성의 부재 — 리팩토링 저항성의 영역)

<img width="1080" alt="스크린샷 2025-06-03 오전 1 21 07" src="https://github.com/user-attachments/assets/06b565c3-6e64-44be-91ac-164529d7f919" />

_**그림 4.4)**_ 테스트는 신호(버그를 찾아내는 능력)가 강하고, 잡음(거짓 경보)이 적을수록 정확도가 높습니다.

거짓 긍정과 거짓 부정을 이해하는 또 다른 방법은 신호 대 잡음 비율(signal-to-noise ratio)의 관점에서 생각하는 것입니다. 그림 4.4의 수식에서 볼 수 있듯이, 테스트 정확도를 향상시키는 방법에는 두 가지가 있습니다. 첫 번째는 분자, 즉 신호(signal)를 증가시키는 것입니다. 이는 테스트가 회귀 버그를 더 잘 찾아내도록 만드는 것을 의미합니다. 두 번째는 분모, 즉 잡음(noise)을 줄이는 것입니다. 이는 테스트가 거짓 경보를 덜 발생시키도록 만드는 것입니다.

두 가지 모두 매우 중요합니다. 거짓 경보가 전혀 없다고 하더라도 버그를 찾아내지 못하는 테스트는 쓸모가 없습니다. 마찬가지로, 코드의 모든 버그를 찾아낼 수 있다고 해도, 잡음이 너무 많아진다면 테스트의 정확도는 0에 수렴하게 됩니다. 그런 유용한 정보들조차 무의미한 정보의 바다 속에 묻혀 버리기 때문입니다.

## 4.2.2 거짓 양성(false positive)과 거짓 음성(false negative)의 중요성: 동적 변화

단기적으로는 거짓 양성(false positive:FP)이  거짓음성(false negative:FN)만큼 나쁘지는 않습니다. 프로젝트 초반에는 잘못된 경고를 받는 것이, 경고를 전혀 받지 못해 버그가 프로덕션에 반영될 위험을 감수하는 것보다는 그다지 큰 문제가 되지 않습니다. 그러나 프로젝트가 성장함에 따라, 거짓 양성은 테스트 스위트(suite)에 점점 더 큰 영향을 미치기 시작합니다 (그림 4.5 참조).

<img width="1080" alt="스크린샷 2025-06-03 오전 1 23 45" src="https://github.com/user-attachments/assets/ed96f405-1b2e-497b-a27f-125fd0e5f68d" />

_**그림 4.5)**_ 거짓 양성(잘못된 경고)은 초기에는 그다지 부정적인 영향을 미치지 않습니다. 그러나 프로젝트가 커질수록 그 영향은 점점 더 커지며, 결국 거짓 음성(발견되지 않은 버그)만큼이나 중요해집니다.

왜 거짓 양성(잘못된 경고)이 초반에는 그렇게 중요하지 않을까요? 그것은 코드 리팩터링의 중요성 또한 프로젝트 초기에는 크지 않기 때문입니다. 프로젝트 초기에 많은 코드 정리를 수행할 필요는 없습니다. 새로 작성된 코드는 대개 깔끔하고 결함이 없으며, 또한 그 코드가 아직 기억에 생생하기 때문에 테스트가 잘못된 경고를 보내더라도 쉽게 리팩터링할 수 있습니다.

하지만 시간이 지나면서 코드베이스는 점점 열화됩니다. 복잡해지고 구조가 흐트러지죠. 이런 경향을 완화하기 위해서는 주기적으로 리팩터링을 수행해야 합니다. 그렇지 않으면 새로운 기능을 도입하는 데 드는 비용이 점점 감당할 수 없을 정도로 커지게 됩니다.

리팩터링의 필요성이 커짐에 따라, 테스트의 리팩터링 저항성 또한 점점 더 중요해집니다. 앞서 설명했듯이, 테스트가 자꾸 거짓 경고를 보내고, 실제로는 존재하지 않는 버그에 대해 경고한다면 리팩터링을 진행할 수 없습니다. 그런 테스트는 신뢰를 잃게 되고, 더 이상 신뢰할 수 있는 피드백 수단으로 보지 않게 됩니다.

코드가 거짓 양성으로부터 보호받을 수 있도록 하는 것은 프로젝트 후반부에 특히 중요하지만, 대부분의 개발자들은 이를 그렇게 인식하지 않습니다. 많은 사람들이 좋은 유닛 테스트의 첫 번째 속성인 회귀 방지 능력(버그를 놓치지 않는 능력) 개선에만 집중합니다. 그러나 이것만으로는 프로젝트 성장을 지속적으로 지원할 수 있는 가치 있고 정확한 테스트 스위트를 만들 수 없습니다.

그 이유는 대부분의 프로젝트가 후반 단계에 도달하지 않기 때문입니다. 대부분 소규모 프로젝트이며, 프로젝트가 너무 커지기 전에 개발이 끝나기 때문입니다. 따라서 개발자들은 잘못된 경고보다 놓친 버그 문제를 더 자주 겪게 됩니다. 그래서 이에 맞춰 테스트를 최적화하는 것이죠.

하지만 여러분이 중간 규모 이상, 혹은 장기적인 프로젝트에 참여하고 있다면, 거짓음성(놓친 버그)과 거짓 양성(잘못된 경고) 모두에 똑같은 수준의 주의를 기울여야 합니다.

