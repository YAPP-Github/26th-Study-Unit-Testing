# 6장 단위 테스트의 스타일

- **출력 기반 테스트 (Output-based testing)**
- **상태 기반 테스트 (State-based testing)**
- **통신 기반 테스트 (Communication-based testing)**

출력 기반 테스트가 가장 품질이 높다. 통신 기반 테스트는 특별한 경우에만 사용.

순수 함수형으로 작성된 코드에만 출력 기반 테스트 스타일을 적용할 수 있다. 이를 위해 기존 코드를 함수형 아키텍쳐로 재구성해야 한다.

## 6-1 단위 테스트의 3가지 스타일

한 테스트 안에서 세 가지 스타일 중 하나 이상의 스타일을 조합해서 사용할 수 있다.

> 출력 기반
> 
- 입력값을 주고 **출력값만 검증**
- 테스트 대상이 **부작용이 없어야** 하고, **글로벌 상태나 외부 시스템에 의존하지 않아야** 한다.
- 함수형 스타일이라고 불린다
- 순수 함수 테스트에 적합

> 상태 기반
> 
- 동작 후의 **시스템 내부 상태나 외부 의존 상태**를 검증한다.
- 시스템의 내부 구조나 상태가 관찰 가능한 경우 사용.
- 주로 **클래식 학파**에서 선호.

> 통신 기반
> 
- SUT가 **협력 객체와 어떻게 소통했는지**를 검증.
    - (예: 어떤 메서드가 호출되었는지, 호출 횟수는 맞는지 등)
- Mock 객체 사용.
- 외부 시스템 호출 여부 확인에 적합.
- 주로 **런던 학파**에서 선호.

## 6-2 단위 테스트의 3가지 스타일 비교하기

> 회귀 방지 및 피드백 속도 관점에서의 스타일 비교
> 
- **회귀 방지력**: 세 가지 스타일 모두 비슷함. 테스트 커버리지, 복잡도, 도메인 중요도에 따라 결정됨.
- **통신 기반 테스트**는 얕은 테스트를 유도할 수 있는 잠재적 위험 있음 (mock 과도 사용).
- **피드백 속도**: 외부 의존성 없을 경우, 세 스타일 모두 유사. mock 사용으로 인한 미미한 차이만 존재.

---

> 리팩터링에 대한 저항력 관점에서의 스타일 비교
> 
- **출력 기반 테스트**
    - 리팩터링에 가장 강함.
    - 구현 세부사항과 결합도가 낮음 (출력만 검증).
- **상태 기반 테스트**
    - 중간 수준.
    - 내부 상태와 결합되며, API 표면적이 넓어짐 → 변경에 취약.
- **통신 기반 테스트**
    - 가장 약함.
    - mock/stub와의 상호작용이 많아 테스트 깨질 확률 높음.
    - observable behavior만 검증하도록 주의 깊은 설계 필요.

---

> 유지보수성(Maintainability) 측면에서의 테스트 스타일 비교
> 
- **출력 기반**
    - 가장 유지보수성 높음.
    - 짧고 간결, 외부 의존성 없음.
- **상태 기반**
    - 중간 수준.
    - 더 많은 assertion 필요 → 테스트 크기 커짐.
    - `헬퍼 메서드`나 `값 객체화`로 완화 가능하지만 한계 있음.
- **통신 기반**
    - 가장 유지보수성 낮음.
    - 테스트 더블 설정과 mock chain 등으로 코드 복잡도 증가.

## 6-3 함수형 아키텍쳐 이해하기

> 함수형 프로그래밍이란
> 
- 함수형 프로그래밍이란 **수학적 함수**(mathematical function)를 이용한 프로그래밍을 말한다.
- 수학적 함수란
    - 숨겨진 입력이나 출력이 없는 함수(또는 메서드)
    - 메서드 시그니처만 보면 어떤 동작을 하는지 판단 가능
    - 입력에 대해 항상 같은 출력을 반환
- **숨겨진 입력과 출력 예시**:
    - 사이드 이펙트(side effect): 인스턴스의 상태를 변경하거나, 디스크의 파일을 업데이트하는 작업 등
    - 예외(Exception): 제어 흐름 외부로 빠져나감
    - **내부 또는 외부 상태에 대한 참조**: `DateTime.Now`, 데이터베이스에서 데이터를 조회하거나, private 가변 필드에 접근하는 경우 등
- **수학적 함수인지 판단하는 좋은 기준**
    - 반환값으로 호출을 대체할 수 있는가? (참조 투명성)

> **함수형 아키텍처란 무엇인가**
> 

함수형 프로그래밍의 목적은 부작용을 완전히 제거하는 것이 아니라, 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 데 있다.

- **함수형 코어 (Functional Core) 또는 불변 코어(immutable core)**
    - 수학적 함수로만 구성됨
    - 결정만 수행
- **가변 셸 (Mutable Shell)**
    - 외부와 통신 (DB, 네트워크 등)
    - 결정된 내용을 실행 (side-effect 발생)
- 함수형 코어와 가변 셸의 협력
    - 가변 셸이 모든 입력값을 수집한다.
    - 함수형 코어가 그에 따른 결정을 생성한다.
    - 셸이 그 결정을 부작용으로 전환한다.
- 이상적인 목표는 함수형 코어를 **출력 기반 테스트(output-based tests)** 로 폭넓게 테스트하고, 가변 셸은 **소수의 통합 테스트(integration tests)** 만으로 커버하는 것

> **함수형 아키텍처와 육각형 아키텍처 비교하기**
> 
- 공통점
    - 관심사 분리
    - 단방향 의존성**(one-way dependency)**
    - **테스트 용이성(testability)**
- 차이점
    - 함수형 아키텍처는 모든 부작용을 비즈니스 작업의 가장자리로 밀어내어 **불변 코어에서 분리**한다. 육각형 아키텍처에서는 **도메인 계층 안에서 발생하는 부작용을 허용**한다
- 함수형 아키텍처는 육각형 아키텍처의 **하위집합(subset)** 으로 볼 수 있음

## 6-4 함수형 아키텍쳐로 전환하기와 출력 기반 테스트
