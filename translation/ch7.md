## 7. 가치 있는 단위 테스트를 향한 리팩터링

---

이번 장에서는 다음 내용을 다룹니다:
- 네 가지 종류의 코드를 구분하는 방법
- Humble Object 패턴에 대한 이해
- 가치 있는 테스트를 작성하는 방법

---

1장에서 저는 좋은 단위 테스트의 속성을 다음과 같이 정의했습니다:
- 개발 사이클에 통합되어 있어야 합니다.
- 코드베이스에서 가장 중요한 부분만을 대상으로 해야 합니다.
- 최소한의 유지보수 비용으로 최대의 가치를 제공해야 합니다.

이 마지막 속성을 달성하려면 다음과 같은 능력이 필요합니다:
- 가치 있는 테스트(또는 반대로 가치가 낮은 테스트)를 구별할 수 있어야 합니다.
- 가치 있는 테스트를 작성할 수 있어야 합니다.

4장에서는 회귀로부터의 보호, 리팩터링에 대한 저항성, 빠른 피드백, 유지보수성이라는 네 가지 속성을 통해 가치 있는 테스트를 어떻게 식별할 수 있는지 다뤘습니다. 그리고 5장에서는 그중에서도 가장 중요한 속성인 리팩터링에 대한 저항성을 좀 더 깊이 설명했습니다.

앞서 언급했듯이, 테스트의 가치를 알아보는 것만으로는 충분하지 않습니다. 직접 그런 테스트를 작성할 수 있어야 합니다. 이 능력은 테스트를 식별하는 능력을 바탕으로 하면서도, 코드 설계에 대한 지식도 함께 요구합니다. 단위 테스트는 테스트 대상이 되는 코드와 밀접하게 연결되어 있기 때문에, 그 코드를 개선하지 않고서는 가치 있는 테스트를 만들 수 없습니다.

6장에서는 감사 시스템(audit system)을 함수형 아키텍처로 리팩터링하고, 그 결과 출력 기반 테스트(output-based testing)를 적용할 수 있었던 사례를 살펴봤습니다. 이번 장에서는 이 접근 방식을 함수형 아키텍처를 사용할 수 없는 애플리케이션을 포함해 더 넓은 범위에 일반화해봅니다. 대부분의 소프트웨어 프로젝트에서 가치 있는 테스트를 작성할 수 있도록 도와줄 실용적인 가이드라인을 함께 살펴보겠습니다.

### 7.1. 리팩터링할 코드를 식별하기

테스트 대상이 되는 코드를 리팩터링하지 않고서는 테스트 품질을 획기적으로 개선하는 경우는 거의 없습니다. 테스트 코드와 실제 프로덕션 코드는 본질적으로 연결되어 있기 때문에, 이 점은 피할 수 없습니다.  
이번 섹션에서는 리팩터링의 방향을 정하기 위해 전체 코드를 네 가지 유형으로 분류하는 방법을 살펴봅니다. 이후의 섹션에서는 이를 바탕으로 한 포괄적인 예시를 소개합니다.

#### 7.1.1. 네 가지 코드 유형

이 섹션에서는 이번 장의 기반이 되는 네 가지 코드 유형을 소개합니다.  
모든 프로덕션 코드는 두 가지 기준에 따라 분류할 수 있습니다:
- 복잡도 또는 도메인 중요도
- 협력 객체(collaborator)의 수

코드 복잡도는 코드 내의 의사결정 지점(분기점)의 수로 정의됩니다. 이 수가 많을수록 코드의 복잡도는 높아집니다.

---

### 사이클로매틱 복잡도 계산 방법

컴퓨터 과학에서는 코드 복잡도를 나타내는 특별한 용어가 있습니다. 바로 **사이클로매틱 복잡도(cyclomatic complexity)**입니다.  
사이클로매틱 복잡도는 특정 프로그램이나 메서드 내에 존재하는 분기(branch)의 수를 나타냅니다. 이 값은 다음과 같은 공식으로 계산됩니다:

**1 + (분기 지점의 수)**

따라서 제어 흐름문(if 문이나 조건 반복문 등)이 없는 메서드는 1 + 0 = 1의 사이클로매틱 복잡도를 가집니다.

이 지표는 다른 의미로도 해석할 수 있습니다.  
즉, 하나의 메서드 내에서 진입 지점부터 종료 지점까지 존재할 수 있는 **독립적인 경로의 수**, 또는 **100% 분기 커버리지를 달성하기 위해 필요한 테스트 수**로 볼 수도 있습니다.

여기서 말하는 '분기 지점의 수'는 가장 단순한 조건(predicate)의 수를 기준으로 계산된다는 점에 유의해야 합니다.  
예를 들어, 다음과 같은 문장이 있다고 가정해보겠습니다:

`IF condition1 AND condition2 THEN ...`

이 문장은 다음과 같이 풀어 쓸 수 있습니다:

`IF condition1 THEN IF condition2 THEN ...`

따라서 이 경우의 복잡도는 **1 + 2 = 3**이 됩니다.

---

도메인 중요도(domain significance)는 코드가 프로젝트의 문제 영역(problem domain)과 얼마나 밀접하게 관련되어 있는지를 나타냅니다.  
일반적으로 도메인 레이어(domain layer)에 있는 코드는 최종 사용자의 목표와 직접 연결되어 있기 때문에 도메인 중요도가 높습니다. 반면, 유틸리티 코드는 이런 연결성이 없습니다.

복잡한 코드나 도메인 중요도가 높은 코드는 단위 테스트의 이점을 가장 많이 누릴 수 있습니다. 왜냐하면 이런 코드에 대한 테스트는 회귀로부터의 보호 효과가 크기 때문입니다.  
단, 도메인 코드라고 해서 반드시 복잡할 필요는 없고, 복잡한 코드라고 해서 도메인 중요도가 반드시 높은 것도 아닙니다. 이 두 요소는 서로 독립적입니다.  
예를 들어, 주문 금액을 계산하는 메서드는 조건문 하나 없이 작성될 수 있어 사이클로매틱 복잡도는 1에 불과할 수 있습니다. 그럼에도 불구하고 이 메서드는 비즈니스적으로 중요한 기능을 담고 있기 때문에 테스트가 꼭 필요합니다.

두 번째 기준은 클래스나 메서드가 가진 협력 객체(collaborator)의 수입니다.  
2장에서 다뤘던 것처럼, 협력 객체는 변경 가능하거나(mutable), 프로세스 외부에 존재하는(out-of-process) 의존성(혹은 그 둘 다)을 의미합니다.  
협력 객체가 많을수록 테스트는 더 비싸지고 유지보수성은 떨어지게 됩니다.  
이는 테스트 크기가 커질수록 협력 객체를 설정하고 그 상태나 상호작용을 검증하는 데 드는 코드도 많아지기 때문입니다.

협력 객체의 **종류**도 중요합니다.  
**프로세스 외부 의존성(out-of-process dependency)** 은 도메인 모델에서는 되도록 사용하지 않는 것이 좋습니다.  
이런 의존성은 테스트에서 복잡한 mock 설정을 유지해야 하기 때문에 유지보수 비용이 더 많이 듭니다.  
또한, 상호작용을 검증하는 mock은 애플리케이션 경계를 넘는 경우에만 제한적으로 사용해야 리팩터링에 강한 테스트가 될 수 있습니다 (자세한 내용은 5장을 참고하세요).

따라서 외부 의존성과의 통신은 도메인 레이어 외부의 클래스에 위임하고, 도메인 클래스는 **프로세스 내부(in-process)** 의존성만 다루는 것이 좋습니다.

또한, 협력 객체에는 **명시적인 경우**뿐 아니라 **암묵적인 경우**도 포함됩니다.  
즉, SUT(System Under Test)가 인자로 협력 객체를 받는 경우뿐만 아니라, 정적 메서드를 통해 암묵적으로 의존하는 경우도 테스트에서는 명시적으로 설정해야 하기 때문에 마찬가지로 계산에 포함됩니다.  
반면, **불변(immutable) 의존성**—예를 들면 값(value)이나 값 객체(value object)—은 설정과 검증이 훨씬 간단하기 때문에 협력 객체 수에 포함하지 않습니다.

이처럼 코드의 복잡도, 도메인 중요도, 협력 객체 수를 조합하면 다음과 같은 네 가지 코드 유형이 나옵니다 (그림 7.1 참고):

- **도메인 모델 및 알고리즘** (그림 7.1, 좌측 상단)  
  복잡한 코드는 종종 도메인 모델의 일부이지만, 항상 그런 것은 아닙니다.  
  문제 도메인과 직접적으로 관련 없는 복잡한 알고리즘도 존재할 수 있습니다.

- **단순한 코드** (그림 7.1, 좌측 하단)  
  예를 들어 C#에서는 매개변수가 없는 생성자나 한 줄로 된 프로퍼티 등이 이에 해당합니다.  
  협력 객체도 거의 없고, 복잡성이나 도메인 중요도도 낮습니다.

- **컨트롤러** (그림 7.1, 우측 하단)  
  컨트롤러 자체는 복잡하거나 비즈니스 핵심 작업을 수행하지 않지만, 도메인 클래스나 외부 시스템 등 다른 구성요소의 작업을 조율하는 역할을 합니다.

![[스크린샷 2025-06-24 15.28.04.png]]

**그림 7.1** 네 가지 코드 유형  
코드 복잡도와 도메인 중요도(세로축), 그리고 협력 객체의 수(가로축)에 따라 분류됨

- **과도하게 복잡한 코드** (그림 7.1, 우측 상단)  
  이 코드는 두 지표 모두에서 점수가 높습니다. 협력 객체가 많고, 코드 자체도 복잡하거나 중요한 역할을 합니다.  
  대표적인 예로는 fat controller가 있습니다. 이들은 복잡한 작업을 다른 구성요소에 위임하지 않고 모든 작업을 직접 처리합니다.

---

도메인 모델과 알고리즘(좌측 상단 영역)은 단위 테스트를 통해 가장 큰 효과를 얻을 수 있는 부분입니다.  
여기서의 테스트는 **가치가 높고, 유지 비용이 적습니다**.

- **가치가 높은 이유**: 해당 코드는 복잡하거나 중요한 로직을 수행하기 때문에, 테스트는 회귀로부터의 강력한 보호를 제공합니다.  
- **유지비가 적은 이유**: 협력 객체가 거의 없기 때문에 테스트의 유지보수가 쉽습니다.

반면, **단순한 코드(좌측 하단)**는 테스트하지 않는 것이 좋습니다.  
이런 테스트는 거의 아무런 가치를 주지 않습니다.

**컨트롤러(우측 하단)**는 핵심적인 로직을 직접 수행하지 않고, 도메인 클래스나 외부 시스템과 같은 다른 구성요소의 작업을 조율합니다.  
이런 코드는 단위 테스트보다는, **더 큰 범위의 통합 테스트** 일부로 간단히 테스트하는 것이 좋습니다 (3부에서 자세히 다룹니다).

가장 문제가 되는 유형은 **과도하게 복잡한 코드(우측 상단)**입니다.  
단위 테스트를 작성하기는 어렵지만, 테스트 없이 두기에는 너무 위험합니다.  
많은 개발자들이 단위 테스트를 어려워하는 주된 이유가 바로 이 코드 유형 때문입니다.  
이번 장에서는 이 딜레마를 어떻게 해결할 수 있을지 다룹니다.

핵심 전략은 이 과도하게 복잡한 코드를 두 부분으로 나누는 것입니다:
- **알고리즘**
- **컨트롤러**  
(그림 7.2 참고)

물론 실제로 이 분리를 구현하는 건 쉽지 않을 수 있지만, 이 전략이 핵심입니다.

> 💡 **TIP**  
> 코드가 중요하거나 복잡할수록 협력 객체는 적어야 합니다.

과도하게 복잡한 코드를 제거하고, **도메인 모델과 알고리즘에 대해서만 단위 테스트를 작성하는 것**이  
가치 있고, 유지하기 쉬운 테스트 스위트를 만드는 길입니다.  
이 방법을 사용하면 100% 테스트 커버리지는 얻지 못하겠지만, 그럴 필요도 없습니다.  
**100% 커버리지를 목표로 해서는 안 됩니다.**

당신의 진짜 목표는, **각 테스트가 프로젝트에 의미 있는 가치를 더하는 것**입니다.  
그렇지 않은 테스트는 리팩터링하거나 제거하세요.  
테스트 스위트의 크기만 불필요하게 부풀리는 테스트는 허용하지 마세요.

![[스크린샷 2025-06-24 15.28.41.png]]

**그림 7.2** 과도하게 복잡한 코드를 알고리즘과 컨트롤러로 분리하는 리팩터링  
이상적으로는, 우측 상단 영역에는 코드가 없어야 합니다.

> ⚠️ **NOTE**  
> 나쁜 테스트를 작성하느니, 차라리 테스트를 아예 작성하지 않는 편이 낫습니다.

물론, 과도하게 복잡한 코드를 제거하는 일은 말처럼 쉬운 일이 아닙니다.  
그럼에도 불구하고, 이를 도와줄 수 있는 몇 가지 기술이 있습니다.  
먼저 이 기술들의 이론적 배경을 설명하고, 그 다음에는 실제에 가까운 예제를 통해 시연해보겠습니다.

---

### 7.1.2. Humble Object 패턴을 활용한 코드 분리

과도하게 복잡한 코드를 분리하려면, **Humble Object** 디자인 패턴을 사용해야 합니다.  
이 패턴은 Gerard Meszaros가 저서 *xUnit Test Patterns: Refactoring Test Code* (Addison-Wesley, 2007)에서  
코드 결합도를 줄이기 위한 방법 중 하나로 처음 소개했습니다. 하지만 이 패턴은 훨씬 더 폭넓게 활용될 수 있습니다. 그 이유는 곧 확인할 수 있습니다.

코드가 테스트하기 어려운 가장 흔한 이유는, 프레임워크 의존성과 강하게 결합되어 있기 때문입니다 (그림 7.3 참고).  
예를 들면 다음과 같은 경우가 있습니다:

- 비동기 처리나 멀티스레드 실행
- 사용자 인터페이스(UI)
- 프로세스 외부 의존성과의 통신 등

![[스크린샷 2025-06-24 15.33.17.png]]

**그림 7.3**  
테스트하기 어려운 의존성과 강하게 결합된 코드는 테스트도 어렵습니다.  
이런 경우, 테스트 역시 해당 의존성을 다뤄야 하므로 유지보수 비용이 증가하게 됩니다.

![[스크린샷 2025-06-24 15.33.33.png]]

**그림 7.4**  
**Humble Object** 패턴은 복잡한 코드에서 핵심 로직을 분리해냅니다.  
이로 인해 해당 코드는 "겸손한(humble)" 코드가 되어, 자체적으로는 테스트할 필요가 없을 만큼 단순해집니다.  
분리된 로직은 테스트가 용이한 별도의 클래스로 이동되고, 원래의 코드는 그 클래스와 테스트하기 어려운 의존성을 이어주는 얇은 래퍼(wrapper)가 됩니다.

---

이런 코드를 테스트 가능하게 만들기 위해서는, **테스트 가능한 부분을 코드에서 분리해내야** 합니다.  
이 과정을 통해, 원래의 코드는 분리된 컴포넌트와 테스트하기 어려운 의존성을 연결하는 얇은 껍데기(wrapper)가 됩니다.  
이 껍데기 코드 자체에는 로직이 거의 없기 때문에, 굳이 테스트하지 않아도 됩니다 (그림 7.4 참고).

혹시 이 접근 방식이 익숙하게 느껴지신다면, 이유가 있습니다.  
이미 이 책에서 다룬 적이 있기 때문입니다.  
사실 **헥사고날 아키텍처(hexagonal architecture)**와 **함수형 아키텍처(functional architecture)** 모두 이 패턴을 그대로 따르고 있습니다.

앞서 다룬 내용들을 기억하신다면, 헥사고날 아키텍처는 **비즈니스 로직**과 **프로세스 외부 의존성과의 통신**을 분리해야 한다고 주장합니다.  
비즈니스 로직은 **도메인 레이어**가, 외부와의 통신은 **애플리케이션 서비스 레이어**가 담당합니다.

함수형 아키텍처는 여기서 한 걸음 더 나아갑니다.  
**모든 협력 객체와의 통신**을 비즈니스 로직에서 완전히 분리하는 것이 특징입니다.  
그래서 함수형 아키텍처의 핵심은 매우 테스트하기 쉬운 구조를 가집니다.  
**함수형 코어(functional core)**는 어떤 협력 객체도 가지지 않으며, 모든 의존성은 **불변(immutable)**입니다.  
덕분에, 이 구조는 코드 유형 분류 다이어그램(그림 7.5)의 **세로축(협력 객체 수 적음)**에 매우 가까운 위치를 차지합니다.

---

![[스크린샷 2025-06-24 15.33.46.png]]

**그림 7.5**  
- **함수형 아키텍처의 함수형 코어**와  
- **헥사고날 아키텍처의 도메인 레이어**는  
모두 코드 유형 분류 도표에서 좌측 상단에 위치합니다.  

이 영역은 **협력 객체가 적고**, **복잡성과 도메인 중요도는 높은 코드**를 의미합니다.

- 특히 함수형 코어는 **협력 객체가 아예 없기 때문에**, 세로축에 더 가까운 위치를 차지합니다.
- 반면, **함수형 아키텍처의 mutable shell**이나  
  **헥사고날 아키텍처의 애플리케이션 서비스 레이어**는  
  컨트롤러 영역(우측 하단)에 속하게 됩니다.

Humble Object 패턴을 또 다른 시각에서 보면, **단일 책임 원칙(Single Responsibility Principle)**을 따르는 하나의 방식으로 이해할 수 있습니다.  
이 원칙은 **하나의 클래스는 하나의 책임만 가져야 한다**고 말합니다.  
그 책임 중 하나는 언제나 **비즈니스 로직**이며, 이 패턴은 그 로직을 다른 모든 것으로부터 분리하는 데 활용될 수 있습니다.

이번 맥락에서 우리가 특히 관심을 가지는 것은 **비즈니스 로직**과 **오케스트레이션(orchestration)**의 분리입니다.  
이 두 책임은 코드의 **깊이(depth)**와 **너비(width)**라는 관점으로도 생각해볼 수 있습니다.

- **깊은 코드**: 복잡하거나 중요한 로직을 담고 있음
- **넓은 코드**: 많은 협력 객체와 상호작용함

코드는 깊거나 넓을 수는 있지만, **둘 다여서는 안 됩니다** (그림 7.6 참고).

![[스크린샷 2025-06-24 15.35.54.png]]

**그림 7.6**  
코드의 "깊이"와 "너비" 개념은 비즈니스 로직과 오케스트레이션 책임을 분리할 때 유용한 비유입니다.  
- **컨트롤러(Controller)**는 많은 의존성(화살표로 표시됨)을 조율하지만, 그 자체는 복잡하지 않습니다 (블록의 높이로 표시).  
- **도메인 클래스(Domain class)**는 그 반대로, 복잡하지만 의존성은 거의 없습니다.

---

이 분리가 얼마나 중요한지 아무리 강조해도 지나치지 않습니다.  
실제로 널리 알려진 여러 원칙과 패턴들이 **Humble Object 패턴의 변형**이라고 할 수 있습니다.  
이들 모두는 복잡한 로직과 오케스트레이션 코드를 **명확히 분리**하기 위해 고안된 것입니다.

앞서 본 것처럼, 헥사고날 아키텍처와 함수형 아키텍처 모두 이 패턴과 밀접한 관계가 있습니다.  
그 외의 예시로는 다음과 같은 것들이 있습니다:

- **MVP(Model-View-Presenter)**  
- **MVC(Model-View-Controller)**  

이 두 패턴은 **비즈니스 로직(Model)**, **UI(View)**, 그리고 이 둘의 조율(Presenter 또는 Controller)을 **분리**하는 데 도움을 줍니다.  
여기서 Presenter나 Controller는 **Humble Object**의 역할을 하며, View와 Model을 연결하는 얇은 껍데기 역할을 합니다.

또 하나의 예시는 **Domain-Driven Design**에서의 **Aggregate 패턴**입니다.  
이 패턴의 목표 중 하나는 클래스를 클러스터(aggregate)로 묶어 **클래스 간 연결성을 줄이는 것**입니다.  
- 클러스터 내부에서는 클래스 간 연결이 강하지만,  
- 클러스터 간에는 느슨하게 결합됩니다.  

이러한 구조는 코드베이스 전체에서의 통신 수를 줄여줍니다.  
결과적으로 테스트가 쉬워지고, 유지보수성도 향상됩니다.

---

비즈니스 로직과 오케스트레이션을 분리하는 이유는 **테스트 용이성 향상**에만 있는 것이 아닙니다.  
이 분리는 **코드 복잡도를 제어하는 데도 효과적**이며,  
이는 프로젝트가 장기적으로 성장해 나가기 위해서도 **매우 중요합니다**.

저는 개인적으로 **테스트 가능한 설계는 단지 테스트하기 쉬운 것을 넘어서, 유지보수도 쉬운 구조**가 된다는 점이 정말 흥미롭다고 생각합니다.

### 7.2. 가치 있는 단위 테스트를 위한 리팩터링

이번 섹션에서는 **과도하게 복잡한 코드**를 **알고리즘**과 **컨트롤러**로 나누는 포괄적인 예시를 소개합니다.  
비슷한 예시를 이전 장에서도 살펴봤는데, 당시에는 출력 기반 테스트(output-based testing)와 함수형 아키텍처에 초점을 맞췄었죠.  
이번에는 이 접근 방식을 **모든 엔터프라이즈 수준의 애플리케이션**에 적용할 수 있도록 일반화해보겠습니다.  
**Humble Object 패턴**의 도움을 받아 이를 구현할 것이며, 이 프로젝트는 이 장뿐 아니라 3부의 다른 장들에서도 계속 활용할 예정입니다.

---

#### 7.2.1. 고객 관리 시스템 소개

예시 프로젝트는 **고객 관리 시스템(CRM)**입니다. 이 시스템은 사용자 등록을 관리하며, 모든 사용자 정보는 데이터베이스에 저장됩니다.  
현재 이 시스템은 단 하나의 유스 케이스만 지원합니다: **사용자의 이메일 변경**

이 기능에는 세 가지 비즈니스 규칙이 있습니다:

- 사용자의 이메일이 회사 도메인에 속하면, 해당 사용자는 **직원**으로 간주됩니다.  
  그렇지 않으면, **고객**으로 처리됩니다.
- 시스템은 **직원 수**를 추적해야 합니다.  
  사용자의 유형이 직원에서 고객으로, 혹은 그 반대로 변경되면, 이 숫자도 함께 변경되어야 합니다.
- 이메일이 변경되면, 시스템은 외부 시스템에 **메시지 버스(message bus)**를 통해 알림을 보내야 합니다.

---

이제 CRM 시스템의 초기 구현을 살펴보겠습니다.

> 📄 **코드 목록 7.1**  
> CRM 시스템의 초기 구현

![[스크린샷 2025-06-24 15.40.56.png]]
![[스크린샷 2025-06-24 15.41.13.png]]

`User` 클래스는 사용자의 이메일을 변경하는 책임을 가지고 있습니다.  
코드의 가독성을 위해 이메일 유효성 검사나 데이터베이스에서 사용자의 존재 여부 확인 등 **단순한 유효성 검사는 생략**했습니다.

이제 이 구현을 **코드 유형 분류 도표(types-of-code diagram)**의 관점에서 분석해보겠습니다.

- 코드의 **복잡도는 그렇게 높지 않습니다.**  
  `ChangeEmail` 메서드는 명시적인 분기 지점이 두 군데뿐입니다:
  - 사용자를 **직원** 또는 **고객**으로 구분
  - 회사의 직원 수를 어떻게 업데이트할지 결정

  하지만 코드가 단순하다고 해도, 이 결정들은 **중요한 비즈니스 로직**입니다.  
  따라서 이 클래스는 **복잡도와 도메인 중요도 측면에서 높은 점수**를 얻습니다.

- 반면, `User` 클래스에는 총 네 개의 의존성이 존재합니다.  
  - 이 중 **두 개는 명시적이고**,  
  - **두 개는 암묵적입니다.**

  명시적인 의존성은 `userId`와 `newEmail`입니다.  
  하지만 이 둘은 단순한 값(value)이기 때문에, **협력 객체 수에는 포함되지 않습니다.**

  암묵적인 의존성은 `Database`와 `MessageBus`입니다.  
  이 둘은 모두 **프로세스 외부 의존성(out-of-process collaborators)**입니다.

앞서 설명했듯이, **도메인 중요도가 높은 코드**에 외부 의존성이 포함되는 것은 **지양해야 할 구조**입니다.  
따라서 `User` 클래스는 **협력 객체 수 측면에서도 높은 점수**를 받게 되고,  
결과적으로 **과도하게 복잡한 코드** 범주에 속하게 됩니다 (그림 7.7 참고).

---

이런 구조처럼, **도메인 클래스가 직접 데이터베이스에서 자신을 조회하고 저장하는 방식**은  
**Active Record 패턴**이라고 부릅니다.

이 패턴은 간단한 프로젝트나 단기 프로젝트에서는 잘 작동하지만,  
**코드베이스가 커질수록 확장성에서 문제가 발생**하는 경우가 많습니다.

가장 큰 이유는 바로 다음 두 책임이 분리되지 않기 때문입니다:
- **비즈니스 로직**
- **프로세스 외부 의존성과의 통신**

---

![[스크린샷 2025-06-24 15.41.32.png]]

**그림 7.7**  
초기 `User` 클래스 구현은  
- **복잡도와 도메인 중요도**,  
- **협력 객체 수**  
양쪽 모두에서 높은 점수를 받아  
**과도하게 복잡한 코드** 범주에 속합니다.

#### 7.2.2. 첫 번째 시도: 암묵적 의존성을 명시적으로 바꾸기

테스트 가능성을 높이기 위한 가장 일반적인 접근 방식은, **암묵적인 의존성을 명시적으로 만드는 것**입니다.  
즉, `Database`와 `MessageBus`에 대한 **인터페이스를 정의하고**, 이를 `User` 클래스에 주입(inject)한 다음, 테스트에서는 **mock**을 사용하는 방식입니다.

이 방식은 어느 정도 효과가 있습니다. 실제로 이전 장에서 감사 시스템(audit system)에 mock을 도입할 때도 이 방식을 사용했었죠.  
하지만 **이것만으로는 충분하지 않습니다.**

**코드 유형 분류 다이어그램** 관점에서 보면, 도메인 모델이 외부 의존성에 직접 접근하든, 인터페이스를 통해 간접 접근하든 **본질은 동일합니다**.  
이러한 의존성은 여전히 **프로세스 외부(out-of-process)**에 있기 때문입니다.  
이는 메모리에 없는 데이터를 프록시(proxy)를 통해 다루는 것과 같으며, 테스트를 위해서는 여전히 **복잡한 mock 설정**이 필요합니다.  
그 결과, **테스트의 유지보수 비용**이 높아집니다.

게다가 database 의존성에 mock을 사용하는 것은 **테스트의 불안정성(test fragility)**으로 이어질 수 있습니다. (자세한 내용은 다음 장에서 다룹니다.)

결론적으로, **도메인 모델은 외부 시스템과 직접 또는 간접적으로 어떤 방식으로든 연결되어서는 안 됩니다.**  
이것이 바로 헥사고날 아키텍처가 주장하는 핵심 원칙이기도 합니다.  
> 도메인 모델은 외부 시스템과의 통신 책임을 절대 가져서는 안 됩니다.

---

#### 7.2.3. 두 번째 시도: 애플리케이션 서비스 레이어 도입

도메인 모델이 외부 시스템과 직접 통신하는 문제를 해결하기 위해, **이 책임을 별도의 클래스로 옮겨야** 합니다.  
즉, **겸손한 컨트롤러(Humble Controller)**, 즉 헥사고날 아키텍처 용어로는 **애플리케이션 서비스(Application Service)**입니다.

일반적인 규칙으로, 도메인 클래스는 다음과 같은 **프로세스 내부(in-process)** 의존성만 가져야 합니다:
- 다른 도메인 클래스
- 단순 값(value)

다음은 첫 번째 버전의 애플리케이션 서비스 클래스입니다:

> 📄 **코드 목록 7.2**  
> 애플리케이션 서비스 클래스, 버전 1

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public void ChangeEmail(int userId, string newEmail)
    {
        object[] data = _database.GetUserById(userId);
        string email = (string)data[1];
        UserType type = (UserType)data[2];
        var user = new User(userId, email, type);

        object[] companyData = _database.GetCompany();
        string companyDomainName = (string)companyData[0];
        int numberOfEmployees = (int)companyData[1];

        int newNumberOfEmployees = user.ChangeEmail(
            newEmail, companyDomainName, numberOfEmployees);

        _database.SaveCompany(newNumberOfEmployees);
        _database.SaveUser(user);
        _messageBus.SendEmailChangedMessage(userId, newEmail);
    }
}
```

이 구현은 나쁘지 않은 첫 시도입니다.  
**User 클래스에서 외부 시스템과의 상호작용 책임을 분리**해냈기 때문입니다.  
하지만 여전히 몇 가지 문제점이 있습니다:

- `Database`와 `MessageBus` 같은 외부 의존성이 **직접 인스턴스화**되어 있습니다.  
  나중에 이 클래스를 위한 **통합 테스트를 작성할 때 문제가 됩니다.**

- 컨트롤러가 **데이터베이스에서 받은 원시 데이터를 기반으로 User 인스턴스를 복원**하고 있습니다.  
  이 작업은 **복잡한 로직**이며, 단순한 오케스트레이션만 담당해야 하는 애플리케이션 서비스에 포함되면 안 됩니다.

- 회사(employee count) 관련 데이터도 마찬가지입니다.  
  `User` 클래스가 **직원 수 변경 결과를 반환하는 것**은 구조적으로 어색합니다.  
  **직원 수는 특정 유저의 책임이 아닙니다.** 이 로직은 다른 곳에서 관리되어야 합니다.

- 새 이메일이 기존 이메일과 같든 다르든 **무조건 데이터 저장과 알림 전송을 수행**합니다.  
  이는 불필요한 작업을 유발할 수 있습니다.

---

하지만 이런 문제들을 제외하면, 현재의 `User` 클래스는 **테스트가 매우 쉬운 구조**가 되었습니다.  
- 더 이상 외부 의존성과 통신하지 않으며,  
- 협력 객체도 아예 존재하지 않습니다.

다음은 `User` 클래스의 `ChangeEmail` 메서드의 새로운 버전입니다:

```csharp
public int ChangeEmail(string newEmail, string companyDomainName, int numberOfEmployees)
{
    if (Email == newEmail)
        return numberOfEmployees;

    string emailDomain = newEmail.Split('@')[1];
    bool isEmailCorporate = emailDomain == companyDomainName;

    UserType newType = isEmailCorporate
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        int newNumber = numberOfEmployees + delta;
        numberOfEmployees = newNumber;
    }

    Email = newEmail;
    Type = newType;

    return numberOfEmployees;
}
```

![[스크린샷 2025-06-24 16.01.49.png]]

**그림 7.8**

Take 2에서는 User 클래스가 **도메인 모델 영역의 세로축 근처**, 
즉 협력 객체가 없는 영역으로 옮겨졌습니다. 
반면 UserController는 **컨트롤러 영역에 있긴 하지만**, 내부 로직이 꽤 복잡해서 
**과도하게 복잡한 코드 영역의 경계에 가까워지고 있는 상태**입니다.

### 7.2.4. 세 번째 시도: 애플리케이션 서비스에서 복잡도 제거하기

`UserController`를 **명확히 컨트롤러 영역에 위치시키기 위해**, 우리는 이 안에 들어 있는 **객체 복원 로직(reconstruction logic)**을 분리해야 합니다.

만약 ORM(Object-Relational Mapping) 라이브러리를 사용하고 있다면, 이 **복원 로직을 ORM에 위임**하는 것이 좋습니다.  
대부분의 ORM 라이브러리는 데이터베이스 테이블을 도메인 클래스에 어떻게 매핑할지 정의할 수 있는 구조를 제공합니다.  
예를 들어:
- 클래스 위에 어노테이션을 붙이거나,
- XML 파일을 사용하거나,
- 플루언트 매핑을 정의하는 전용 파일을 작성할 수 있습니다.

만약 ORM을 사용하지 않거나 사용할 수 없는 상황이라면,  
**도메인 모델 내부에 팩토리(factory)**를 만들어서 데이터베이스의 원시 데이터를 기반으로 도메인 객체를 생성할 수 있습니다.  
이 팩토리는 별도의 클래스로 정의할 수도 있고, 단순한 경우에는 도메인 클래스 안에 정적 메서드로 포함시켜도 됩니다.

이번 예제의 복원 로직은 그렇게 복잡하지 않지만, 이런 책임은 **분리하는 것이 바람직**하기 때문에 `UserFactory`라는 별도 클래스로 정의했습니다:

> 📄 **코드 목록 7.3**  
> `UserFactory` 클래스

```csharp
public class UserFactory
{
    public static User Create(object[] data)
    {
        Precondition.Requires(data.Length >= 3);
        int id = (int)data[0];
        string email = (string)data[1];
        UserType type = (UserType)data[2];
        return new User(id, email, type);
    }
}
```

이제 이 코드는 모든 협력 객체와 **완전히 분리되어 있기 때문에 테스트하기 쉽습니다.**

또한, 이 메서드에는 **안전장치**도 추가했습니다:
data 배열에 **최소 3개의 요소가 있어야 한다는 조건**입니다.
Precondition은 단순한 커스텀 클래스이며, 조건이 false일 경우 예외를 던집니다.

이 클래스의 장점은 다음과 같습니다:
- 코드가 간결해지고,
- 부정 조건보다 긍정 조건을 사용할 수 있어 **가독성이 향상**됩니다.

예를 들어, 다음과 같은 표현보다는:

```csharp
if (data.Length < 3)
    throw new Exception();
```

다음과 같이 쓰는 것이 더 읽기 쉽습니다:

```csharp
Precondition.Requires(data.Length >= 3);
```

---

이 복원 로직은 **약간의 복잡성은 있지만, 도메인 중요도는 없습니다.**
즉, 사용자의 이메일을 변경하려는 클라이언트의 목표와는 **직접적인 관련이 없습니다.**
이는 앞서 설명했던 **유틸리티 코드**의 전형적인 예시입니다.

---
#### **❓ 복원 로직이 왜 복잡한가요?**

UserFactory.Create() 메서드에는 **명시적인 분기(branch)가 거의 없는데**,
왜 복잡하다고 판단할 수 있을까요?

1장에서 언급했듯이, 우리가 작성한 코드 안에 보이지 않지만,
**내부 라이브러리에서 수많은 분기점이 발생할 수 있습니다.**

이 메서드가 바로 그런 경우입니다.

- `data[0]`과 같이 배열 인덱스로 접근하는 것도,
    내부적으로는 **.NET Framework가 어떤 요소를 반환할지 결정하는 분기**를 거칩니다.

- object 타입에서 int나 string으로 변환하는 과정도 마찬가지입니다.
    내부적으로는:
    - 예외를 던질지,
    - 형 변환을 허용할지 등

다양한 판단이 이루어집니다.

이러한 **숨겨진 분기(hidden branches)들** 때문에,
비록 코드에 눈에 띄는 조건문이 없어도, 이 복원 로직은 **테스트의 가치가 있는 코드**가 됩니다.

### 네 번째 시도: 새로운 Company 클래스 도입

다시 한 번 컨트롤러 코드를 살펴보면 다음과 같은 부분이 있습니다:

```csharp
object[] companyData = _database.GetCompany();
string companyDomainName = (string)companyData[0];
int numberOfEmployees = (int)companyData[1];
int newNumberOfEmployees = user.ChangeEmail(
    newEmail, companyDomainName, numberOfEmployees);
```

이 코드에서, User가 **직원 수 변경 결과를 반환하는 구조**는 어색합니다.
이는 **책임이 잘못 배치되어 있다는 신호**이며,
그 자체로 **추상화가 부족하다는 증거**이기도 합니다.

이 문제를 해결하기 위해서는, 회사 관련 데이터와 로직을 묶어줄 **새로운 도메인 클래스 Company**를 도입해야 합니다. 

다음은 그 클래스의 구현입니다.

---

> 📄 **코드 목록 7.4**  
> `Company` 클래스

```csharp
public class Company
{
    public string DomainName { get; private set; }
    public int NumberOfEmployees { get; private set; }

    public void ChangeNumberOfEmployees(int delta)
    {
        Precondition.Requires(NumberOfEmployees + delta >= 0);
        NumberOfEmployees += delta;
    }

    public bool IsEmailCorporate(string email)
    {
        string emailDomain = email.Split('@')[1];
        return emailDomain == DomainName;
    }
}
```

이 클래스에는 두 가지 주요 메서드가 있습니다:

- `ChangeNumberOfEmployees()`  
- `IsEmailCorporate()`

이들은 5장에서 소개한 **Tell, Don’t Ask 원칙**을 잘 따릅니다.  
즉, 데이터를 가져와 직접 처리하지 않고, **객체에 "무엇을 해야 하는지"를 말하도록** 합니다.

`User`는 이제 회사 데이터를 직접 다루는 대신,  
- 이메일이 회사 도메인인지 판단하는 작업,  
- 직원 수를 변경하는 작업을  
**`Company` 클래스에 위임**합니다.

---

이제 `Company` 객체도 `UserFactory`와 마찬가지로, 별도의 팩토리를 통해 생성하게 됩니다.  
다음은 리팩터링 이후의 컨트롤러입니다.

> 📄 **코드 목록 7.5** 
> 리팩토링 이후 `UserController` 클래스

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public void ChangeEmail(int userId, string newEmail)
    {
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);

        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);

        user.ChangeEmail(newEmail, company);

        _database.SaveCompany(company);
        _database.SaveUser(user);
        _messageBus.SendEmailChangedMessage(userId, newEmail);
    }
}
```

이제 도메인 객체인 `User`도 다음과 같이 정리됩니다:

> 📄 **코드 목록 7.6**
> 리팩토링 이후 `User` 클래스

```csharp
public class User
{
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }

    public void ChangeEmail(string newEmail, Company company)
    {
        if (Email == newEmail)
            return;

        UserType newType = company.IsEmailCorporate(newEmail)
            ? UserType.Employee
            : UserType.Customer;

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
        }

        Email = newEmail;
        Type = newType;
    }
}
```

이처럼, 책임이 올바르게 분리되면서 `User` 클래스는 훨씬 **간결하고 명확한 구조**가 되었습니다.  
이전에는 `User`가 직접 회사 데이터를 다루고 있었지만,  
이제는 `Company` 객체에 **필요한 요청만 전달하고**,  
자신의 역할인 이메일 변경 로직만 담당합니다.

---

**그림 7.9**에서는 각 클래스가 코드 유형 분류 도표에서 어디에 위치하는지를 보여줍니다.

- 팩토리들과 `User`, `Company` 클래스는 모두  
  **도메인 모델 및 알고리즘 영역(좌측 상단)**에 속합니다.
- 단, `User`는 **이제 `Company`라는 협력 객체를 가지게 되었기 때문에**  
  **세로축에서 살짝 오른쪽으로 이동**했습니다.

이로 인해 `User` 클래스는 **이전보다 약간 테스트하기 어려워졌지만**,  
큰 차이는 없습니다.

![[스크린샷 2025-06-24 18.40.13.png]]

**그림 7.9**

`User` 클래스는 이제 `Company`라는 협력 객체를 갖게 되었기 때문에,  
**도메인 모델 영역 내에서 오른쪽으로 이동**했습니다.  
한편, `UserController`는 모든 복잡한 로직을 팩토리로 분리한 덕분에  
**컨트롤러 영역에 확고히 자리 잡게 되었습니다.**

이제 `UserController`는 다양한 협력 객체들을 조립하는 **오케스트레이터 역할**만 담당합니다.  
복잡한 로직은 모두 팩토리로 이동했고,  
이 클래스는 책임이 단순해져 명확히 **컨트롤러 영역**에 속하게 되었습니다.

---

이번 구현은 **이전 장에서 다뤘던 함수형 아키텍처**와 매우 유사한 구조를 가집니다.

- 감사 시스템(audit system)의 **functional core**  
- CRM 시스템의 **도메인 레이어 (`User`, `Company`)**

이 둘 모두 공통적으로, **프로세스 외부 의존성과 직접 통신하지 않습니다.**

이러한 외부 통신은 모두 **애플리케이션 서비스 레이어**에서 담당합니다:
- 파일 시스템이나 데이터베이스로부터 **원시 데이터를 읽어오고**,  
- 이를 상태가 없는 알고리즘이나 도메인 모델에 전달하며,  
- 처리 결과를 다시 저장소에 **반영(persist)**합니다.

---

두 구현의 가장 큰 차이점은 **부작용(side effect)**에 대한 처리 방식입니다.

- 함수형 아키텍처의 core는 **아예 부작용이 없습니다.**
- 반면, CRM 시스템의 도메인 모델은 이메일 변경이나 직원 수 변경처럼  
  **일부 부작용을 내부적으로 가지고 있습니다.**

하지만 중요한 점은, 이 모든 부작용이 **도메인 모델 내부 메모리 내에서만 발생**하며,  
**컨트롤러가 해당 객체를 DB에 저장할 때만 외부로 전달된다는 점입니다.**

---

이처럼 **모든 부작용이 메모리 안에 국한되어 있다**는 점은 **테스트 가능성을 크게 향상**시킵니다.

- 테스트가 외부 시스템과 통신할 필요가 없고,  
- 복잡한 커뮤니케이션 기반 테스트도 필요 없습니다.

우리는 **출력 기반 테스트(output-based testing)** 또는  
**상태 기반 테스트(state-based testing)**만으로도 충분히 검증할 수 있습니다.

---

### 7.3. 최적의 단위 테스트 커버리지 분석

이제 **Humble Object 패턴을 통한 리팩터링이 완료**되었으니,  
이제는 프로젝트 내 각 코드가 **어떤 유형의 코드에 해당하며**,  
**어떤 방식으로 테스트되어야 하는지**를 분석할 수 있습니다.

다음에 나올 **표 7.1**은 샘플 프로젝트의 모든 코드를  
**코드 유형 분류 도표(types-of-code diagram)**의 위치 기준으로 정리한 것입니다.

---

비즈니스 로직과 오케스트레이션을 완전히 분리했기 때문에,  
이제 **어떤 코드에 단위 테스트를 적용할지 명확하게 판단할 수 있습니다.**

**📊 표 7.1 — Humble Object 패턴을 적용한 리팩터링 이후 샘플 프로젝트의 코드 유형 분류**

|                           | 협력 객체 적음                                                                                                                                                                                        | 협력 객체 많음                                       |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| **복잡도 높거나<br>도메인 중요도 높음** | - `User.ChangeEmail(newEmail, company)`<br>- `Company.ChangeNumberOfEmployees(delta)`<br>- `Company.IsEmailCorporate(email)`<br>- `UserFactory.Create(data)`<br>- `CompanyFactory.Create(data)` | -                                              |
| **복잡도 낮고<br>도메인 중요도 낮음**  | - `User`와 `Company`의 생성자(Constructor)                                                                                                                                                           | `UserController.ChangeEmail(userId, newEmail)` |

#### 7.3.1 도메인 레이어와 유틸리티 코드 테스트하기

**표 7.1**에서 좌측 상단에 위치한 메서드들을 테스트하는 것이 **비용 대비 효과** 측면에서 가장 좋습니다.

- 코드가 **복잡하거나 도메인적으로 중요**하기 때문에,  
  테스트는 회귀로부터 **강력한 보호 효과**를 가집니다.
- 동시에 **협력 객체가 적기 때문에**,  
  테스트의 **유지보수 비용도 최소화**됩니다.

다음은 `User` 클래스를 어떻게 테스트할 수 있는지 보여주는 예시입니다:

다음은 이메일을 **비기업 이메일에서 기업 이메일로 변경**할 때의 테스트 예시입니다:

```csharp
[Fact]
public void Changing_email_from_non_corporate_to_corporate()
{
    var company = new Company("mycorp.com", 1);
    var sut = new User(1, "user@gmail.com", UserType.Customer);

    sut.ChangeEmail("new@mycorp.com", company);

    Assert.Equal(2, company.NumberOfEmployees);
    Assert.Equal("new@mycorp.com", sut.Email);
    Assert.Equal(UserType.Employee, sut.Type);
}
```

**완전한 커버리지(full coverage)**를 얻기 위해서는  
다음과 같은 **3가지 추가 테스트**가 필요합니다:

- `Changing_email_from_corporate_to_non_corporate`  
- `Changing_email_without_changing_user_type`  
- `Changing_email_to_the_same_one`

---

다른 세 클래스에 대한 테스트는 이보다 더 간단할 수 있습니다.  
그리고 여러 테스트 케이스를 하나로 묶기 위해  
**파라미터화된 테스트(parameterized test)**를 사용할 수 있습니다.

다음은 이메일이 기업 도메인에 해당하는지 여부를 검사하는 테스트 예시입니다:

```csharp
[InlineData("mycorp.com", "email@mycorp.com", true)]
[InlineData("mycorp.com", "email@gmail.com", false)]
[Theory]
public void Differentiates_a_corporate_email_from_non_corporate(
    string domain, string email, bool expectedResult)
{
    var sut = new Company(domain, 0);
    bool isEmailCorporate = sut.IsEmailCorporate(email);
    Assert.Equal(expectedResult, isEmailCorporate);
}
```

#### 7.3.2 나머지 세 영역의 코드 테스트하기

**표 7.1의 좌측 하단**, 즉 **복잡도가 낮고 협력 객체도 적은 코드**는  
`User`와 `Company`의 **생성자(Constructor)**를 예로 들 수 있습니다:

```csharp
public User(int userId, string email, UserType type)
{
    UserId = userId;
    Email = email;
    Type = type;
}
```

이런 생성자들은 구조가 단순해서, **굳이 테스트할 가치가 없습니다.**  
테스트를 작성한다고 해도, **회귀로부터 얻을 수 있는 보호 효과가 거의 없습니다.**

또한, **표 7.1의 우측 상단**(복잡하고 협력 객체도 많은 코드)은  
이번 리팩터링 과정에서 **모두 제거되었기 때문에 테스트할 대상이 없습니다.**

**컨트롤러 영역(표 7.1의 우측 하단)**에 대한 테스트는  
**다음 장에서** 자세히 다룰 예정입니다.

#### 7.3.3 전제 조건(Precondition)을 테스트해야 할까?

이제 조금 특별한 **분기 지점**, 즉 **전제 조건(precondition)**에 대해 살펴보겠습니다.  
이런 조건들도 테스트 대상이 될 수 있을까요?

예를 들어, `Company` 클래스의 다음 메서드를 다시 보겠습니다:

```csharp
public void ChangeNumberOfEmployees(int delta)
{
    Precondition.Requires(NumberOfEmployees + delta >= 0);
    NumberOfEmployees += delta;
}
```

이 메서드에서는 **직원 수가 음수가 되어서는 안 된다**는 전제 조건을 명시하고 있습니다.  
이런 전제 조건은 **예외적인 상황**에서만 동작하며,  
보통은 코드의 **버그로 인해 발생할 수 있는 상황을 막기 위해** 존재합니다.

이러한 safeguard는 소프트웨어가 **더 심각한 오류로 번지기 전에 빠르게 실패하도록(fail fast)** 도와줍니다.  
예를 들어, 직원 수가 음수로 저장되어 데이터베이스에 반영된다면  
그 문제를 추적하고 수정하는 일이 훨씬 어려워질 수 있습니다.

---

그렇다면, 이런 전제 조건을 **테스트해야 할까요?**  
즉, 이런 테스트가 테스트 스위트에 들어갈 만큼 **가치 있는가요?**

정답은 상황에 따라 다르지만, 일반적인 가이드라인은 다음과 같습니다:

- **도메인적으로 의미 있는 전제 조건은 테스트하라.**  
  예: 직원 수는 음수가 될 수 없다 → 이는 `Company` 클래스의 **불변 조건(invariant)**이며,  
  항상 만족되어야 하는 핵심 규칙입니다.

- 반대로, **도메인 의미가 없는 전제 조건은 굳이 테스트할 필요가 없다.**

예를 들어, 다음은 `UserFactory`의 전제 조건입니다:

```csharp
public static User Create(object[] data)
{
    Precondition.Requires(data.Length >= 3);
    // id, email, type 추출
}
```

이 전제 조건은 단지 **배열의 길이 검증**일 뿐이며,  
**도메인 규칙과는 무관**하기 때문에,  
이 경우엔 굳이 테스트를 작성할 필요는 없습니다.

#### 7.4. 컨트롤러에서 조건 분기 로직 다루기

조건 분기 로직을 다루면서 동시에 **도메인 레이어를 외부 시스템과 분리된 상태로 유지하는 것**은  
쉽지 않으며, **여러 가지 트레이드오프(trade-off)**를 수반합니다.  
이번 섹션에서는 어떤 트레이드오프가 존재하는지,  
그리고 각 프로젝트 상황에 맞춰 **어떤 선택을 할지 결정하는 방법**을 설명합니다.

---

비즈니스 로직과 오케스트레이션을 분리하는 구조는,  
다음 세 단계가 **명확하게 구분되는 경우**에 가장 잘 작동합니다:

1. 저장소에서 데이터를 읽어오기  
2. 비즈니스 로직 실행  
3. 처리된 데이터를 다시 저장소에 저장  

이런 구조는 다음 아키텍처에서 가장 잘 작동합니다:

- **헥사고날 아키텍처**
- **함수형 아키텍처**

![[스크린샷 2025-06-24 18.49.56.png]]

> 📊 **그림 7.10**  
> 외부 시스템과의 연결을 **비즈니스 연산의 가장자리에만 배치**하면  
> 구조적 명확성과 테스트 용이성이 모두 향상됩니다.

---

하지만 현실에서는 **이 세 단계가 명확하게 나뉘지 않는 경우**도 많습니다.

예를 들어, 이전 장에서 다뤘던 것처럼  
**비즈니스 로직 중간 단계에서 외부 시스템에 추가 데이터를 요청해야 하는 경우**도 있고,  
**외부 시스템에 쓰기(write) 작업을 해야 할지 말지를**  
결정 로직에 따라 정해야 하는 경우도 있습니다.

![[스크린샷 2025-06-24 18.50.10.png]]

> 📊 **그림 7.11**  
> 비즈니스 로직 도중 외부 시스템과 상호작용해야 하는 경우에는  
> 헥사고날 아키텍처의 구조가 잘 맞지 않을 수 있습니다.

---

이러한 상황에서 선택할 수 있는 세 가지 접근 방식은 다음과 같습니다:

1. **외부 시스템과의 통신을 비즈니스 연산의 시작 또는 끝에 몰아넣기**  
   - `read-decide-act` 구조는 유지되지만,  
     필요하지 않은 경우에도 외부 시스템 호출이 발생하므로 **성능 저하**가 발생할 수 있습니다.

2. **도메인 모델에 외부 의존성을 직접 주입**  
   - 비즈니스 로직이 외부 시스템 호출 여부를 직접 결정하지만,  
     **도메인 모델 테스트 용이성이 크게 감소**합니다.

3. **의사결정 과정을 더 세분화하여 컨트롤러에서 각각 처리**  
   - 테스트성과 성능을 모두 확보할 수 있지만,  
     **컨트롤러 로직이 복잡해지고**,  
     관리하기 어려운 상태로 갈 수 있습니다.

![[스크린샷 2025-06-24 18.50.18.png]]

> 📊 **그림 7.12**  
> 세 가지 속성 —  
> **도메인 모델 테스트 용이성**,  
> **컨트롤러 단순성**,  
> **성능**  
> 을 모두 만족시키는 하나의 해결책은 존재하지 않습니다.  
> **세 가지 중 두 개만 선택할 수 있습니다.**

---

현실적으로는 **성능이 중요한 프로젝트가 많기 때문에**,  
첫 번째 접근 방식(모든 외부 통신을 가장자리에 배치)은 **현실적이지 않습니다.**

두 번째 접근 방식(도메인에 외부 의존성 주입)은  
결과적으로 **도메인 모델을 과도하게 복잡하게 만들며**,  
이번 장에서 리팩터링했던 **초기 CRM 구조로 회귀하게 됩니다.**  
따라서 **이 방식은 피하는 것을 권장합니다.**

---

그렇다면 가장 현실적인 선택지는 세 번째입니다:  
**의사결정 로직을 세분화하고, 컨트롤러에서 각 단계별로 처리**하는 방식입니다.

물론, 이 접근 방식은 **컨트롤러를 더 복잡하게 만들 수 있고**,  
코드 유형 분류 도표에서 **"과도하게 복잡한 코드" 영역에 가까워질 위험**도 있습니다.

하지만, 컨트롤러의 복잡도는 **적절한 리팩터링과 분리**를 통해  
충분히 **관리 가능한 수준으로 유지할 수 있습니다.**


#### 7.4.1 CanExecute/Execute 패턴 사용하기

컨트롤러의 복잡도가 커지는 것을 완화하는 첫 번째 방법은  
**CanExecute/Execute 패턴**을 사용하는 것입니다.  
이 패턴은 도메인 모델의 비즈니스 로직이 컨트롤러로 **새어나가는 것을 막는 데** 유용합니다.

예제를 통해 살펴보겠습니다.

---

#### 📌 새로운 요구 사항

이제 사용자는 이메일을 **확정하기 전까지만 변경**할 수 있다고 가정해 봅시다.  
확정된 이후에는 이메일 변경을 시도할 경우, **오류 메시지를 보여줘야** 합니다.

이를 위해 `User` 클래스에 새로운 프로퍼티 `IsEmailConfirmed`를 추가합니다.

> 📄 **코드 목록 7.7**
> `User` 클래스에 프로퍼티 추가

```csharp
public class User
{
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }

    public bool IsEmailConfirmed { get; private set; }

    // ChangeEmail(newEmail, company) 메서드는 생략
}
```

이제 이 조건을 어디에 넣을지 선택할 수 있습니다. 두 가지 방식이 있습니다.

---

#### ✅ 첫 번째 방법: `User.ChangeEmail()` 안에 검사 로직 추가

이 방식은 **결정(판단)**을 `User` 클래스가 내리도록 하고,  
**컨트롤러는 결과에 따라 행동만 합니다.**

이 구조의 장점은 **결정 로직이 도메인에 집중**되어 있고,  
**컨트롤러는 단순한 액터 역할만** 한다는 것입니다.

단점은 성능 저하입니다. 이메일이 이미 확정되어 변경이 불가능한 상황에서도  
`Company` 객체를 **무조건 조회**하게 됩니다.

```csharp
public string ChangeEmail(string newEmail, Company company)
{
    if (IsEmailConfirmed)
        return "Can't change a confirmed email";

    // 나머지 이메일 변경 로직
}
```

> 📄 **코드 목록 7.8**
> **컨트롤러: 도메인 로직 결과에 따른 처리**

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);     //
    User user = UserFactory.Create(userData);              // Prepares
														   // the datta
    object[] companyData = _database.GetCompany();         //
    Company company = CompanyFactory.Create(companyData);  //

    string error = user.ChangeEmail(newEmail, company);    // Makes a decision
    
    if (error != null)                                     //
        return error;                                      //
                                                           // Acts on the
    _database.SaveCompany(company);                        // decision
    _database.SaveUser(user);                              //
    _messageBus.SendEmailChangedMessage(userId, newEmail); //

    return "OK";
}
```

> 💡 참고  
> 위 if문은 "행동 단계"에 속하기 때문에 복잡도를 증가시키는 분기문으로 간주하지 않습니다.  
> **실제 결정은 User 클래스에서 이루어지기 때문**입니다.

---

#### ❌ 두 번째 방법: `User.IsEmailConfirmed`를 컨트롤러에서 직접 검사

이 방식은 **성능은 유지되지만**, 컨트롤러가 **결정과 행동을 둘 다 담당**하게 됩니다.  
도메인 로직이 분리되지 않아 **책임이 중첩되고**,  
컨트롤러가 **복잡해지며 테스트가 어려운 방향**으로 가게 됩니다.

> 📄 **코드 목록 7.9**
> **컨트롤러가 직접 판단하는 구조**

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    if (user.IsEmailConfirmed)                    // Decision-making
        return "Can't change a confirmed email";  // moved here from User.

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    _messageBus.SendEmailChangedMessage(userId, newEmail);

    return "OK";
}
```

이 방식은 이메일을 변경할 수 있는지 확인하기 전에  
그냥 `ChangeEmail()`을 호출하는 등의 **우발적인 실수도 허용하게 되며**,  
**도메인 캡슐화가 깨질 위험**이 생깁니다.

---

#### ✅ 해결책: `CanExecute/Execute` 패턴 도입

이 문제를 해결하기 위해, `User` 클래스에 **`CanChangeEmail()`**이라는 메서드를 만들고,  
이 메서드의 실행이 **`ChangeEmail()` 호출 전의 전제 조건**이 되도록 합니다.

이렇게 하면 컨트롤러는 **"이메일을 변경할 수 있나?"만 물어보면 되고**,  
결정 로직은 모두 도메인에 남습니다.

> 📄 **코드 목록 7.10**
> **CanExecute/Execute 패턴 적용**

```csharp
public string CanChangeEmail()
{
    if (IsEmailConfirmed)
        return "Can't change a confirmed email";
    return null;
}

public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);
    // 이메일 변경 로직
}
```

이 방식의 장점은 다음과 같습니다:

1. **컨트롤러는 도메인 로직에 대해 아무것도 몰라도 됩니다.**  
   `CanChangeEmail()`만 호출해서 가능 여부만 확인하면 됩니다.  
   (이 메서드 안에는 여러 유효성 검사 로직이 숨겨져 있을 수 있습니다.)

2. `ChangeEmail()` 내부의 전제 조건 덕분에,  
   이메일을 **검증 없이 변경하는 상황이 절대 발생하지 않도록 보장**할 수 있습니다.

---

이 패턴은 **모든 결정(decision-making)을 도메인 레이어로 집중시켜**  
컨트롤러에 분기 로직이 생기지 않도록 막습니다.

컨트롤러에 여전히 `if (CanChangeEmail())` 같은 조건문이 있어도,  
**그 자체는 테스트할 필요가 없습니다.**  
해당 분기 로직은 **도메인에서 충분히 테스트 가능**하기 때문입니다.

> 💡 참고  
> 여기서는 간단하게 **string을 반환해 에러를 표현**했지만,  
> 실제 프로젝트에서는 `Result`와 같은 **전용 클래스를 만들어**  
> 성공/실패 여부를 더 명확하게 표현하는 것이 좋습니다.

#### 7.4.2 도메인 이벤트를 활용한 도메인 모델 변경 사항 추적

어떤 경로를 거쳐 도메인 모델이 현재 상태에 도달했는지를 파악하는 것은  
쉽지 않지만, 경우에 따라 **그 과정 자체를 외부 시스템에 알려야 할 필요**가 있습니다.  
이 책임을 컨트롤러에 맡기면 **컨트롤러가 복잡해지고 역할이 무거워집니다.**

이 문제를 해결하기 위해 도입할 수 있는 개념이 바로 **도메인 이벤트(Domain Event)**입니다.  
비즈니스 연산이 끝난 뒤 도메인에서 발생한 중요한 변경 사항을 추적하고,  
그것을 **외부 시스템과의 통신으로 전환**하는 방식입니다.

---

#### 📘 정의: 도메인 이벤트란?

> **도메인 이벤트**는 도메인 전문가에게 의미 있는 사건을 표현합니다.  
> 단순한 UI 이벤트(예: 버튼 클릭)와 달리,  
> **업무적으로 중요한 맥락을 담고 있는 것이 특징**입니다.

---

우리의 CRM 시스템에도 비슷한 요구사항이 있습니다:  
**사용자의 이메일이 변경되었을 때 외부 시스템에 메시지를 전송**해야 합니다.

그러나 현재 구현은 문제가 있습니다.  
**이메일이 실제로 변경되지 않았더라도 메시지를 무조건 전송**합니다.

> 📄 **코드 목록 7.11**
> **이메일이 변경되지 않아도 메시지를 전송하는 코드**

```csharp
// User
public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);
    if (Email == newEmail)
        return;
    // 나머지 변경 로직
}

// Controller
public string ChangeEmail(int userId, string newEmail)
{
    // 사전 처리 생략
    user.ChangeEmail(newEmail, company);
    _database.SaveCompany(company);
    _database.SaveUser(user);
    _messageBus.SendEmailChangedMessage(userId, newEmail);
    return "OK";
}
```

이 문제를 해결하기 위해 이메일 비교 로직을 컨트롤러로 옮길 수도 있지만,  
그렇게 하면 **비즈니스 로직이 분산**되어  
**도메인과 오케스트레이션의 분리가 깨지게 됩니다.**

또한 이 로직은 `CanChangeEmail()`에 포함시키기도 애매합니다.  
(같은 이메일을 입력한 경우 오류를 발생시키면 안 되기 때문입니다.)

이처럼 **도메인 모델에 외부 의존성을 넘기지 않으면서, 불필요한 호출을 막아야 할 때**  
**도메인 이벤트를 활용하는 것이 최적의 해결책**입니다.

---

#### 📌 도메인 이벤트 구현 방식

도메인 이벤트는 보통 **외부 시스템에 전달해야 할 데이터를 포함한 클래스**입니다.  
예: 이메일 변경 이벤트는 다음 정보를 포함합니다:

- 사용자 ID
- 새 이메일


> 📄 **EmailChangedEvent 클래스 예시**

```csharp
public class EmailChangedEvent
{
    public int UserId { get; }
    public string NewEmail { get; }

    public EmailChangedEvent(int userId, string newEmail)
    {
        UserId = userId;
        NewEmail = newEmail;
    }
}
```

> 💡 **도메인 이벤트 이름은 과거형(past tense)**으로 짓는 것이 일반적입니다.
> 이는 **이미 발생한 사건**을 나타내기 때문입니다.
> 도메인 이벤트는 **불변(immutable)**이며, 값 타입처럼 취급됩니다.

`User` 클래스는 이메일이 변경될 때마다  
이벤트를 수집하는 컬렉션에 `EmailChangedEvent`를 추가하게 됩니다:

> 📄 **코드 목록 7.12**
> **이메일 변경 시 이벤트 추가**

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);
    if (Email == newEmail)
        return;

    UserType newType = company.IsEmailCorporate(newEmail)
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);
    }

    Email = newEmail;
    Type = newType;

    EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));
}
```

이제 컨트롤러는 이 이벤트들을 **하나씩 메시지로 변환**하여 외부 시스템에 전송합니다:

> 📄 **코드 목록 7.13**
> **컨트롤러에서 도메인 이벤트 처리**

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    string error = user.CanChangeEmail();
    if (error != null)
        return error;

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);
    _database.SaveCompany(company);
    _database.SaveUser(user);

    foreach (var ev in user.EmailChangedEvents)
    {
        _messageBus.SendEmailChangedMessage(ev.UserId, ev.NewEmail);
    }

    return "OK";
}
```

여기서 중요한 점은 다음과 같습니다:

- `Company`와 `User`는 **이메일이 변경되지 않았더라도 항상 저장(persist)**됩니다.  
  → 하지만 이는 큰 문제가 되지 않습니다.

- **데이터베이스와의 통신은 구현 세부 사항**일 뿐이며,  
  **외부에 노출되는 메시지 전송**은 **CRM의 관측 가능한 행동**에 해당합니다.  
  따라서 메시지는 **이메일이 실제로 변경되었을 때만** 전송되어야 합니다.

- ORM을 사용하면 상태가 변경되지 않았을 경우  
  **데이터베이스와의 실제 라운드 트립을 피할 수 있으므로** 성능 손실도 적습니다.

---

#### 📦 도메인 이벤트 일반화

- `DomainEvent`라는 **기반 클래스(base class)**를 만들 수 있고,  
- 모든 도메인 클래스가 `List<DomainEvent>`를 통해 이벤트를 수집하도록 만들 수 있습니다.
- 컨트롤러에서 직접 처리하는 대신 **이벤트 디스패처(dispatcher)**를 만들 수도 있습니다.
- 대규모 프로젝트에서는 **이벤트 병합(merge)**이 필요할 수 있으며,  
  이에 대해서는 저자의 블로그 글 [“Merging domain events before dispatching”](http://mng.bz/YeVe)을 참고하세요.

---

이처럼 도메인 이벤트를 사용하면, **결정 책임을 컨트롤러에서 도메인 모델로 옮길 수 있고**,  
외부 시스템과의 통신을 테스트할 때도 **모의 객체(mock) 없이 도메인 이벤트 생성만 검증**하면 됩니다.

> 📄 **코드 목록 7.14**
> **도메인 이벤트 생성에 대한 단위 테스트**

```csharp
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    var company = new Company("mycorp.com", 1);
    var sut = new User(1, "user@mycorp.com", UserType.Employee, false);

    sut.ChangeEmail("new@gmail.com", company);

    company.NumberOfEmployees.Should().Be(0);
    sut.Email.Should().Be("new@gmail.com");
    sut.Type.Should().Be(UserType.Customer);

    sut.EmailChangedEvents.Should().Equal(
        new EmailChangedEvent(1, "new@gmail.com"));
}
```

이 테스트는 다음을 **동시에 검증**합니다:

- 도메인 상태 변경 (`Email`, `Type`, `NumberOfEmployees`)
- 도메인 이벤트가 정확히 하나 생성되었는지, 그리고 그 내용이 올바른지

---

물론, 컨트롤러도 여전히 **오케스트레이션을 잘 수행하는지에 대한 테스트**가 필요합니다.  
하지만 이제 그 테스트는 **작고 간결한 범위 내에서 작성**하면 됩니다.  
이에 대해서는 다음 장에서 자세히 다룹니다.

## 7.5 결론

이번 장 전체에 걸쳐 반복되어 나타난 하나의 주제를 떠올려 보세요:  
**외부 시스템에 대한 부작용의 적용을 추상화하는 것**입니다.  

이러한 추상화는 **비즈니스 작업이 끝날 때까지 부작용을 메모리 내에 유지**함으로써 달성됩니다.  
이렇게 하면 **프로세스 외부의 의존성을 포함하지 않고도** 평범한 단위 테스트로 검증할 수 있습니다.

**도메인 이벤트는 메시지 버스에 보낼 예정인 메시지에 대한 추상화**이며,  
**도메인 클래스의 변경은 데이터베이스에 예정된 수정에 대한 추상화**입니다.

> 💡 참고: **추상화를 테스트하는 것이, 추상화된 대상 자체를 테스트하는 것보다 더 쉽습니다.**

우리는 **도메인 이벤트와 CanExecute/Execute 패턴**의 도움을 받아  
모든 의사결정을 도메인 모델 안에 성공적으로 가둘 수 있었습니다.  
하지만 항상 그렇게 할 수 있는 것은 아닙니다.  
비즈니스 로직의 **분할(fragmentation)** 이 불가피한 상황도 존재합니다.

예를 들어, **이메일의 유일성 검증**을 컨트롤러 외부에서 수행하는 것은  
도메인 모델 안에 **프로세스 외부 의존성**을 도입하지 않고는 불가능합니다.  

또 다른 예로는, 비즈니스 작업의 흐름을 변경해야 하는 **외부 시스템 호출의 실패 상황**이 있습니다.  
이런 경우, 어떤 경로로 진행할지를 결정하는 로직은 도메인 계층에 있을 수 없습니다.  
왜냐하면 **그 외부 시스템 호출을 수행하는 주체는 도메인 계층이 아니기 때문**입니다.  

이러한 로직은 **컨트롤러에 넣고, 통합 테스트로 커버**해야 합니다.  
그럼에도 불구하고, **비즈니스 로직과 오케스트레이션을 분리하는 것**에는  
큰 가치가 있습니다.  
이러한 분리는 **단위 테스트 과정을 획기적으로 단순화**시켜주기 때문입니다.

---

컨트롤러에 일부 비즈니스 로직이 들어가는 것을 완전히 피할 수 없듯이,  
도메인 클래스에서 **모든 협력자**를 제거하는 것도 거의 불가능합니다.  
하지만 그것은 괜찮습니다.  
**1명, 2명, 또는 3명의 협력자 정도**는 도메인 클래스를  
과도하게 복잡한 코드로 만들지 않습니다.  
단, **이 협력자들이 프로세스 외부의 의존성을 참조하지 않는 경우에 한해서**입니다.

다만, **이런 협력자들과의 상호작용을 검증하기 위해 목(mock)을 사용하는 일은 피하세요.**  
이런 상호작용은 도메인 모델의 **관찰 가능한 행위(observable behavior)** 와 무관하기 때문입니다.

컨트롤러에서 도메인 클래스로의 **맨 처음 호출**만이  
컨트롤러의 목적과 직접적인 연관을 갖습니다.  
도메인 클래스가 **그 안에서 다른 도메인 클래스들에 대해 수행하는 모든 후속 호출**은  
모두 **구현 세부사항**입니다.

---

Figure 7.13은 이러한 개념을 보여줍니다.  
해당 그림은 **CRM 내 구성 요소들 간의 통신**과  
이 통신들이 **관찰 가능한 행위와 맺는 관계**를 나타냅니다.  

5장에서 설명했듯이, **메서드가 클래스의 관찰 가능한 행위인지 여부**는  
**클라이언트가 누구인지**, 그리고 **그 클라이언트의 목적이 무엇인지**에 달려 있습니다.  
어떤 메서드가 관찰 가능한 행위에 속하려면, 다음 두 가지 조건 중 **하나 이상**을 충족해야 합니다:

- 클라이언트의 목적 중 **하나와 즉각적인 연결**이 있어야 한다.  
- **프로세스 외부의 의존성에 부작용을 일으켜**, 외부 애플리케이션이 이를 **관찰 가능하게** 해야 한다.

컨트롤러의 `ChangeEmail()` 메서드는 **그 자체로 관찰 가능한 행위에 속하며**,  
**메시지 버스로의 호출 또한 그렇습니다**.  
첫 번째 메서드는 **외부 클라이언트의 진입점(entry point)** 으로써 첫 번째 기준을 만족합니다.  
버스로의 호출은 **외부 애플리케이션에 메시지를 전송**하기 때문에 두 번째 기준을 만족합니다.

따라서, **이 두 메서드 호출을 모두 검증**해야 합니다  
(이 내용은 다음 장에서 다룰 것입니다).

그러나 컨트롤러에서 `User`로의 후속 호출은  
**외부 클라이언트의 목적과 직접적인 연결이 없습니다**.  
외부 클라이언트는 **이메일 변경을 컨트롤러가 어떻게 수행하는지**에는 관심이 없으며,  
**최종 상태가 올바르고**, **메시지 버스로의 호출이 수행되었는지**에만 관심이 있습니다.  

따라서, **컨트롤러의 행동을 테스트할 때**,  
컨트롤러가 `User`에게 무엇을 호출했는지를 검증해서는 안 됩니다.

---

호출 스택에서 한 단계 아래로 내려가 보면 비슷한 상황이 나타납니다.  
이제는 **컨트롤러가 클라이언트**이며,  
`User`의 `ChangeEmail` 메서드는 그 클라이언트의 목적,  
즉 **이메일을 변경하는 것**과 직접 연결되어 있으므로 **테스트 대상**입니다.  

하지만, `User`가 `Company`에 대해 수행하는 **후속 호출**은  
컨트롤러 관점에서는 **구현 세부사항**에 불과합니다.  
따라서 `User`의 `ChangeEmail` 메서드를 테스트할 때는,  
`User`가 `Company`에서 어떤 메서드를 호출하는지 **검증해서는 안 됩니다**.

이와 같은 논리는 호출 스택에서 한 단계 더 내려가,  
`Company`의 두 메서드를 `User` 관점에서 테스트할 때도 그대로 적용됩니다.

---

**관찰 가능한 행위와 구현 세부사항**을 **양파 껍질처럼 겹겹이 존재하는 층**으로 생각하세요.  
**각 계층을 그 바깥 계층의 관점**에서 테스트하고,  
그 계층이 내부 계층과 어떻게 통신하는지는 **무시**하세요.  

이 계층들을 하나씩 벗겨나가면서, **관점을 전환**하게 됩니다:  
이전에는 구현 세부사항이었던 것이,  
이제는 관찰 가능한 행위가 되어 **새로운 테스트 대상**이 됩니다.

---

![[스크린샷 2025-06-24 19.12.11.png]]

**Figure 7.13**: CRM 내 구성 요소들 간의 통신과,  
그 통신이 관찰 가능한 행위와 맺는 관계를 나타낸 도식

## 요약

- 코드 복잡도는 코드 자체가 내리는 명시적인 결정과, 코드가 사용하는 라이브러리가 내리는 암묵적인 결정을 포함한, 코드 내의 의사결정 지점의 수로 정의된다.

- 도메인 중요성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 중요한지를 보여준다. 복잡한 코드는 종종 도메인 중요성이 높지만, 항상 그런 것은 아니다.

- 복잡하거나 도메인 중요성이 높은 코드는 단위 테스트로부터 가장 큰 이득을 본다. 해당 테스트는 리그레션에 대한 더 강한 보호를 제공하기 때문이다.

- 협력자가 많은 코드를 다루는 단위 테스트는 높은 유지 비용을 가진다. 이러한 테스트는 협력자들을 기대한 상태로 만들고, 이후 상태나 상호작용을 확인하기 위해 많은 공간이 필요하다.

- 모든 프로덕션 코드는 복잡도나 도메인 중요성과 협력자 수에 따라 네 가지 유형의 코드로 분류할 수 있다:
  - **도메인 모델과 알고리즘**(높은 복잡도 또는 도메인 중요성, 적은 협력자 수): 단위 테스트에 대한 투자 대비 최고의 수익을 제공한다.
  - **사소한 코드**(낮은 복잡도 및 도메인 중요성, 적은 협력자 수): 테스트할 가치가 없다.
  - **컨트롤러**(낮은 복잡도 및 도메인 중요성, 많은 협력자 수): 간단한 통합 테스트로 테스트되어야 한다.
  - **과도하게 복잡한 코드**(높은 복잡도 또는 도메인 중요성, 많은 협력자 수): 컨트롤러와 복잡한 코드로 분리되어야 한다.

- 코드가 중요하거나 복잡할수록 협력자 수는 적어야 한다.

- Humble Object 패턴은 비즈니스 로직을 별도의 클래스로 추출함으로써 과도하게 복잡한 코드를 테스트 가능하게 만든다. 결과적으로 남는 코드는 비즈니스 로직을 둘러싼 얇고 겸손한 래퍼인 컨트롤러가 된다.

- 헥사고날 아키텍처와 함수형 아키텍처는 Humble Object 패턴을 구현한다. 헥사고날 아키텍처는 비즈니스 로직과 외부 시스템과의 통신을 분리한다. 함수형 아키텍처는 비즈니스 로직과 모든 협력자와의 통신을 분리한다.

- 비즈니스 로직과 오케스트레이션 책임을 코드 깊이와 코드 너비라는 관점에서 생각하라. 코드는 깊을 수는 있고(복잡하거나 중요), 넓을 수는 있지만(많은 협력자와 작동), **동시에 둘 다여서는 안 된다.**

- 도메인적으로 중요한 전제 조건이라면 테스트하라. 그렇지 않다면 테스트하지 마라.

- 비즈니스 로직과 오케스트레이션을 분리할 때 중요한 세 가지 속성이 있다:
  - 도메인 모델 테스트 가능성 — 도메인 클래스 내 협력자의 수와 종류에 따라 결정된다.
  - 컨트롤러 단순성 — 컨트롤러 내 의사결정 지점의 존재에 따라 달라진다.
  - 성능 — 외부 시스템에 대한 호출 횟수에 의해 정의된다.

- 한 번에 이 세 가지 속성 중 두 가지만 가질 수 있다:
  - 외부 읽기/쓰기를 비즈니스 연산의 끝으로 미루기 — 컨트롤러 단순성과 도메인 모델 테스트 가능성을 유지하지만 성능을 포기함
  - 외부 의존성을 도메인 모델에 주입하기 — 성능과 컨트롤러 단순성은 유지되지만 도메인 모델 테스트 가능성을 훼손함
  - 의사결정 과정을 더 세분화된 단계로 나누기 — 성능과 도메인 모델 테스트 가능성은 유지되지만 컨트롤러 단순성을 포기함

- 의사결정 과정을 더 세분화된 단계로 나누기 — 장점과 단점의 조합 중 가장 좋은 트레이드오프다. 다음 두 가지 패턴을 통해 컨트롤러 복잡도 증가를 완화할 수 있다:
  - CanExecute/Execute 패턴은 각 Do() 메서드에 대해 CanDo()를 도입하고, 그 실행 성공을 Do()의 전제 조건으로 만든다. 이 패턴은 본질적으로 컨트롤러의 의사결정을 제거한다. 왜냐하면 CanDo()를 Do() 전에 호출하지 않을 수 없게 되기 때문이다.
  - 도메인 이벤트는 도메인 모델에서의 중요한 변경을 추적하고, 이러한 변경을 외부 시스템 호출로 변환하는 데 도움을 준다. 이 패턴은 추적 책임을 컨트롤러에서 제거한다.

- **추상화는 그것이 추상화하는 대상을 테스트하는 것보다 더 쉽다.**  
  도메인 이벤트는 향후 외부 시스템 호출에 대한 추상화다.  
  도메인 클래스의 변경은 향후 데이터 저장소에 대한 수정에 대한 추상화다.
