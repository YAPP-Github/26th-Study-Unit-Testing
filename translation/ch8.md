-----

## 8장 통합 테스트는 왜 필요한가?

단위 테스트를 충분히 활용하여 견고한 코드베이스를 구축했다면, 통합 테스트가 왜 필요한지 의아할 수 있습니다. 8장 '통합 테스트는 왜 필요한가?'는 이러한 질문에 대한 답을 제공하며, 단위 테스트만으로는 포착하기 어려운 문제들을 통합 테스트가 어떻게 해결하는지 설명합니다.

### 이 장에서 다루는 내용:

  * 통합 테스트의 역할 이해하기
  * 테스트 피라미드 개념 심층 탐구하기
  * 가치 있는 통합 테스트 작성하기

단위 테스트에만 전적으로 의존한다면 시스템 전체가 제대로 작동하는지 확신할 수 없습니다. 단위 테스트는 비즈니스 로직을 검증하는 데는 훌륭하지만, 이 로직이 고립된 상태에서만 작동하는지 확인하는 것만으로는 충분하지 않습니다. 다양한 부분이 서로 그리고 외부 시스템(데이터베이스, 메시지 버스 등)과 어떻게 통합되는지 검증해야 합니다.

이 장에서는 통합 테스트의 역할, 즉 언제 통합 테스트를 적용해야 하고 언제 일반 단위 테스트 또는 Fail Fast 원칙과 같은 다른 기술에 의존하는 것이 더 나은지 배웁니다. 통합 테스트에서 어떤 프로세스 외부 종속성을 있는 그대로 사용하고 어떤 것을 모의(mock)로 대체해야 하는지 알아봅니다. 또한 도메인 모델 경계를 명시적으로 만들고, 애플리케이션의 계층 수를 줄이며, 순환 종속성을 제거하는 등 코드베이스의 전반적인 상태를 개선하는 데 도움이 되는 통합 테스트 모범 사례를 살펴봅니다. 마지막으로, 단일 구현을 가진 인터페이스를 간헐적으로 사용해야 하는 이유와 로깅 기능을 어떻게, 언제 테스트해야 하는지 배웁니다.

-----

### 8.1 통합 테스트란 무엇인가?

통합 테스트는 테스트 스위트에서 중요한 역할을 합니다. 또한 단위 테스트와 통합 테스트의 수를 균형 있게 유지하는 것도 중요합니다. 곧 그 역할이 무엇인지, 그리고 어떻게 균형을 유지하는지 살펴보겠지만, 먼저 통합 테스트가 단위 테스트와 무엇이 다른지 다시 한번 짚어보겠습니다.

#### 8.1.1 통합 테스트의 역할

2장에서 기억하시겠지만, 단위 테스트는 다음 세 가지 요구 사항을 충족하는 테스트입니다:

  * 단일 동작 단위를 검증한다.
  * 빠르게 수행한다.
  * 다른 테스트와 격리하여 수행한다.

이 세 가지 요구 사항 중 적어도 하나를 충족하지 못하는 테스트는 통합 테스트 범주에 속합니다. 따라서 **통합 테스트는 단위 테스트가 아닌 모든 테스트**입니다.

실제로 통합 테스트는 거의 항상 시스템이 프로세스 외부 종속성과 통합되어 어떻게 작동하는지 검증합니다. 다시 말해, 이러한 테스트는 컨트롤러 사분면의 코드(코드 사분면에 대한 자세한 내용은 7장 참조)를 다룹니다. 그림 8.1의 다이어그램은 단위 테스트와 통합 테스트의 일반적인 책임을 보여줍니다. 단위 테스트는 도메인 모델을 다루는 반면, 통합 테스트는 해당 도메인 모델을 프로세스 외부 종속성과 연결하는 코드를 확인합니다.

```
아, 텍스트로 도식화한 것이 예상과 다르게 보여서 "깨진다"고 느끼셨군요. 죄송합니다.

텍스트 기반의 ASCII 아트는 글꼴, 터미널 환경, 줄 바꿈 방식 등에 따라 다르게 보일 수 있습니다. 좀 더 명확하게 보이도록 ┌, ─, ┬, │, └, ┴, ┘ 같은 박스 그리기 문자를 사용하여 다시 시도해 보겠습니다. 그리고 각 섹션의 내용을 더 명확히 분리하여 배치하겠습니다.

▲
│   (복잡성, 도메인 중요성)
│   Complexity, domain significance
│
┌───────────────────────────┬───────────────────────────┐
│        Unit tests         │                           │
│                           │                           │
│  ┌────────────────────┐   │  ┌────────────────────┐   │
│  │ Domain model,      │   │  │ Overcomplicated    │   │
│  │ algorithms         │   │  │ code               │   │
│  │ (단위 테스트)        │   │  │                    │   │
│  └────────────────────┘   │  └────────────────────┘   │
├───────────────────────────┼───────────────────────────┤
│                           │        Integration tests  │
│                           │                           │
│  ┌────────────────────┐   │  ┌────────────────────┐   │
│  │ Trivial code       │   │  │ Controllers        │   │
│  │ (사소한 코드)        │   │  │ (통합 테스트)        │   │
│  └────────────────────┘   │  └────────────────────┘   │
└───────────────────────────┴───────────────────────────┘
▶ (협력자 수) Number of collaborators
```

**그림 8.1** 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 도메인 모델과 알고리즘을 다룹니다. 사소하고 지나치게 복잡한 코드는 전혀 테스트해서는 안 됩니다.

컨트롤러 사분면을 다루는 테스트도 때로는 단위 테스트일 수 있다는 점에 유의하십시오. 모든 프로세스 외부 종속성이 모의로 대체되면 테스트 간에 공유되는 종속성이 없으므로 테스트가 빠르고 서로 격리된 상태를 유지할 수 있습니다. 그러나 대부분의 애플리케이션에는 모의로 대체할 수 없는 프로세스 외부 종속성(일반적으로 다른 애플리케이션에는 보이지 않는 데이터베이스)이 있습니다.

7장에서 기억하시겠지만, 그림 8.1의 다른 두 사분면(사소한 코드와 지나치게 복잡한 코드)은 전혀 테스트해서는 안 됩니다. 사소한 코드는 노력할 가치가 없으며, 지나치게 복잡한 코드는 알고리즘과 컨트롤러로 리팩토링되어야 합니다. 따라서 모든 테스트는 도메인 모델과 컨트롤러 사분면에만 집중해야 합니다.

#### 8.1.2 테스트 피라미드 재검토

단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요합니다. 프로세스 외부 종속성과 직접 작업하면 통합 테스트가 느려집니다. 또한 이러한 테스트는 유지 관리 비용도 더 많이 듭니다. 유지 관리 비용 증가는 다음으로 인해 발생합니다:

  * 프로세스 외부 종속성을 계속 작동시켜야 할 필요성
  * 더 많은 협력자가 참여하여 테스트 크기가 커지는 것

반면에 통합 테스트는 더 많은 양의 코드(자신이 작성한 코드와 애플리케이션에서 사용하는 라이브러리 코드 모두)를 통과하므로 회귀로부터 보호하는 데 단위 테스트보다 더 좋습니다. 또한 프로덕션 코드와 더 분리되어 있으므로 리팩토링에 대한 저항력이 더 강합니다.

단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 일반적인 **경험 법칙**은 다음과 같습니다: **비즈니스 시나리오의 엣지 케이스를 가능한 한 많이 단위 테스트로 확인하고, 통합 테스트는 하나의 해피 경로와 단위 테스트로 커버할 수 없는 모든 엣지 케이스를 다루는 데 사용하십시오.**

**정의** **해피 경로**는 비즈니스 시나리오의 성공적인 실행입니다. **엣지 케이스**는 비즈니스 시나리오 실행이 오류를 발생시키는 경우입니다.

대부분의 작업을 단위 테스트로 전환하면 유지 관리 비용을 낮게 유지하는 데 도움이 됩니다. 동시에 비즈니스 시나리오당 하나 또는 두 개의 포괄적인 통합 테스트를 통해 시스템 전체의 정확성을 보장합니다. 이 가이드라인은 그림 8.2에 표시된 단위 테스트와 통합 테스트 간의 피라미드 형태의 비율을 형성합니다(2장에서 논의했듯이 엔드투엔드 테스트는 통합 테스트의 하위 집합입니다).

```
                      엔드투엔드
                    (회귀 방지,
                  리팩토링 저항)
                        ▲
                        │
                        │
                  통합 테스트
                        │
                        │
                        ▼
                    단위 테스트
                  (빠른 피드백,
                  유지 관리성)

                      테스트 수
```

**그림 8.2** 테스트 피라미드는 대부분의 애플리케이션에 가장 적합한 트레이드오프를 나타냅니다. 빠르고 저렴한 단위 테스트는 대부분의 엣지 케이스를 다루고, 더 적은 수의 느리고 비용이 많이 드는 통합 테스트는 시스템 전체의 정확성을 보장합니다.

테스트 피라미드는 프로젝트의 복잡성에 따라 다른 모양을 가질 수 있습니다. 간단한 애플리케이션은 도메인 모델 및 알고리즘 사분면에 코드가 거의(또는 전혀) 없습니다. 결과적으로 테스트는 피라미드가 아닌 직사각형을 형성하며, 단위 테스트와 통합 테스트의 수가 동일합니다(그림 8.3). 가장 사소한 경우에는 단위 테스트가 전혀 없을 수도 있습니다.

```
                      통합 테스트
                        │
                        │
                        ▼
                    단위 테스트
```

**그림 8.3** 간단한 프로젝트의 테스트 피라미드. 복잡성이 낮으면 일반 피라미드에 비해 단위 테스트 수가 더 적게 필요합니다.

통합 테스트는 간단한 애플리케이션에서도 그 가치를 유지합니다. 코드가 아무리 간단하더라도 다른 하위 시스템과의 통합에서 어떻게 작동하는지 검증하는 것이 여전히 중요합니다.

#### 8.1.3 통합 테스트 vs. Fail Fast

이 섹션에서는 비즈니스 시나리오당 하나의 해피 경로와 단위 테스트로 커버할 수 없는 모든 엣지 케이스를 다루기 위해 통합 테스트를 사용한다는 가이드라인을 자세히 설명합니다.

통합 테스트의 경우, 모든 프로세스 외부 종속성과의 상호 작용을 검증하기 위해 **가장 긴 해피 경로**를 선택하십시오. 모든 상호 작용을 통과하는 단일 경로가 없다면, 모든 외부 시스템과의 통신을 캡처하는 데 필요한 만큼 추가 통합 테스트를 작성하십시오.

단위 테스트로 커버할 수 없는 엣지 케이스와 마찬가지로, 이 가이드라인의 이 부분에도 예외가 있습니다. 해당 엣지 케이스의 잘못된 실행이 전체 애플리케이션을 즉시 실패시키는 경우에는 엣지 케이스를 테스트할 필요가 없습니다. 예를 들어, 7장에서 샘플 CRM 시스템의 User가 `CanChangeEmail` 메서드를 구현하고 `ChangeEmail()`의 전제 조건으로 해당 메서드의 성공적인 실행을 어떻게 만들었는지 보았습니다.

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);
    /* the rest of the method */
}
```

컨트롤러는 `CanChangeEmail()`을 호출하고 해당 메서드가 오류를 반환하면 작업을 중단합니다:

```csharp
// UserController
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);
    string error = user.CanChangeEmail();
    if (error != null)
        return error; // 엣지 케이스
    /* the rest of the method */
}
```

이 예제는 통합 테스트로 이론적으로 커버할 수 있는 엣지 케이스를 보여줍니다. 그러나 이러한 테스트는 충분히 중요한 가치를 제공하지 않습니다. 컨트롤러가 `CanChangeEmail()`을 먼저 참조하지 않고 이메일을 변경하려고 하면 애플리케이션이 충돌합니다. 이 버그는 첫 번째 실행에서 나타나므로 쉽게 발견하고 수정할 수 있습니다. 또한 데이터 손상으로 이어지지도 않습니다.

**팁** 나쁜 테스트를 작성하느니 차라리 테스트를 전혀 작성하지 않는 것이 낫습니다. 중요한 가치를 제공하지 않는 테스트는 나쁜 테스트입니다.

컨트롤러에서 `CanChangeEmail()`을 호출하는 것과 달리, User에 전제 조건이 존재한다는 것은 테스트해야 합니다. 하지만 이것은 단위 테스트로 더 잘 수행되며, 통합 테스트가 필요하지 않습니다.

버그가 빠르게 드러나도록 하는 것을 **Fail Fast 원칙**이라고 하며, 이는 통합 테스트에 대한 실행 가능한 대안입니다.

-----

**Fail Fast 원칙**

Fail Fast 원칙은 예상치 못한 오류가 발생하는 즉시 현재 작업을 중단하는 것을 의미합니다. 이 원칙은 다음을 통해 애플리케이션을 더 안정적으로 만듭니다:

  * **피드백 루프 단축** – 버그를 일찍 발견할수록 수정하기가 더 쉽습니다. 프로덕션에 이미 있는 버그는 개발 중에 발견된 버그보다 수정 비용이 몇 배 더 많이 듭니다.
  * **지속성 상태 보호** – 버그는 애플리케이션 상태를 손상시킵니다. 일단 그 상태가 데이터베이스에 침투하면 수정하기가 훨씬 더 어려워집니다. Fail Fast는 손상이 확산되는 것을 방지하는 데 도움이 됩니다.

(계속)

현재 작업을 중단하는 것은 일반적으로 예외를 던지는 방식으로 이루어집니다. 왜냐하면 예외는 Fail Fast 원칙에 완벽하게 적합한 의미론을 가지고 있기 때문입니다: 예외는 프로그램 흐름을 중단하고 실행 스택의 가장 높은 수준으로 팝업되어, 거기서 로그를 기록하고 작업을 종료하거나 다시 시작할 수 있습니다.

전제 조건은 Fail Fast 원칙이 작동하는 한 가지 예입니다. 실패하는 전제 조건은 애플리케이션 상태에 대해 잘못된 가정을 했다는 것을 의미하며, 이는 항상 버그입니다. 또 다른 예는 구성 파일에서 데이터를 읽는 것입니다. 구성 파일의 데이터가 불완전하거나 올바르지 않은 경우 예외를 던지도록 읽기 로직을 정렬할 수 있습니다. 또한 이 로직을 애플리케이션 시작 시점에 가깝게 배치하여 구성에 문제가 있는 경우 애플리케이션이 시작되지 않도록 할 수 있습니다.

-----

### 8.2 어떤 프로세스 외부 종속성을 직접 테스트해야 하는가?

앞서 언급했듯이, 통합 테스트는 시스템이 프로세스 외부 종속성과 어떻게 통합되는지 검증합니다. 이러한 검증을 구현하는 두 가지 방법이 있습니다: 실제 프로세스 외부 종속성을 사용하거나, 해당 종속성을 모의(mock)로 대체하는 것입니다. 이 섹션에서는 두 가지 접근 방식을 언제 적용해야 하는지 보여줍니다.

#### 8.2.1 두 가지 유형의 프로세스 외부 종속성

모든 프로세스 외부 종속성은 두 가지 범주로 나뉩니다:

  * **관리되는 종속성 (완전히 제어할 수 있는 프로세스 외부 종속성)** — 이러한 종속성은 애플리케이션을 통해서만 액세스할 수 있습니다. 이들과의 상호 작용은 외부 세계에 보이지 않습니다. 일반적인 예는 데이터베이스입니다. 외부 시스템은 일반적으로 데이터베이스에 직접 액세스하지 않고, 애플리케이션이 제공하는 API를 통해 액세스합니다.
  * **관리되지 않는 종속성 (완전히 제어할 수 없는 프로세스 외부 종속성)** — 이러한 종속성과의 상호 작용은 외부에서 관찰할 수 있습니다. SMTP 서버와 메시지 버스가 예시입니다. 둘 다 다른 애플리케이션에 보이는 부작용을 생성합니다.

5장에서 관리되는 종속성과의 통신은 구현 세부 사항이라고 언급했습니다. 반대로, 관리되지 않는 종속성과의 통신은 시스템의 관찰 가능한 동작의 일부입니다(그림 8.4). 이러한 구별은 통합 테스트에서 프로세스 외부 종속성을 다루는 방식의 차이로 이어집니다.

**중요** 관리되는 종속성의 실제 인스턴스를 사용하고, 관리되지 않는 종속성은 모의로 대체하십시오.

```
+----------------+       +-------------------+
| Third-party    |       | Application       |
| system         |       | database          |
| (external      |       | (managed          |
| client)        |       | dependency)       |
+----------------+       +-------------------+
        ▲                      ▲
        │                      │
        │ 구현 세부 사항         │
        ▼                      ▼
+----------------+       +-------------------+
| SMTP service   |       | Your application  |
| (unmanaged     |       |                   |
| dependency)    |       |                   |
+----------------+       +-------------------+
Observable behavior (contract)
```

**그림 8.4** 관리되는 종속성과의 통신은 구현 세부 사항입니다. 통합 테스트에서 이러한 종속성을 있는 그대로 사용하십시오. 관리되지 않는 종속성과의 통신은 시스템의 관찰 가능한 동작의 일부입니다. 이러한 종속성은 모의 처리되어야 합니다.

5장에서 논의했듯이, 관리되지 않는 종속성과의 통신 패턴을 보존해야 하는 요구 사항은 이러한 종속성과의 역방향 호환성을 유지해야 할 필요성에서 비롯됩니다. 모의는 이 작업을 수행하는 데 완벽합니다. 모의를 사용하면 모든 가능한 리팩토링에도 불구하고 통신 패턴의 영속성을 보장할 수 있습니다.

그러나 관리되는 종속성과의 통신에서는 역방향 호환성을 유지할 필요가 없습니다. 왜냐하면 애플리케이션만이 그들과 통신하기 때문입니다. 외부 클라이언트는 데이터베이스를 어떻게 구성하는지 신경 쓰지 않습니다. 중요한 것은 시스템의 최종 상태뿐입니다. 통합 테스트에서 관리되는 종속성의 실제 인스턴스를 사용하면 외부 클라이언트의 관점에서 해당 최종 상태를 검증하는 데 도움이 됩니다. 또한 컬럼 이름 변경이나 한 데이터베이스에서 다른 데이터베이스로 마이그레이션과 같은 데이터베이스 리팩토링 중에도 도움이 됩니다.

#### 8.2.2 관리되는 종속성과 관리되지 않는 종속성 모두와 작업하기

때로는 관리되는 종속성과 관리되지 않는 종속성 모두의 속성을 나타내는 프로세스 외부 종속성을 만나게 될 것입니다. 좋은 예는 다른 애플리케이션도 액세스할 수 있는 데이터베이스입니다.

이야기는 보통 이렇습니다. 시스템은 자체 전용 데이터베이스로 시작합니다. 얼마 후, 다른 시스템이 같은 데이터베이스에서 데이터를 필요로 하기 시작합니다. 그래서 팀은 다른 시스템과의 통합을 용이하게 하기 위해 제한된 수의 테이블에 대한 액세스를 공유하기로 결정합니다. 결과적으로 데이터베이스는 관리되는 종속성과 관리되지 않는 종속성 모두가 됩니다. 여전히 애플리케이션에만 보이는 부분을 포함하지만, 그 외에도 다른 애플리케이션이 액세스할 수 있는 많은 테이블도 있습니다.

데이터베이스를 사용하는 것은 시스템 간 통합을 구현하는 좋지 않은 방법입니다. 왜냐하면 이러한 시스템을 서로 **결합**시키고 추가 개발을 복잡하게 만들기 때문입니다. 다른 모든 옵션이 소진되었을 때만 이 접근 방식을 사용하십시오. 통합을 수행하는 더 나은 방법은 API(동기 통신용) 또는 메시지 버스(비동기 통신용)를 통한 것입니다.

하지만 공유 데이터베이스가 이미 있고 가까운 미래에 아무것도 할 수 없다면 어떻게 해야 할까요? 이 경우, 다른 애플리케이션에 보이는 테이블을 관리되지 않는 종속성으로 취급하십시오. 이러한 테이블은 사실상 메시지 버스 역할을 하며, 해당 행은 메시지 역할을 합니다. 모의를 사용하여 이러한 테이블과의 통신 패턴이 변경되지 않는지 확인하십시오. 동시에 데이터베이스의 나머지 부분을 관리되는 종속성으로 취급하고, 그와의 상호 작용이 아닌 최종 상태를 검증하십시오(그림 8.5).

```
+--------------------+
| External applications |
+--------------------+
          ▲
          │
          │ Replace with mocks
          ▼
+--------------------+
| Unmanaged part     |
| (Table, Table)     |
+--------------------+
          ▲
          │
          │ Test directly
          ▼
+--------------------+
| Managed part       |
| (Table, Table,     |
| Table, Table)      |
+--------------------+
          ▲
          │
          │
          ▼
+--------------------+
| Your application   |
+--------------------+
```

**그림 8.5** 외부 애플리케이션에 보이는 데이터베이스의 일부를 관리되지 않는 종속성으로 취급하십시오. 통합 테스트에서 모의로 대체하십시오. 데이터베이스의 나머지 부분을 관리되는 종속성으로 취급하십시오. 그와의 상호 작용이 아닌 최종 상태를 검증하십시오.

이러한 데이터베이스의 두 부분을 구분하는 것이 중요합니다. 왜냐하면 공유 테이블은 외부에서 관찰 가능하며, 애플리케이션이 그들과 어떻게 통신하는지에 대해 주의해야 하기 때문입니다. 절대적으로 필요한 경우가 아니라면 시스템이 해당 테이블과 상호 작용하는 방식을 변경하지 마십시오\! 다른 애플리케이션이 그러한 변경에 어떻게 반응할지 알 수 없습니다.

#### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없다면?

때로는 통제할 수 없는 이유로 통합 테스트에서 관리되는 종속성의 실제 버전을 사용할 수 없을 때가 있습니다. 예를 들어, IT 보안 정책 때문에 테스트 자동화 환경은 물론 개발자 컴퓨터에도 배포할 수 없는 레거시 데이터베이스이거나, 테스트 데이터베이스 인스턴스를 설정하고 유지 관리하는 비용이 너무 많이 들기 때문일 수 있습니다.

이런 상황에서는 어떻게 해야 할까요? 관리되는 종속성임에도 불구하고 데이터베이스를 모의 처리해야 할까요? 아닙니다. 왜냐하면 관리되는 종속성을 모의 처리하는 것은 통합 테스트의 리팩토링 저항성을 손상시키기 때문입니다. 더 나아가, 그러한 테스트는 더 이상 회귀에 대한 좋은 보호를 제공하지 않습니다. 그리고 데이터베이스가 프로젝트에서 유일한 프로세스 외부 종속성이라면, 결과적인 통합 테스트는 기존 단위 테스트 세트(이 단위 테스트가 7장의 가이드라인을 따른다고 가정할 때)에 비해 추가적인 보호를 제공하지 않을 것입니다.

그러한 통합 테스트가 단위 테스트 외에 하는 유일한 일은 컨트롤러가 어떤 저장소 메서드를 호출하는지 확인하는 것입니다. 즉, 컨트롤러의 세 줄짜리 코드가 올바르다는 것 외에는 아무것도 확신할 수 없으면서도 여전히 많은 준비 작업을 해야 합니다.

데이터베이스를 있는 그대로 테스트할 수 없다면 **통합 테스트를 전혀 작성하지 말고, 대신 도메인 모델의 단위 테스트에만 집중하십시오.** 항상 모든 테스트를 면밀히 조사해야 한다는 것을 기억하십시오. 충분히 높은 가치를 제공하지 않는 테스트는 테스트 스위트에 포함될 자격이 없습니다.

-----

### 8.3 통합 테스트: 예시

7장의 샘플 CRM 시스템으로 돌아가서 통합 테스트로 어떻게 커버할 수 있는지 살펴보겠습니다. 기억하시겠지만, 이 시스템은 사용자 이메일 변경이라는 하나의 기능을 구현합니다. 데이터베이스에서 사용자와 회사를 검색하고, 의사 결정을 도메인 모델에 위임한 다음, 결과를 다시 데이터베이스에 저장하고 필요한 경우 메시지 버스에 메시지를 넣습니다(그림 8.6).

```
                      +-------------------+
                      | GetUserById       |
                      | GetCompany        |
                      +-------------------+
                           ▲           ▲
                           │           │
                           │           │
                      +-------------------+
                      | Database          |
                      +-------------------+
                           ▲           ▲
                           │           │
                           │           │
                      +-------------------+
                      | Application       |
                      | service           |
                      | (controller)      |
                      | ChangeEmail       |
                      +-------------------+
                           ▲           ▲
                           │           │
                           │           │
                      +-------------------+
                      | Business logic    |
                      | (domain model)    |
                      | CanChangeEmail    |
                      +-------------------+
                           ▲           ▲
                           │           │
                           │           │
                      +-------------------+
                      | SaveCompany       |
                      | SaveUser          |
                      | SendMessage       |
                      +-------------------+
                           ▲           ▲
                           │           │
                           │           │
                      +-------------------+
                      | Message bus       |
                      +-------------------+
```

**그림 8.6** 사용자 이메일 변경 유스케이스. 컨트롤러는 데이터베이스, 메시지 버스, 도메인 모델 간의 작업을 조정합니다.

다음 목록은 현재 컨트롤러가 어떻게 생겼는지 보여줍니다.

**목록 8.1** 사용자 컨트롤러

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public string ChangeEmail(int userId, string newEmail)
    {
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);
        string error = user.CanChangeEmail();
        if (error != null)
            return error;

        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);

        user.ChangeEmail(newEmail, company);

        _database.SaveCompany(company);
        _database.SaveUser(user);

        foreach (EmailChangedEvent ev in user.EmailChangedEvents)
        {
            _messageBus.SendEmailChangedMessage(ev.UserId, ev.NewEmail);
        }

        return "OK";
    }
}
```

다음 섹션에서는 먼저 통합 테스트를 사용하여 확인할 시나리오를 설명합니다. 그런 다음 테스트에서 데이터베이스와 메시지 버스와 함께 작업하는 방법을 보여줍니다.

#### 8.3.1 어떤 시나리오를 테스트해야 하는가?

앞서 언급했듯이, 통합 테스트에 대한 일반적인 가이드라인은 **가장 긴 해피 경로**와 **단위 테스트로 실행할 수 없는 모든 엣지 케이스**를 커버하는 것입니다. 가장 긴 해피 경로는 모든 프로세스 외부 종속성을 통과하는 경로입니다.

CRM 프로젝트에서 가장 긴 해피 경로는 **기업 이메일에서 비기업 이메일로 변경하는 것**입니다. 이러한 변경은 최대 수의 부작용을 초래합니다:

  * 데이터베이스에서 사용자 및 회사 모두 업데이트됩니다: 사용자는 유형(기업에서 비기업으로)과 이메일을 변경하고, 회사는 직원 수를 변경합니다.
  * 메시지 버스로 메시지가 전송됩니다.

단위 테스트로 테스트되지 않는 엣지 케이스는 이메일을 변경할 수 없는 시나리오 하나뿐입니다. 그러나 이 시나리오는 애플리케이션이 컨트롤러에 이 검사가 없으면 Fail Fast 방식으로 실패할 것이기 때문에 테스트할 필요가 없습니다. 따라서 하나의 통합 테스트만 남게 됩니다:

```csharp
public void Changing_email_from_corporate_to_non_corporate()
```

#### 8.3.2 데이터베이스와 메시지 버스 분류하기

통합 테스트를 작성하기 전에 두 가지 프로세스 외부 종속성을 분류하고 어떤 것을 직접 테스트하고 어떤 것을 모의(mock)로 대체할지 결정해야 합니다. 애플리케이션 데이터베이스는 다른 시스템이 액세스할 수 없기 때문에 **관리되는 종속성**입니다. 따라서 실제 인스턴스를 사용해야 합니다. 통합 테스트는 다음을 수행합니다:

  * 데이터베이스에 사용자 및 회사를 삽입합니다.
  * 해당 데이터베이스에서 이메일 변경 시나리오를 실행합니다.
  * 데이터베이스 상태를 확인합니다.

반면에 메시지 버스는 **관리되지 않는 종속성**입니다. 그 유일한 목적은 다른 시스템과의 통신을 가능하게 하는 것입니다. 통합 테스트는 메시지 버스를 모의 처리하고 컨트롤러와 모의 간의 상호 작용을 나중에 확인합니다.

#### 8.3.3 엔드투엔드 테스트는 어떤가?

샘플 프로젝트에는 엔드투엔드 테스트가 없을 것입니다. API 시나리오에서 엔드투엔드 테스트는 배포되고 완전히 작동하는 API 버전에 대해 실행되는 테스트로, 모든 프로세스 외부 종속성에 대한 모의가 없음을 의미합니다(그림 8.7). 반면에 통합 테스트는 동일한 프로세스 내에서 애플리케이션을 호스팅하고 관리되지 않는 종속성을 모의로 대체합니다(그림 8.8).

```
+--------------------+       +--------------------+
| Message bus        |       | Database           |
+--------------------+       +--------------------+
          ▲                          ▲
          │                          │
(Out-of-process)          (Out-of-process)
          │                          │
          │                          │
+--------------------+
| Application        |
+--------------------+
          ▲
          │
          │ (End-to-end test)
          │
+--------------------+
| In-process         |
+--------------------+
```

**그림 8.7** 엔드투엔드 테스트는 외부 클라이언트를 에뮬레이트하므로 배포된 버전의 애플리케이션을 모든 프로세스 외부 종속성을 포함하여 테스트 범위에 포함시켜 테스트합니다. 엔드투엔드 테스트는 관리되는 종속성(예: 데이터베이스)을 직접 확인해서는 안 되며, 애플리케이션을 통해서 간접적으로만 확인해야 합니다.

```
+--------------------+       +--------------------+
| Database           |       | Message bus mock   |
+--------------------+       +--------------------+
          ▲                          ▲
          │                          │
(Out-of-process)          (In-process, mock)
          │                          │
          │                          │
+--------------------+
| Application        |
+--------------------+
          ▲
          │
          │ (Integration test)
          │
+--------------------+
| In-process         |
+--------------------+
```

**그림 8.8** 통합 테스트는 동일한 프로세스 내에서 애플리케이션을 호스팅합니다. 엔드투엔드 테스트와 달리 통합 테스트는 관리되지 않는 종속성을 모의로 대체합니다. 통합 테스트를 위한 유일한 프로세스 외부 구성 요소는 관리되는 종속성입니다.

2장에서 언급했듯이, 엔드투엔드 테스트를 사용할지 여부는 판단 문제입니다. 대부분의 경우, 통합 테스트 범위에 관리되는 종속성을 포함하고 관리되지 않는 종속성만 모의 처리할 때, 통합 테스트는 엔드투엔드 테스트와 거의 동일한 수준의 보호를 제공하므로 엔드투엔드 테스트를 건너뛸 수 있습니다. 그러나 배포 후 프로젝트에 대한 건전성 검사를 제공하는 하나 또는 두 개의 포괄적인 엔드투엔드 테스트를 여전히 만들 수 있습니다. 애플리케이션이 모든 프로세스 외부 종속성과 제대로 통신하는지 확인하기 위해 그러한 테스트도 가장 긴 해피 경로를 통과하도록 만드십시오. 외부 클라이언트의 동작을 에뮬레이트하려면 메시지 버스를 직접 확인하되, 데이터베이스의 상태는 애플리케이션 자체를 통해 확인하십시오.

#### 8.3.4 통합 테스트: 첫 시도

다음은 통합 테스트의 첫 번째 버전입니다.

**목록 8.2** 통합 테스트

```csharp
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    // Arrange (준비)
    var db = new Database(ConnectionString);
    User user = CreateUser( // 데이터베이스에 사용자 및 회사 생성
        "user@mycorp.com", UserType.Employee, db);
    CreateCompany("mycorp.com", 1, db);
    var messageBusMock = new Mock<IMessageBus>(); // 메시지 버스에 대한 모의 설정
    var sut = new UserController(db, messageBusMock.Object);

    // Act (실행)
    string result = sut.ChangeEmail(user.UserId, "new@gmail.com");

    // Assert (단언)
    Assert.Equal("OK", result);
    object[] userData = db.GetUserById(user.UserId);
    User userFromDb = UserFactory.Create(userData);
    Assert.Equal("new@gmail.com", userFromDb.Email); // 사용자의 상태 단언
    Assert.Equal(UserType.Customer, userFromDb.Type);
    object[] companyData = db.GetCompany();
    Company companyFromDb = CompanyFactory
        .Create(companyData);
    Assert.Equal(0, companyFromDb.NumberOfEmployees); // 회사의 상태 단언
    messageBusMock.Verify( // 모의와의 상호 작용 확인
        x => x.SendEmailChangedMessage(
            user.UserId, "new@gmail.com"),
        Times.Once);
}
```

**팁** `Arrange` 섹션에서 테스트는 사용자 및 회사를 직접 데이터베이스에 삽입하지 않고 `CreateUser` 및 `CreateCompany` 헬퍼 메서드를 호출한다는 점에 유의하십시오. 이러한 메서드는 여러 통합 테스트에서 재사용될 수 있습니다.

입력 매개변수로 사용된 데이터와 독립적으로 데이터베이스의 상태를 확인하는 것이 중요합니다. 이를 위해 통합 테스트는 `Assert` 섹션에서 사용자 및 회사 데이터를 별도로 쿼리하고, 새 `userFromDb` 및 `companyFromDb` 인스턴스를 생성한 다음, 해당 상태를 단언합니다. 이 접근 방식은 테스트가 데이터베이스에 대한 쓰기 및 읽기 모두를 실행하여 회귀에 대한 최대 보호를 제공하도록 보장합니다. 읽기 자체는 컨트롤러가 내부적으로 사용하는 것과 동일한 코드(이 예에서는 `Database`, `UserFactory`, `CompanyFactory` 클래스 사용)를 사용하여 구현되어야 합니다.

이 통합 테스트는 작업을 수행하지만 여전히 일부 개선이 가능합니다. 예를 들어, `Assertion` 섹션에서도 헬퍼 메서드를 사용하여 이 섹션의 크기를 줄일 수 있습니다. 또한 `messageBusMock`은 잠재적으로 제공할 수 있는 것만큼 회귀에 대한 좋은 보호를 제공하지 않습니다. 이러한 개선 사항에 대해서는 모의(mocking) 및 데이터베이스 테스트 모범 사례를 다루는 다음 두 장에서 이야기할 것입니다.

-----

### 8.4 종속성 추상화를 위한 인터페이스 사용

단위 테스트 분야에서 가장 오해받는 주제 중 하나는 인터페이스의 사용입니다. 개발자들은 종종 인터페이스를 도입하는 이유를 잘못 해석하고, 그 결과 인터페이스를 과도하게 사용하는 경향이 있습니다. 이 섹션에서는 이러한 잘못된 이유들을 자세히 설명하고, 어떤 상황에서 인터페이스 사용이 바람직하고 어떤 상황에서 바람직하지 않은지 보여줄 것입니다.

#### 8.4.1 인터페이스와 느슨한 결합

많은 개발자들은 데이터베이스나 메시지 버스와 같은 프로세스 외부 종속성에 대해 단 하나의 구현만 가지고 있더라도 인터페이스를 도입합니다. 이러한 관행은 오늘날 너무나 널리 퍼져서 거의 아무도 의문을 제기하지 않습니다. 여러분은 종종 다음과 유사한 클래스-인터페이스 쌍을 보게 될 것입니다:

```csharp
public interface IMessageBus
public class MessageBus : IMessageBus

public interface IUserRepository
public class UserRepository : IUserRepository
```

이러한 인터페이스 사용에 대한 일반적인 추론은 다음과 같은 데 도움이 된다는 것입니다:

  * 프로세스 외부 종속성을 추상화하여 **느슨한 결합**을 달성한다.
  * 기존 코드를 변경하지 않고 새로운 기능을 추가하여 \*\*개방-폐쇄 원칙(OCP)\*\*을 준수한다.

이 두 가지 이유 모두 **오해**입니다. 단일 구현을 가진 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체적인 클래스보다 더 느슨한 결합을 제공하지 않습니다. **진정한 추상화는 발명되는 것이 아니라 발견됩니다.** 정의상 발견은 사후에, 추상화가 이미 존재하지만 코드에 아직 명확하게 정의되지 않았을 때 발생합니다. 따라서 인터페이스가 진정한 추상화가 되려면 적어도 두 개 이상의 구현을 가져야 합니다.

두 번째 이유(기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있는 능력)는 더 근본적인 원칙인 **YAGNI**를 위반하기 때문에 오해입니다. YAGNI는 "You aren't gonna need it (지금 당장 필요하지 않을 거야)"의 약자로, 지금 당장 필요하지 않은 기능에 시간을 투자하는 것을 반대합니다. 이 기능을 개발해서는 안 되며, 미래에 그러한 기능이 나타날 것을 고려하여 기존 코드를 수정해서도 안 됩니다. 주요 두 가지 이유는 다음과 같습니다:

  * **기회 비용** — 사업자들이 당장 필요로 하지 않는 기능에 시간을 할애하면, 당장 필요한 기능에 할애할 시간을 빼앗게 됩니다. 게다가 사업자들이 개발된 기능을 마침내 필요로 하게 되면, 그들의 기능에 대한 시각은 아마도 진화했을 것이고, 여러분은 이미 작성된 코드를 여전히 조정해야 할 것입니다. 이러한 활동은 낭비입니다. 실제 필요가 발생했을 때 기능을 처음부터 구현하는 것이 더 이롭습니다.
  * **프로젝트 내 코드가 적을수록 좋다.** 즉각적인 필요 없이 혹시 모를 경우에 대비하여 코드를 도입하는 것은 코드베이스의 소유 비용을 불필요하게 증가시킵니다. 프로젝트의 가능한 한 늦은 단계까지 새로운 기능 도입을 미루는 것이 좋습니다.

**팁** 코드를 작성하는 것은 문제를 해결하는 데 비용이 많이 드는 방법입니다. 솔루션이 적은 코드를 요구하고 그 코드가 더 간단할수록 좋습니다.

YAGNI가 적용되지 않는 예외적인 경우가 있지만, 이런 경우는 거의 없습니다. 이러한 경우에 대해서는 제 글 "OCP vs YAGNI"([https://enterprise-craftsmanship.com/posts/ocp-vs-yagni)를](https://www.google.com/search?q=https://enterprise-craftsmanship.com/posts/ocp-vs-yagni)를) 참조하십시오.

#### 8.4.2 프로세스 외부 종속성에 인터페이스를 사용하는 이유

그렇다면 각 인터페이스가 하나의 구현만 가지고 있다고 가정할 때, 프로세스 외부 종속성에 인터페이스를 사용하는 이유는 무엇일까요? 실제 이유는 훨씬 더 실용적이고 현실적입니다. 바로 **모의(mocking)를 가능하게 하기 위함**입니다. 인터페이스가 없으면 테스트 더블을 생성할 수 없으므로, 테스트 대상 시스템과 프로세스 외부 종속성 간의 상호 작용을 확인할 수 없습니다.

따라서 해당 종속성을 모의 처리해야 할 필요가 없다면 프로세스 외부 종속성에 대한 인터페이스를 도입하지 마십시오. 관리되지 않는 종속성만 모의 처리하므로, 이 가이드라인은 다음으로 요약될 수 있습니다: **관리되지 않는 종속성에만 인터페이스를 사용하십시오.** 관리되는 종속성은 여전히 컨트롤러에 명시적으로 주입하지만, 그럴 때는 구체적인 클래스를 사용하십시오.

두 개 이상의 구현을 가진 진정한 추상화(진정한 추상화)는 모의 처리 여부와 관계없이 인터페이스로 표현될 수 있다는 점에 유의하십시오. 그러나 모의 처리 외의 이유로 단일 구현을 가진 인터페이스를 도입하는 것은 YAGNI 위반입니다.

그리고 목록 8.2에서 `UserController`가 이제 메시지 버스와 데이터베이스를 모두 생성자를 통해 명시적으로 받아들이지만, 메시지 버스만 해당 인터페이스를 가지고 있다는 것을 눈치챘을 수도 있습니다. 데이터베이스는 관리되는 종속성이므로 그러한 인터페이스가 필요하지 않습니다. 다음은 컨트롤러입니다:

```csharp
public class UserController
{
    private readonly Database _database; // 구체적인 클래스
    private readonly IMessageBus _messageBus; // 인터페이스

    public UserController(Database database, IMessageBus messageBus)
    {
        _database = database;
        _messageBus = messageBus;
    }

    public string ChangeEmail(int userId, string newEmail)
    /* 이 메서드는 _database 및 _messageBus를 사용합니다 */
    {
    }
}
```

**참고** 인터페이스에 의존하지 않고도 종속성을 모의 처리할 수 있습니다. 해당 종속성의 메서드를 `virtual`로 만들고 클래스 자체를 모의의 기본으로 사용하는 방식입니다. 그러나 이 접근 방식은 인터페이스를 사용하는 것보다 열등합니다. 인터페이스 대 기본 클래스에 대한 이 주제에 대해서는 11장에서 더 자세히 설명합니다.

#### 8.4.3 프로세스 내 종속성에 인터페이스 사용하기

때로는 프로세스 외부 종속성뿐만 아니라 프로세스 내 종속성까지도 인터페이스로 뒷받침하는 코드베이스를 볼 수 있습니다. 예를 들면 다음과 같습니다:

```csharp
public interface IUser
{
    int UserId { get; set; }
    string Email { get; }
    string CanChangeEmail();
    void ChangeEmail(string newEmail, Company company);
}

public class User : IUser
{
    /* ... */
}
```


`IUser`가 단 하나의 구현만을 가진다고 가정할 때(그리고 그러한 특정 인터페이스는 항상 단 하나의 구현만을 가집니다), 이것은 **엄청난 위험 신호**입니다. 프로세스 외부 종속성과 마찬가지로, 도메인 클래스에 단일 구현을 가진 인터페이스를 도입하는 유일한 이유는 모의(mocking)를 가능하게 하기 위함입니다. 그러나 프로세스 외부 종속성과 달리, **도메인 클래스 간의 상호 작용을 확인해서는 안 됩니다.** 왜냐하면 그렇게 하면 취약한 테스트(구현 세부 사항에 결합되어 리팩토링에 대한 저항력 측정에서 실패하는 테스트)가 발생하기 때문입니다(모의 및 테스트 취약성에 대한 자세한 내용은 5장 참조).
-----

## 8.5 통합 테스트 모범 사례

통합 테스트를 최대한 활용하는 데 도움이 되는 몇 가지 일반적인 지침이 있습니다:

  * **도메인 모델 경계를 명시적으로 만들기**
  * **애플리케이션의 계층 수 줄이기**
  * **순환 종속성 제거하기**

늘 그렇듯이, 테스트에 유익한 모범 사례는 일반적으로 코드베이스의 상태를 개선하는 경향이 있습니다.

### 8.5.1 도메인 모델 경계를 명시적으로 만들기

코드베이스에서 도메인 모델에 대해 항상 명시적이고 잘 알려진 위치를 갖도록 노력하세요. **도메인 모델**은 프로젝트가 해결하고자 하는 문제에 대한 도메인 지식의 집합입니다. 도메인 모델에 명시적인 경계를 할당하면 코드의 해당 부분을 더 잘 시각화하고 추론할 수 있습니다.

이러한 관행은 테스트에도 도움이 됩니다. 이 장의 앞부분에서 언급했듯이, 단위 테스트는 도메인 모델과 알고리즘을 대상으로 하는 반면, 통합 테스트는 컨트롤러를 대상으로 합니다. 도메인 클래스와 컨트롤러 간의 명시적인 경계는 단위 테스트와 통합 테스트의 차이를 구별하기 쉽게 만듭니다.

경계 자체는 별도의 어셈블리 또는 네임스페이스 형태를 취할 수 있습니다. 모든 도메인 로직이 단일하고 명확한 범주 아래에 있고 코드베이스 전체에 흩어져 있지 않은 한, 세부 사항은 그렇게 중요하지 않습니다.

### 8.5.2 계층 수 줄이기

대부분의 프로그래머는 추가적인 간접 계층(layers of indirection)을 도입하여 코드를 추상화하고 일반화하려는 경향이 있습니다. 일반적인 엔터프라이즈 수준 애플리케이션에서는 여러 개의 이러한 계층을 쉽게 관찰할 수 있습니다(그림 8.9).

```
+-----------------------------------+
| 애플리케이션 서비스 계층 (사용자 이메일 변경, 비밀번호 재설정, 주문 결제) |
+-----------------------------------+
                  ▲
                  │
                  │
+-----------------------------------+
| 비즈니스 로직 구현 계층             |
+-----------------------------------+
                  ▲
                  │
                  │
+-----------------------------------+
| 추상화 계층                       |
+-----------------------------------+
                  ▲
                  │
                  │
+-----------------------------------+
| 영속성 계층                       |
+-----------------------------------+
```

**그림 8.9** 다양한 애플리케이션 관심사는 종종 별도의 간접 계층에 의해 처리됩니다. 일반적인 기능은 각 계층의 작은 부분을 차지합니다.

극단적인 경우, 애플리케이션은 너무 많은 추상화 계층을 가져서 코드베이스를 탐색하고 가장 간단한 작업 뒤에 숨겨진 논리를 이해하기가 너무 어려워집니다. 어느 시점에서 당신은 현재 문제에 대한 특정 솔루션에 도달하고 싶어질 뿐, 진공 상태의 그 솔루션에 대한 어떤 일반화가 아닙니다.

컴퓨터 과학의 모든 문제는 또 다른 간접 계층으로 해결될 수 있습니다. 너무 많은 간접 계층의 문제만 빼고 말입니다.
— 데이비드 J. 휠러

간접 계층은 코드에 대한 추론 능력에 부정적인 영향을 미칩니다. 모든 기능이 각 계층에 표현될 때, 모든 조각을 응집력 있는 그림으로 조립하는 데 상당한 노력을 기울여야 합니다. 이는 전체 개발 프로세스를 방해하는 추가적인 정신적 부담을 야기합니다.

과도한 수의 추상화는 단위 또는 통합 테스트에도 도움이 되지 않습니다. 많은 간접 계층을 가진 코드베이스는 컨트롤러와 도메인 모델 사이에 명확한 경계가 없는 경향이 있습니다(7장에서 기억하시겠지만, 이는 효과적인 테스트를 위한 전제 조건입니다). 또한 각 계층을 별도로 검증하려는 경향이 훨씬 강합니다. 이러한 경향은 많은 저가치 통합 테스트를 초래하며, 각 테스트는 특정 계층의 코드만 실행하고 그 아래 계층은 모의 처리합니다. 최종 결과는 항상 동일합니다: 회귀에 대한 불충분한 보호와 리팩토링에 대한 낮은 저항력이 결합된 상태입니다.

가능한 한 **간접 계층을 적게** 가지도록 노력하십시오. 대부분의 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층의 세 가지만으로도 충분합니다. 인프라 계층은 일반적으로 도메인 모델에 속하지 않는 알고리즘과 프로세스 외부 종속성에 대한 액세스를 가능하게 하는 코드로 구성됩니다(그림 8.10).

```
+-----------------------------------+
| 애플리케이션 서비스 계층             |
| (사용자 이메일 변경, 비밀번호 재설정, 주문 결제) |
+-----------------------------------+
                  ▲
                  │
                  │ 외부 클라이언트를 위한 진입점 제공 및 도메인 클래스와 프로세스 외부 종속성 간의 작업 조정
                  │
+-----------------------------------+
| 도메인 계층                       |
| (도메인 로직 포함)                |
+-----------------------------------+
                  ▲
                  │
                  │
+-----------------------------------+
| 인프라 계층                       |
| (프로세스 외부 종속성 작업; 데이터베이스 저장소, ORM 매핑, SMTP 게이트웨이) |
+-----------------------------------+
```

**그림 8.10** 도메인 계층(도메인 로직 포함), 애플리케이션 서비스 계층(외부 클라이언트를 위한 진입점을 제공하고 도메인 클래스와 프로세스 외부 종속성 간의 작업을 조정함), 인프라 계층(프로세스 외부 종속성과 함께 작동; 데이터베이스 저장소, ORM 매핑, SMTP 게이트웨이가 이 계층에 있음)의 세 가지 계층만으로도 충분합니다.

### 8.5.3 순환 종속성 제거하기

코드베이스의 유지 관리성을 크게 향상시키고 테스트를 더 쉽게 만들 수 있는 또 다른 관행은 **순환 종속성(circular dependencies)을 제거하는 것**입니다.

**정의** \*\*순환 종속성(cyclic dependency라고도 함)\*\*은 기능을 수행하기 위해 직접 또는 간접적으로 서로 의존하는 둘 이상의 클래스입니다.

순환 종속성의 일반적인 예는 콜백입니다:

```csharp
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        service.GenerateReport(orderId, this); // ReportGenerationService가 CheckOutService에 의존

        /* 다른 코드 */
    }
}

public class ReportGenerationService
{
    public void GenerateReport(
        int orderId,
        CheckOutService checkOutService) // CheckOutService에 의존
    {
        /* 생성 완료 시 checkOutService를 호출합니다 */
    }
}
```

여기서 `CheckOutService`는 `ReportGenerationService`의 인스턴스를 생성하고, 자신을 해당 인스턴스에 인수로 전달합니다. `ReportGenerationService`는 `CheckOutService`를 다시 호출하여 보고서 생성 결과에 대해 알립니다.

과도한 수의 추상화 계층과 마찬가지로, 순환 종속성은 코드를 읽고 이해하려고 할 때 엄청난 인지 부하를 추가합니다. 그 이유는 순환 종속성이 솔루션을 탐색하기 시작할 수 있는 명확한 시작점을 제공하지 않기 때문입니다. 단 하나의 클래스를 이해하려면 모든 관련 클래스 그래프를 한 번에 읽고 이해해야 합니다. 심지어 소수의 상호 의존적인 클래스 세트도 빠르게 이해하기 너무 어려워질 수 있습니다.

순환 종속성은 테스트에도 방해가 됩니다. 클래스 그래프를 분할하고 단일 동작 단위를 격리하기 위해 종종 인터페이스와 모의(mocking)에 의존해야 하는데, 이는 도메인 모델을 테스트할 때는 허용되지 않습니다(자세한 내용은 5장 참조).

인터페이스를 사용하는 것은 순환 종속성 문제를 가리는 역할만 한다는 점에 유의하십시오. `CheckOutService`에 인터페이스를 도입하고 `ReportGenerationService`가 구체적인 클래스 대신 해당 인터페이스에 의존하도록 만들면 컴파일 시점에 순환 종속성을 제거하지만(그림 8.11), 런타임에는 여전히 순환이 지속됩니다. 컴파일러가 더 이상 이 클래스 구성을 순환 참조로 간주하지 않더라도, 코드를 이해하는 데 필요한 인지 부하는 줄어들지 않습니다. 오히려 추가적인 인터페이스 때문에 증가합니다.

```
+-----------------+
| CheckOutService |
+-----------------+
        │
        ▼
+-----------------+
| ICheckOutService|  <--- (인터페이스 도입으로 컴파일 시 순환 제거)
+-----------------+
        ▲
        │
+-------------------------+
| ReportGenerationService |
+-------------------------+
```

**그림 8.11** 인터페이스를 사용하면 컴파일 시점에 순환 종속성을 제거하지만, 런타임에는 제거되지 않습니다. 코드를 이해하는 데 필요한 인지 부하는 줄어들지 않습니다.

순환 종속성을 처리하는 더 나은 접근 방식은 **그것들을 제거하는 것**입니다. `ReportGenerationService`가 `CheckOutService`나 `ICheckOutService` 인터페이스에 의존하지 않도록 리팩토링하고, `CheckOutService`를 호출하는 대신 작업 결과를 일반 값으로 반환하도록 만드세요:

```csharp
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        Report report = service.GenerateReport(orderId); // 결과 값을 직접 받음
        /* 다른 작업 */
    }
}

public class ReportGenerationService
{
    public Report GenerateReport(int orderId)
    {
        /* ... */ // 콜백 없이 결과 Report 객체를 반환
    }
}
```

코드베이스의 모든 순환 종속성을 제거하는 것은 거의 불가능합니다. 하지만 그렇다 하더라도, 남아 있는 상호 의존적인 클래스 그래프를 가능한 한 작게 만들어 피해를 최소화할 수 있습니다.

### 8.5.4 테스트에서 여러 Act 섹션 사용하기

3장에서 기억하시겠지만, 테스트에 여러 개의 `Arrange`, `Act`, 또는 `Assert` 섹션이 있는 것은 \*\*코드 스멜(code smell)\*\*입니다. 이는 해당 테스트가 여러 동작 단위를 확인한다는 신호이며, 이는 결국 테스트의 유지 관리성을 방해합니다. 예를 들어, 사용자 등록 및 사용자 삭제와 같이 두 가지 관련 유스케이스가 있는 경우, 이 두 가지 유스케이스를 단일 통합 테스트에서 확인하고 싶은 유혹을 받을 수 있습니다. 이러한 테스트는 다음 구조를 가질 수 있습니다:

  * **Arrange** — 사용자를 등록할 데이터를 준비합니다.
  * **Act** — `UserController.RegisterUser()`를 호출합니다.
  * **Assert** — 데이터베이스를 쿼리하여 등록이 성공적으로 완료되었는지 확인합니다.
  * **Act** — `UserController.DeleteUser()`를 호출합니다.
  * **Assert** — 데이터베이스를 쿼리하여 사용자가 삭제되었는지 확인합니다.

이 접근 방식은 사용자 상태가 자연스럽게 서로 이어지고, 첫 번째 `Act`(사용자 등록)가 다음 `Act`(사용자 삭제)에 대한 `Arrange` 단계를 동시에 수행할 수 있기 때문에 매력적입니다. 문제는 이러한 테스트가 초점을 잃고 빠르게 너무 비대해질 수 있다는 것입니다.

각 `Act`를 별도의 테스트로 추출하여 **테스트를 분할하는 것이 가장 좋습니다.** 불필요한 작업처럼 보일 수 있지만(결국 하나로 충분한데 왜 두 개의 테스트를 만드는가?), 이 작업은 장기적으로 보상할 것입니다. 각 테스트가 단일 동작 단위에 집중하면 필요할 때 해당 테스트를 이해하고 수정하기가 더 쉬워집니다.

이 지침의 예외는 원하는 상태로 만들기가 어려운 프로세스 외부 종속성과 함께 작동하는 테스트입니다. 예를 들어, 사용자 등록이 외부 은행 시스템에 은행 계좌를 생성한다고 가정해 봅시다. 은행은 조직을 위한 샌드박스를 제공했으며, 해당 샌드박스를 엔드투엔드 테스트에서 사용하고 싶습니다. 문제는 샌드박스가 너무 느리거나, 은행이 샌드박스에 대한 호출 수를 제한할 수 있다는 것입니다. 이러한 시나리오에서는 여러 `Act`를 단일 테스트로 결합하여 문제 있는 프로세스 외부 종속성과의 상호 작용 횟수를 줄이는 것이 유익합니다.

**관리하기 어려운 프로세스 외부 종속성**은 둘 이상의 `Act` 섹션을 가진 테스트를 작성하는 유일한 정당한 이유입니다. 이것이 단위 테스트에서 여러 `Act`를 가져서는 안 되는 이유입니다. 단위 테스트는 프로세스 외부 종속성과 함께 작동하지 않습니다. 통합 테스트조차도 여러 `Act`를 가지는 경우는 거의 없습니다. 실제로 다단계 테스트는 거의 항상 엔드투엔드 테스트 범주에 속합니다.

-----

### 8.6 로깅 기능 테스트 방법

로깅은 회색 영역이며, 테스트와 관련하여 무엇을 해야 할지 명확하지 않습니다. 이는 다음 질문들로 나눌 복잡한 주제입니다:

  * 로깅을 전혀 테스트해야 하는가?
  * 그렇다면 어떻게 테스트해야 하는가?
  * 로깅이 어느 정도면 충분한가?
  * 로거 인스턴스를 어떻게 전달하는가?

예시로 우리의 샘플 CRM 프로젝트를 사용할 것입니다.

#### 8.6.1 로깅을 테스트해야 하는가?

로깅은 코드베이스의 어느 부분에서든 필요할 수 있는 교차 기능입니다. 다음은 `User` 클래스의 로깅 예시입니다.

**목록 8.3** `User`의 로깅 예시

```csharp
public class User
{
    public void ChangeEmail(string newEmail, Company company)
    {
        _logger.Info( // 메서드 시작 로깅
            $"Changing email for user {UserId} to {newEmail}");
        Precondition.Requires(CanChangeEmail() == null);
        if (Email == newEmail)
            return;

        UserType newType = company.IsEmailCorporate(newEmail)
            ? UserType.Employee
            : UserType.Customer;

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
            _logger.Info( // 사용자 유형 변경 로깅
                $"User {UserId} changed type " +
                $"from {Type} to {newType}");
        }

        Email = newEmail;
        Type = newType;
        EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));
        _logger.Info( // 메서드 끝 로깅
            $"Email is changed for user {UserId}");
    }
}
```

`User` 클래스는 `ChangeEmail` 메서드의 시작과 끝, 그리고 사용자 유형 변경을 로그 파일에 기록합니다. 이 기능을 테스트해야 할까요?

한편으로 로깅은 애플리케이션의 동작에 대한 중요한 정보를 생성합니다. 하지만 다른 한편으로는 로깅이 너무 보편적이어서 이 기능이 추가적이고 상당히 중요한 테스트 노력의 가치가 있는지 불분명합니다. 로깅을 테스트해야 하는지에 대한 답은 다음과 같습니다: **로깅이 애플리케이션의 관찰 가능한 동작의 일부인가, 아니면 구현 세부 사항인가?**

그런 의미에서 다른 기능과 다르지 않습니다. 로깅은 궁극적으로 텍스트 파일이나 데이터베이스와 같은 프로세스 외부 종속성에서 부작용을 초래합니다. 이러한 부작용이 고객, 애플리케이션의 클라이언트, 또는 개발자 자신 외의 다른 사람에 의해 관찰되도록 의도된 경우, 로깅은 **관찰 가능한 동작**이며 따라서 테스트되어야 합니다. 유일한 대상이 개발자인 경우, 이는 아무도 눈치채지 못하게 자유롭게 수정할 수 있는 **구현 세부 사항**이며, 이 경우에는 테스트해서는 안 됩니다.

예를 들어, 로깅 라이브러리를 작성하는 경우, 이 라이브러리가 생성하는 로그는 그 관찰 가능한 동작의 가장 중요한(그리고 유일한) 부분입니다. 또 다른 예는 사업자들이 핵심 애플리케이션 워크플로우 로깅을 고집할 때입니다. 이 경우 로그도 비즈니스 요구 사항이 되므로 테스트로 커버되어야 합니다. 그러나 후자의 예에서는 개발자만을 위한 별도의 로깅도 있을 수 있습니다.

스티브 프리먼(Steve Freeman)과 냇 프라이스(Nat Pryce)는 그들의 책 『Growing Object-Oriented Software, Guided by Tests』(Addison-Wesley Professional, 2009)에서 이 두 가지 유형의 로깅을 \*\*지원 로깅(support logging)\*\*과 \*\*진단 로깅(diagnostic logging)\*\*이라고 부릅니다:

  * **지원 로깅**은 지원 스태프나 시스템 관리자가 추적하도록 의도된 메시지를 생성합니다.
  * **진단 로깅**은 개발자가 애플리케이션 내부에서 무슨 일이 일어나고 있는지 이해하는 데 도움이 됩니다.

#### 8.6.2 로깅은 어떻게 테스트해야 하는가?

로깅은 프로세스 외부 종속성을 포함하므로, 이를 테스트할 때는 프로세스 외부 종속성을 건드리는 다른 기능과 동일한 규칙이 적용됩니다. 애플리케이션과 로그 저장소 간의 상호 작용을 확인하기 위해 **모의(mock)를 사용**해야 합니다.

**ILOGGER 위에 래퍼 도입하기**

하지만 단순히 `ILogger` 인터페이스를 모의 처리하지 마십시오. 지원 로깅은 비즈니스 요구 사항이므로, 해당 요구 사항을 코드베이스에 명시적으로 반영하십시오. 비즈니스에 필요한 모든 지원 로깅을 명시적으로 나열하는 특별한 **`DomainLogger` 클래스**를 생성하십시오. `ILogger` 원시 인터페이스 대신 해당 클래스와의 상호 작용을 확인하십시오.

예를 들어, 사업자들이 사용자 유형의 모든 변경 사항을 로깅하도록 요구하지만, 메서드 시작과 끝의 로깅은 디버깅 목적으로만 존재한다고 가정해 봅시다. 다음 목록은 `DomainLogger` 클래스를 도입한 후의 `User` 클래스를 보여줍니다.

**목록 8.4** 지원 로깅을 `DomainLogger` 클래스로 추출하기

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    _logger.Info( // 진단 로깅
        $"Changing email for user {UserId} to {newEmail}");
    Precondition.Requires(CanChangeEmail() == null);
    if (Email == newEmail)
        return;

    UserType newType = company.IsEmailCorporate(newEmail)
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);
        _domainLogger.UserTypeHasChanged( // 지원 로깅
            UserId, Type, newType);
    }

    Email = newEmail;
    Type = newType;
    EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));
    _logger.Info( // 진단 로깅
        $"Email is changed for user {UserId}");
}
```

진단 로깅은 여전히 이전 로거(`ILogger` 유형)를 사용하지만, 지원 로깅은 이제 `IDomainLogger` 유형의 새 `_domainLogger` 인스턴스를 사용합니다. 다음 목록은 `IDomainLogger`의 구현을 보여줍니다.

**목록 8.5** `ILogger` 위에 래퍼인 `DomainLogger`

```csharp
public class DomainLogger : IDomainLogger
{
    private readonly ILogger _logger;

    public DomainLogger(ILogger logger)
    {
        _logger = logger;
    }

    public void UserTypeHasChanged(
        int userId, UserType oldType, UserType newType)
    {
        _logger.Info(
            $"User {userId} changed type " +
            $"from {oldType} to {newType}");
    }
}
```

`DomainLogger`는 `ILogger` 위에 작동합니다. 즉, 도메인 언어를 사용하여 비즈니스에 필요한 특정 로그 항목을 선언하므로 지원 로깅을 이해하고 유지 관리하기 쉽게 만듭니다. 사실, 이 구현은 로그 파일 후처리 및 분석에 큰 유연성을 제공하는 **구조화된 로깅(structured logging)** 개념과 매우 유사합니다.

**구조화된 로깅 이해하기**

**구조화된 로깅**은 로그 데이터 캡처가 해당 데이터 렌더링과 분리되는 로깅 기술입니다. 전통적인 로깅은 단순 텍스트로 작동합니다. 다음과 같은 호출:

```csharp
logger.Info("User Id is " + 12);
```

먼저 문자열을 형성한 다음 해당 문자열을 로그 저장소에 씁니다. 이 접근 방식의 문제는 결과 로그 파일이 구조가 부족하여 분석하기 어렵다는 것입니다. 예를 들어, 특정 유형의 메시지가 몇 개이고 그 중 특정 사용자 ID와 관련된 메시지가 몇 개인지 확인하기가 쉽지 않습니다. 이를 위해서는 특별한 도구(또는 직접 작성한 도구)를 사용해야 합니다.

반면에 구조화된 로깅은 로그 저장소에 구조를 도입합니다. 구조화된 로깅 라이브러리의 사용은 표면적으로는 비슷하게 보입니다:

```csharp
logger.Info("User Id is {UserId}", 12);
```

그러나 그 기저의 동작은 상당히 다릅니다. 이 메서드는 내부적으로 메시지 템플릿의 해시를 계산하고(메시지 자체는 공간 효율성을 위해 조회 저장소에 저장됨) 해당 해시를 입력 매개변수와 결합하여 캡처된 데이터 집합을 형성합니다. 다음 단계는 해당 데이터의 렌더링입니다. 전통적인 로깅과 마찬가지로 여전히 평면 로그 파일을 가질 수 있지만, 이는 가능한 렌더링 중 하나일 뿐입니다. 캡처된 데이터를 JSON 또는 CSV 파일로 렌더링하도록 로깅 라이브러리를 구성할 수도 있으며, 이 경우 분석하기가 더 쉽습니다(그림 8.12).

```
logger.Info("User Id is {UserId}", 12)
        │
        ▼
+-----------------+
| MessageTemplate |
| User Id is {UserId} |
+-----------------+
        │
        ▼
+--------------+
| Log data     |
| UserId       |
| 12           |
+--------------+
        │
        ▼
+------------------------------------------------+
| 렌더링                                          |
|                                                |
| +-----------------+  +-----------------------+  +-----------------------+
| | 평면 로그 파일  |  | JSON 파일             |  | CSV 파일              |
| | User Id is 12   |  | { “MessageTemplate”:…,|  | MessageTemplate,UserId |
| +-----------------+  | “UserId” : 12 }       |  | User Id is {UserId},12 |
|                      +-----------------------+  +-----------------------+
+------------------------------------------------+
```

**그림 8.12** 구조화된 로깅은 로그 데이터를 해당 데이터의 렌더링과 분리합니다. 평면 로그 파일, JSON, CSV 파일과 같이 여러 렌더링을 설정할 수 있습니다.

목록 8.5의 `DomainLogger` 자체는 구조화된 로거는 아니지만, 동일한 정신으로 작동합니다. 이 메서드를 다시 살펴보십시오:

```csharp
public void UserTypeHasChanged(
    int userId, UserType oldType, UserType newType)
{
    _logger.Info(
        $"User {userId} changed type " +
        $"from {oldType} to {newType}");
}
```

`UserTypeHasChanged()`를 메시지 템플릿의 해시로 볼 수 있습니다. `userId`, `oldType`, `newType` 매개변수와 함께 이 해시는 로그 데이터를 형성합니다. 이 메서드의 구현은 로그 데이터를 평면 로그 파일로 렌더링합니다. 그리고 로그 데이터를 JSON 또는 CSV 파일로 작성하여 쉽게 추가 렌더링을 생성할 수 있습니다.

**지원 및 진단 로깅 테스트 작성**

앞서 언급했듯이 `DomainLogger`는 프로세스 외부 종속성인 로그 저장소를 나타냅니다. 이는 문제가 됩니다. `User`는 이제 해당 종속성과 상호 작용하므로 비즈니스 로직과 프로세스 외부 종속성과의 통신 간의 분리를 위반합니다. `DomainLogger`의 사용은 `User`를 지나치게 복잡한 코드 범주로 전환시켜 테스트하고 유지 관리하기 더 어렵게 만듭니다(코드 범주에 대한 자세한 내용은 7장 참조).

이 문제는 사용자 이메일 변경에 대한 외부 시스템 알림을 구현했던 것과 동일한 방식으로 해결할 수 있습니다: **도메인 이벤트**의 도움을 받아서요(다시 한번, 자세한 내용은 7장 참조). 사용자 유형의 변경 사항을 추적하기 위해 별도의 도메인 이벤트를 도입할 수 있습니다. 그러면 컨트롤러는 다음 목록에 표시된 것처럼 해당 변경 사항을 `DomainLogger` 호출로 변환합니다.

**목록 8.6** `User`에서 `DomainLogger`를 도메인 이벤트로 대체하기

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    _logger.Info(
        $"Changing email for user {UserId} to {newEmail}");
    Precondition.Requires(CanChangeEmail() == null);
    if (Email == newEmail)
        return;

    UserType newType = company.IsEmailCorporate(newEmail)
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);
        AddDomainEvent( // DomainLogger 대신 도메인 이벤트 사용
            new UserTypeChangedEvent(
                UserId, Type, newType));
    }

    Email = newEmail;
    Type = newType;
    AddDomainEvent(new EmailChangedEvent(UserId, newEmail));
    _logger.Info($"Email is changed for user {UserId}");
}
```

이제 `UserTypeChangedEvent`와 `EmailChangedEvent`라는 두 가지 도메인 이벤트가 있다는 점에 유의하십시오. 둘 다 동일한 인터페이스(`IDomainEvent`)를 구현하므로 동일한 컬렉션에 저장할 수 있습니다.

그리고 컨트롤러는 다음과 같습니다.

**목록 8.7** `UserController`의 최신 버전

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);
    string error = user.CanChangeEmail();
    if (error != null)
        return error;

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    _eventDispatcher.Dispatch(user.DomainEvents); // 사용자 도메인 이벤트 디스패치
    return "OK";
}
```

`EventDispatcher`는 도메인 이벤트를 프로세스 외부 종속성 호출로 변환하는 새로운 클래스입니다:

  * `EmailChangedEvent`는 `_messageBus.SendEmailChangedMessage()`로 변환됩니다.
  * `UserTypeChangedEvent`는 `_domainLogger.UserTypeHasChanged()`로 변환됩니다.

`UserTypeChangedEvent`의 사용은 두 가지 책임인 도메인 로직과 프로세스 외부 종속성과의 통신 간의 분리를 복원했습니다. 이제 지원 로깅을 테스트하는 것은 다른 관리되지 않는 종속성인 메시지 버스를 테스트하는 것과 다르지 않습니다:

  * 단위 테스트는 테스트 중인 `User` 인스턴스에서 `UserTypeChangedEvent` 인스턴스를 확인해야 합니다.
  * 단일 통합 테스트는 모의(mock)를 사용하여 `DomainLogger`와의 상호 작용이 제대로 이루어지는지 확인해야 합니다.

컨트롤러에서 지원 로깅을 수행해야 하고 도메인 클래스 중 하나가 아니라면 도메인 이벤트를 사용할 필요가 없다는 점에 유의하십시오. 7장에서 기억하시겠지만, 컨트롤러는 도메인 모델과 프로세스 외부 종속성 간의 협업을 조정합니다. `DomainLogger`는 그러한 종속성 중 하나이므로 `UserController`는 해당 로거를 직접 사용할 수 있습니다.

또한 `User` 클래스가 진단 로깅을 수행하는 방식을 변경하지 않았다는 점도 주목하십시오. `User`는 여전히 `ChangeEmail` 메서드의 시작과 끝에서 로거 인스턴스를 직접 사용합니다. 이는 의도된 것입니다. 진단 로깅은 개발자만을 위한 것이므로 이 기능을 단위 테스트할 필요가 없으며 도메인 모델에서 제외할 필요도 없습니다.

그래도 가능한 경우 `User` 또는 다른 도메인 클래스에서 진단 로깅 사용을 자제하십시오. 다음 섹션에서 그 이유를 설명합니다.

### 8.6.3 로깅은 어느 정도면 충분한가?

또 다른 중요한 질문은 최적의 로깅 양에 대한 것입니다. 어느 정도의 로깅이면 충분할까요? 지원 로깅은 비즈니스 요구 사항이므로 논외입니다. 그러나 진단 로깅은 제어할 수 있습니다.

다음 두 가지 이유 때문에 진단 로깅을 과도하게 사용하지 않는 것이 중요합니다:

  * **과도한 로깅은 코드를 복잡하게 만듭니다.** 이는 특히 도메인 모델에 해당합니다. 그래서 단위 테스트 관점에서는 괜찮지만 `User`에서 진단 로깅을 사용하지 않는 것을 권장합니다. 코드를 모호하게 만들기 때문입니다.
  * **로그의 신호 대 잡음비가 핵심입니다.** 더 많이 로깅할수록 관련 정보를 찾기가 더 어려워집니다. 신호를 최대화하고 잡음을 최소화하십시오.

도메인 모델에서는 진단 로깅을 전혀 사용하지 않도록 노력하십시오. 대부분의 경우, 해당 로깅을 도메인 클래스에서 컨트롤러로 안전하게 옮길 수 있습니다. 그리고 그때조차도 무언가를 디버깅해야 할 때만 일시적으로 진단 로깅을 사용하십시오. 디버깅을 마친 후에는 제거하십시오. 이상적으로는 처리되지 않은 예외에만 진단 로깅을 사용해야 합니다.

### 8.6.4 로거 인스턴스를 어떻게 전달하는가?

마지막으로, 로거 인스턴스를 코드에서 어떻게 전달하는지에 대한 질문입니다. 이러한 인스턴스를 해결하는 한 가지 방법은 다음 목록에 표시된 대로 정적 메서드를 사용하는 것입니다.

**목록 8.8** `ILogger`를 정적 필드에 저장하기

```csharp
public class User
{
    private static readonly ILogger _logger =
        LogManager.GetLogger(typeof(User)); // 정적 메서드를 통해 ILogger 해결 및 private 정적 필드에 저장

    public void ChangeEmail(string newEmail, Company company)
    {
        _logger.Info(
            $"Changing email for user {UserId} to {newEmail}");
        /* ... */
        _logger.Info($"Email is changed for user {UserId}");
    }
}
```

스티븐 반 데어젠(Steven van Deursen)과 마크 시먼(Mark Seeman)은 그들의 책 『Dependency Injection Principles, Practices, Patterns』(Manning Publications, 2018)에서 이러한 유형의 종속성 획득을 \*\*앰비언트 컨텍스트(ambient context)\*\*라고 부릅니다. 이는 **안티 패턴**입니다. 그들의 두 가지 주장은 다음과 같습니다:

  * 종속성이 숨겨져 있고 변경하기 어렵습니다.
  * 테스트가 더 어려워집니다.

저는 이 분석에 전적으로 동의합니다. 그러나 저에게 앰비언트 컨텍스트의 주요 단점은 코드의 잠재적인 문제를 가린다는 것입니다. 로거를 도메인 클래스에 명시적으로 주입하는 것이 너무 불편하여 앰비언트 컨텍스트에 의존해야 한다면, 이는 문제의 확실한 신호입니다. 로깅을 너무 많이 하거나 너무 많은 간접 계층을 사용하는 것입니다. 어떤 경우든 앰비언트 컨텍스트는 해결책이 아닙니다. 대신 문제의 근본 원인을 해결하십시오.

다음 목록은 로거를 명시적으로 주입하는 한 가지 방법인 메서드 인수를 보여줍니다. 다른 방법은 클래스 생성자를 통하는 것입니다.

**목록 8.9** 로거를 명시적으로 주입하기

```csharp
public void ChangeEmail(
    string newEmail,
    Company company,
    ILogger logger) // 메서드 주입
{
    logger.Info(
        $"Changing email for user {UserId} to {newEmail}");
    /* ... */
    logger.Info($"Email is changed for user {UserId}");
}
```

-----

### 8.7 결론

모든 프로세스 외부 종속성과의 통신을 **이 통신이 애플리케이션의 관찰 가능한 동작의 일부인지 아니면 구현 세부 사항인지**의 관점에서 보십시오. 로그 저장소도 이 점에서 다르지 않습니다. 로그가 비프로그래머에 의해 관찰 가능한 경우 로깅 기능을 모의(mock) 처리하고, 그렇지 않은 경우 테스트하지 마십시오.

다음 장에서는 모의(mocking) 주제와 관련된 모범 사례에 대해 더 자세히 다룰 것입니다.

-----

### 요약

  * **통합 테스트는 단위 테스트가 아닌 모든 테스트**입니다. 통합 테스트는 시스템이 프로세스 외부 종속성과 통합되어 어떻게 작동하는지 검증합니다:
      * 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 알고리즘과 도메인 모델을 다룹니다.
      * 통합 테스트는 회귀에 대한 더 나은 보호와 리팩토링에 대한 저항력을 제공합니다. 단위 테스트는 더 나은 유지 관리성과 피드백 속도를 가집니다.
  * 통합 테스트의 기준은 단위 테스트보다 높습니다. 회귀에 대한 보호 및 리팩토링에 대한 저항력 지표에서 단위 테스트보다 높은 점수를 받아야 유지 관리성 및 피드백 속도 저하를 상쇄할 수 있습니다. 테스트 피라미드는 이러한 트레이드오프를 나타냅니다: 대부분의 테스트는 빠르고 저렴한 단위 테스트여야 하며, 시스템 전체의 정확성을 확인하는 느리고 비용이 많이 드는 통합 테스트는 소수여야 합니다:
      * 비즈니스 시나리오의 엣지 케이스를 가능한 한 많이 단위 테스트로 확인하십시오. 통합 테스트는 하나의 해피 경로와 단위 테스트로 커버할 수 없는 모든 엣지 케이스를 다루는 데 사용하십시오.
      * 테스트 피라미드의 모양은 프로젝트의 복잡성에 따라 달라집니다. 간단한 프로젝트는 도메인 모델에 코드가 거의 없으므로 단위 테스트와 통합 테스트의 수가 동일할 수 있습니다. 가장 사소한 경우에는 단위 테스트가 없을 수도 있습니다.
  * **Fail Fast 원칙**은 버그가 빠르게 드러나도록 옹호하며 통합 테스트에 대한 실행 가능한 대안입니다.
  * **관리되는 종속성**은 애플리케이션을 통해서만 액세스할 수 있는 프로세스 외부 종속성입니다. 관리되는 종속성과의 상호 작용은 외부에서 관찰할 수 없습니다. 일반적인 예는 애플리케이션 데이터베이스입니다.
  * **관리되지 않는 종속성**은 다른 애플리케이션이 액세스할 수 있는 프로세스 외부 종속성입니다. 관리되지 않는 종속성과의 상호 작용은 외부에서 관찰할 수 있습니다. 일반적인 예로는 SMTP 서버와 메시지 버스가 있습니다.
  * 관리되는 종속성과의 통신은 구현 세부 사항입니다. 관리되지 않는 종속성과의 통신은 시스템의 관찰 가능한 동작의 일부입니다.
  * 통합 테스트에서 관리되는 종속성의 실제 인스턴스를 사용하고, 관리되지 않는 종속성은 모의(mock)로 대체하십시오.
  * 때로는 프로세스 외부 종속성이 관리되는 종속성과 관리되지 않는 종속성 모두의 속성을 나타내기도 합니다. 일반적인 예는 다른 애플리케이션이 액세스할 수 있는 데이터베이스입니다. 종속성의 관찰 가능한 부분은 관리되지 않는 종속성으로 취급하십시오: 테스트에서 해당 부분을 모의로 대체하십시오. 종속성의 나머지 부분은 관리되는 종속성으로 취급하십시오: 그와의 상호 작용이 아닌 최종 상태를 확인하십시오.
  * 통합 테스트는 관리되는 종속성과 함께 작동하는 모든 계층을 통과해야 합니다. 데이터베이스 예시에서는 입력 매개변수로 사용된 데이터와 독립적으로 해당 데이터베이스의 상태를 확인하는 것을 의미합니다.
  * 단일 구현을 가진 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체적인 클래스보다 더 느슨한 결합을 제공하지 않습니다. 그러한 인터페이스에 대한 미래 구현을 예측하려고 시도하는 것은 YAGNI(You aren't gonna need it) 원칙을 위반합니다.
  * 단일 구현을 가진 인터페이스를 사용하는 유일한 정당한 이유는 모의(mocking)를 가능하게 하기 위함입니다. 이러한 인터페이스는 관리되지 않는 종속성에만 사용하십시오. 관리되는 종속성에는 구체적인 클래스를 사용하십시오.
  * 프로세스 내 종속성에 사용되는 단일 구현을 가진 인터페이스는 위험 신호입니다. 이러한 인터페이스는 도메인 클래스 간의 상호 작용을 확인하기 위해 모의를 사용함을 암시하며, 이는 코드의 구현 세부 사항에 테스트를 결합하게 만듭니다.
  * 코드베이스에서 도메인 모델에 대해 명시적이고 잘 알려진 위치를 가지십시오. 도메인 클래스와 컨트롤러 간의 명시적인 경계는 단위 테스트와 통합 테스트를 구별하기 쉽게 만듭니다.
  * 과도한 수의 간접 계층은 코드에 대한 추론 능력에 부정적인 영향을 미칩니다. 가능한 한 간접 계층을 적게 가지십시오. 대부분의 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층의 세 가지만으로도 충분합니다.
  * 순환 종속성은 코드를 이해하려고 할 때 인지 부하를 추가합니다. 일반적인 예는 콜백(호출된 개체가 호출자에게 작업 결과를 알리는 경우)입니다. 값 객체를 도입하여 순환을 끊으십시오. 해당 값 객체를 사용하여 호출된 개체에서 호출자로 결과를 반환하십시오.
  * 테스트에서 여러 `Act` 섹션은 해당 테스트가 원하는 상태로 만들기 어려운 프로세스 외부 종속성과 함께 작동할 때만 정당화됩니다. 단위 테스트는 프로세스 외부 종속성과 함께 작동하지 않으므로 단위 테스트에서는 여러 `Act`를 가져서는 안 됩니다. 다단계 테스트는 거의 항상 엔드투엔드 테스트 범주에 속합니다.
  * **지원 로깅**은 지원 스태프와 시스템 관리자를 위한 것입니다. 이는 애플리케이션의 관찰 가능한 동작의 일부입니다. **진단 로깅**은 개발자가 애플리케이션 내부에서 무슨 일이 일어나고 있는지 이해하는 데 도움이 됩니다. 이는 구현 세부 사항입니다.
  * 지원 로깅은 비즈니스 요구 사항이므로, 해당 요구 사항을 코드베이스에 명시적으로 반영하십시오. 비즈니스에 필요한 모든 지원 로깅을 나열하는 특별한 `DomainLogger` 클래스를 도입하십시오.
  * 지원 로깅을 프로세스 외부 종속성과 함께 작동하는 다른 기능과 동일하게 취급하십시오. 도메인 모델의 변경 사항을 추적하기 위해 도메인 이벤트를 사용하십시오. 컨트롤러에서 해당 도메인 이벤트를 `DomainLogger` 호출로 변환하십시오.
  * 진단 로깅은 테스트하지 마십시오. 지원 로깅과 달리, 진단 로깅은 도메인 모델에서 직접 수행할 수 있습니다.
  * 진단 로깅은 간헐적으로 사용하십시오. 과도한 진단 로깅은 코드를 복잡하게 만들고 로그의 신호 대 잡음비를 손상시킵니다. 이상적으로는 처리되지 않은 예외에만 진단 로깅을 사용해야 합니다.
  * 모든 종속성(로거 포함)을 항상 생성자를 통해 또는 메서드 인수로 명시적으로 주입하십시오.
