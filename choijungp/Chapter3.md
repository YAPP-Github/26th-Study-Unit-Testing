# 3장. 단위 테스트의 해부학

## 3.1 단위 테스트를 어떻게 구성할 것인가

### **AAA 패턴**

테스트를 Arrange (준비), Act (실행), Assert(검증)로 나누어 진행하는 것을 뜻한다.    
- Arragne (준비): 테스트 대상 (SUT)과 그 의존성을 원하는 상태로 준비한다.
- Act (실행): SUT에 메서드를 호출하고 준비한 의존성을 전달하며, 출력값을 수집한다.
- Assert(검증): 결과를 검증한다. 리턴 값, SUT의 최종 상태 또는 SUT가 호출한 메서드 등이 될 수 있다.

장점
- 모든 테스트가 일관된 구조를 가지므로 어떤 테스트든 쉽게 읽고 이해할 수 있다.
- 테스트 전체의 유지 비용을 감소하는데 도움을 준다.

<br>

### **Give-When-Then 패턴**

- Given: AAA의 Arrange와 동일
- When: AAA의 Act와 동일
- Then: AAA의 Assert와 동일

<details>
<summary>그렇다면 .. AAA 패턴과 Given-When-Then 패턴의 차이점이 뭐지 … ??</summary>
<div markdown="1">

AAA는 **코드를 명확히 정리하는 개발자 중심의 패턴**,  
Given-When-Then은 **테스트를 비즈니스 시나리오처럼 표현하는 비개발자 친화적 패턴**이다.

</div>
</details>

<br>
  
### 테스트 코드 주의 사항
- TDD를 할 때에는 기능이 존재하지 않기 때문에 무엇을 기대할지부터 생각하고 Assert를 먼저 작성하는 것도 좋은 전략이다.  
이미 프로덕션 코드를 작성한 후 테스트를 진행한다면, 이미 기대 동작을 알고 있으므로 Arrange부터 시작하는 것이 더 자연스럽다.

- 이때 Act의 구간이 Assert와 Arrange로 나누어져 있다면 이것은 단위 테스트가 아니라 통합 테스트에 해당한다.
- 단일 행위만 포함할 때의 테스트를 단위 테스트로 보며 이는 간단하고 빠르며 더 이해하기 쉬워진다.
- if문 사용을 지양해야 한다.
    - 단위 테스트든 통합 테스트 든 간에 분기 없기 단순한 순차적 단계들의 나열이어야 한다.
    - 분기처리가 있다는 것은 테스트가 한 번에 많은 검증 검증하고 있다는 뜻이다.
- 보통 Arrage 섹션이 가장 큰 섹션이지만, 지나치게 길어진다면 private 메서드나 팩토리 클래스로 분리하는 것을 추천한다.
- Act 섹션은 1줄이 이상적이다.
    - 2줄 이상이라면 SUT의 API에 문제가 있다는 신호이다. (캡슐화 Xx)
- 보통 하나의 행동이 여러 결과를 만들어낼 수 있기 때문에 Assert 섹션에는 여러 개의 검증이 있어도 된다.
    - 하지만 너무 커지는 Assert 섹션은 주의해야 한다.
- 단위 테스트는 외부 프로세스 종속성과 상호작용 하지 않기 때문에 정리해야 할 부작용이 남지 않기 때문에 Teardown (정리)단계가 필요 없다.
    - 정리의 단계는 통합 테스트의 영역이다.
- 테스트 대상 시스템과 그 외의 의존성을 구분하는 것이 중요하다. 따라서 테스트 시 SUT는 sut라는 변수명을 추천한다.
- `// Arrange` , `// Act` , `// Assert` 라는 주석 대신 빈 줄을 추천한다.      

<br>

## 3.3 여러 테스트 간 테스트 픽스처 재사용하기

> Test Fixture (테스트 픽스처)란 ?       
테스트를 실행하기 위해 공통적으로 준비해야 하는 상태나 환경 (ex. 객체 초기화, DB 연결, 더미 데이터 세팅 등)             
테스트 실행되기 전마다 **항상 동일하고 예측 가능한 상태를 유지**해야 한다.
> 

Setup 단계를 사용하면 테스트의 Arrange 섹션이 동일하게 되고, 이를 별도의 클래스로 추출할 수 있다.           
코드가 간결해지는 장점이 있지만, 테스트 간의 높은 결합도와 가독성이 떨어지는 단점을 야기한다.        

- 테스트 간 높은 결합도는 안티 패턴이다.
    - 테스트 설정을 수정하면 모든 테스트에 영향을 미치게 되므로 불필요한 테스트 실패가 발생할 수 있다.
    - 하나의 테스트를 수정해도 다른 테스트에 영향을 주어선 안된다. (수정의 독립성)
    - 이 원칙을 지키기 위해 테스트 내에 공유 상태를 도입하면 안된다.

- 생성자에 설정 코드를 넣으면 코드의 가독성이 떨어진다.
    - 테스트 메서드만을 통해 전체 테스트 흐름을 이해하기 어려워진다.

그렇다면 더 나은 픽스처 재사용 방법은 **테스트 클래스 내에 private 팩토리 메서드를 도입하는 것**이다.            
- 팩토리 메서드를 사용하면 테스트의 문맥을 유지하면서도 코드도 간결하게 만들 수 있고, 테스트 간 공유 상태도 발생하지 않는다.

<br>

## 3.4 단위 테스트에 이름 짓기

테스트의 적절한 이름은 **해당 테스트가 무엇을 검증하고, 시스템이 어떻게 동작하는지를 이해**하는 데 큰 도움이 된다.

단순 **자연어 문장**으로 작성한 이름이 효과적이다.    
- 엄격한 네이밍 규칙을 따르지 않는다. 표현의 자유 허용
- 도메인을 잘 아는 비개발자에게 시나리오를 설명하듯이 짓는다.
- 단어는 `_`로 구분한다.
- 테스트 이름에 SUT의 메서드 명을 넣지 않는다. 테스트는 코드가 아니라 행동을 검증하는 것이다.

<br>

## 3.5 매개변수화된 테스트로 리팩토링하기

파라미터화 된 테스트를 사용하면 테스트 코드 양은 줄일 수 있지만 테스트 메서드가 어떤 사실들을 나타내는지 파악하기 어려워진다. 

긍정적인 테스트 케이스는 별도의 테스트로 분리하여 가장 중요한 부분에서 설명적인 이름을 붙이는 이점을 누릴 수 있다.
