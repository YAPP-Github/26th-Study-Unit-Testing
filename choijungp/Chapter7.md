# 7장. 가치 있는 단위 테스트를 향한 리팩터링

**좋은 단위 테스트의 속성**

- 개발 사이클에 통합되어 있어야 한다.
- 코드 베이스에서 가장 중요한 부분만을 대상으로 해야 한다.
- 최소한의 유지보수 비용으로 최대의 가치를 제공해야 한다.
    - 가치 있는 테스트를 구별하고, 작성할 수 있어야 한다.

<br>

## 7.1 리팩터링할 코드를 식별하기

프로덕션 코드는 두 가지 기준에 따라 분류할 수 있다.
- 복잡도 또는 도메인 중요도
- 협력 객체(Collaborator)의 수

<br>

**도메인 중요도**       
코드가 프로젝트의 문제 영역과 얼마나 밀접하게 관련되어 있는지를 나타낸다. (특히 도메인 레이어 부분의 코드)    
도메인 중요도가 높은 코드는 회귀로부터의 보호 효과가 크기 때문에 단위 테스트의 이점을 가장 많이 누릴 수 있다.

<br>

**협력 객체(Collaborator)의 수**      
협력 객체는 변경 가능하거나 프로세스 외부에 존재하는 의존성을 뜻한다.     
협력 객체가 많을수록 테스트는 더 비싸지고 유지보수성이 떨어지게 된다.         
협력 객체의 종류도 중요한데, 프로세스 외부 의존성은 도메인에서 사용하지 않는 것이 좋다.        

<br>

**네 가지 코드 유형**
- **도메인 모델 및 알고리즘**
    - 도메인 중요도가 높고, 협력 객체의 수가 적음
    - 단위 테스트를 통해 가장 큰 효과를 얻을 수 있음 → 가치가 높고 유지 비용이 적음
- **단순한 코드**
    - 복잡성이나 도메인 중요도가 낮고, 협력 객체도 거의 없음
    - 아무런 가치를 주지 않기 때문에 테스트를 하지 않는 것이 좋음
- **컨트롤러**
    - 복잡하거나 비즈니스 핵심 작업을 수행하진 않지만, 도메인 클래스나 외부 시스템 등 다른 구성 요소들의 작업을 조율하는 역할을 함
    - 단위 테스트보다는 통합 테스트로 간단히 테스트를 진행하는 것이 좋음ㅁ
- **과도하게 복잡한 코드**
    - 코드 자체가 복잡하거나 중요한 역할을 하고 협력 객체가 많음 (ex. fat controller)
    - 과도하게 복잡한 코드를 알고리즘, 컨트롤러 두 부분으로 나눠 도메인 모델과 알고리즘에 대해서만 단위 테스트를 진행

<br>

**Humble Object 패턴을 활용한 코드 분리**
- 과도하게 복잡한 코드를 분리하려면, Humble Object 디자인 패턴을 사용해야 한다.
- 복잡한 코드에서 핵심 로직을 분리, 그렇게 된다면 기존 코드는 humble 코드가 되어 자체적으로는 테스트할 필요가 없게 된다.
- 함수형 아키텍처의 함수형 코어와 도메인 레이어는 도메인 모델 및 알고리즘에 속한다.
    - 특히 함수형 코어는 협력 객체가 아예 없음
- mutable shell이나 서비스 레이어는 컨트롤러 영역에 속한다.
- Humble Object 패턴은 SRP를 따르는 하나의 방식으로 이해할 수 있다.         
(하나의 클래스는 하나의 책임만 가져야 한다. → 책임 중 하나가 비즈니스 로직이 된다.)

<br>

비즈니스 로직과 오케스트레이션을 분리할 때 코드의 깊이와 너비 관점으로 생각해볼 수 있다.    
- **깊은 코드**: 복잡하거나 중요한 로직을 담고 있음 (ex. 도메인 클래스)
- **넓은 코드**: 많은 협력 객체와 상호작용함 (ex. 컨트롤러)

<br>

비즈니스 로직과 오케스트레이션을 분리한 예시       
- **MVP, MVC**: 비즈니스 로직과 UI, 그 둘 사이의 조율을 분리하고 있다.
- **Domain-Driven Design의 Aggregate 패턴**: 클래스를 클러스터로 묶어 클래스 간 연결성을 줄인다.

<br>

비즈니스 로직과 오케스트레이션을 분리하면 얻는 이점    
- 테스트 용이성 향상
- 코드 복잡도를 제어에 효과적
- 프로젝트가 장기적으로 성장해 나가기 위해서도 중요 → 유지보수가 쉬운 구조가 됨

<br>

## 7.2 가치 있는 단위 테스트를 위한 리팩터링

**고객 관리 시스템 (CRM)의 User 클래스**
- 사용자 이메일을 변경하는 책임 → 코드의 복잡도는 높지 않지만 중요한 비즈니스 로직임
- 2개의 명시적 의존성(`userId`, `newEmail`)과 2개의 암묵적 의존성 (`Databass`, `MessageBus`)
- 그렇게 되어 User 클래스는 과도하게 복잡한 코드 범주에 속하게 된다.

<br>

1. **암묵적 의존성을 명시적으로 변경하기**         
    `Databass`, `MessageBus` 에 대한 인터페이스를 정의하고, User 클래스에 주입한 다음 테스트에서는 mock을 사용하는 방식          
    결과적으론 여전히 프로세스 외부 의존성이 있기 때문에 본질은 동일하다. → 테스트의 불안정성으로 이어질 수 있다.
    
<br>

2. **애플리케이션 서비스 레이어 도입**           
도메인 모듈이 외부 시스템과 직접 통신하는 문제를 해결하기 위해 해당 책임을 별도의 클래스로 옮긴다.         
다만, 아직 몇가지 문제점이 존재한다.
    - `Databass`, `MessageBus` 같은 외부 의존성이 직접 인스턴스화 되어 있음
    - 컨트롤러가 데이터베이스에서 받은 원시 데이터를 기반으로 User 인스턴스를 복원하고 있음
    - User 클래스가 직원 수 변경 결과를 반환하고 있음
    - 새 이메일이 기존 이메일과 같든 다르든 무조건 데이터 저장과 알림 전송을 수행함

<br>

3. **애플리케이션 서비스에서 복잡도 제거하기**       
    복원 로직을 ORM에 위임하거나 도메인 모델 내부에 팩토리를 만들어서 데이터베이스의 원시 데이터를 기반으로 도메인 객체를 생성한다. (`UserFactory`)    
    복원 로직은 약간의 복잡성은 있지만 도메인 중요도는 없다.    
    
<br>

4. **새로운 Company 클래스 도입**    
    User가 직원수 변경 결과를 반환하는 구조가 되어 있는데 이는 책임이 잘못 배치되어 있다는 신호이다.     
    따라서 회사 관련 데이터와 로직을 묶어줄 새로운 도메인 클래스 Company를 도입해야 한다.       
    User가 회사 데이터를 직접 다루는 대신, 이메일이 회사 도메인인지 판단하는 작업, 직원 수를 변경하는 작업을 Company 클래스에 위임한다.
    
<br>

## 7.3 최적의 단위 테스트 커버리지 분석
복잡하고 도메인적으로 중요하지만 협력 객체가 적은 코드를 최우선 테스트 대상으로 한다.          
(ex. `User.ChangeEmail(newEmail, company)` , `Company.ChangeNumberOfEmployees(delta)` )

- 도메인적으로 의미 있는 전제 조건은 테스트 해야 하지만,
- 도메인 의미가 없는 전제 조건은 굳이 테스트할 필요가 없다.

<br>

## 7.4 컨트롤러에서 조건 분기 로직 다루기
**조건 분기 로직**을 다루면서 동시에 **도메인 레이어를 외부 시스템과 분리된 상태로 유지하는 것**은 쉽지 않고, 여러 트레이트 오프를 수반한다.       
비즈니스 로직과 오케스트레이션을 분리하는 구조는 
**1) 저장소에서 데이터를 읽어오고, 
2) 비즈니스 로직을 실행하고, 
3) 처리된 데이터를 다시 저장소에 저장하는 과정**에서 명확하게 구분된다.

하지만 이 세 단계가 명확하게 나뉘지 않는 경우도 많다.     
그러한 경우 선택할 수 있는 세 가지 접근 방식이 있다.
1. **외부 시스템과 통신을 비즈니스 연산의 시작 또는 끝에 몰아넣기**
    - 필요하지 않은 경우에도 외부 시스템 호출이 발생하므로 성능 저하가 발생할 수 있다.
    - 현실적으로 성능이 중요한 프로젝트가 많기 때문에 현실적이지 않다.
2. **도메인 모델에 외부 의존성을 직접 주입**
    - 도메인 모델 테스트 용이성이 크게 감소된다.
    - 도메인 모델을 과도하게 복잡하게 만들며 초기 CRM 구조로 회귀하게 된다.
3. **의사 결정 과정을 더 세분화하여 컨트롤러에서 각각 처리 ✅**
    - 테스트성과 성능을 확보할 수 있지만 컨트롤러 로직이 복잡해지고 관리가 어려워진다.
    - 컨트롤러가 복잡해질 수 있지만 CanExecute / Execute 패턴을 사용해서 관리 가능한 수준으로 유지할 수 있다.

<br>

**CanExecute / Execute 패턴**
- 도메인 모델의 비즈니스 로직이 컨트롤러로 새어나가는 것을 막는데 유용하다.
- 모든 결정 로직이 도메인에 집중되어 있고, 컨트롤러는 단순한 액터 역할을 한다.

**도메인 이벤트 패턴**
- 외부 시스템 통신 시점을 정확히 제어하는 방법
- 실제 변경이 일어났을 때만 외부 통신 발생
- 도메인 로직 분산 방지
- mock 객체 없이 테스트 가능

<br>

## 7.5 결론
관찰 가능한 행위와 구현 세부사항을 겹겹이 존재하는 층으로 생각하자. (like 양파 🧅)     
각 계층을 바깥 계층의 관점에서 테스트하고, 그 계층이 어떻게 통신하는지는 알 필요가 없다.     
