# 8장. 통합 테스트는 왜 필요한가  
- 단위 테스트는 비즈니스 로직을 검증하는데는 훌륭하지만, 단위 테스트로만은 시스템 전체가 제대로 작동하는지 확인하기 어렵다.

<br>

## 8.1 통합 테스트란 무엇인가?

단위 테스트의 요구사항    
- 단일 동작 단위를 검증한다.
- 빠르게 수행한다.
- 다른 테스트와 격리하여 수행한다.

→ 이 중 적어도 하나를 충족하지 못하면 통합 테스트 (즉, 단위 테스트가 아닌 모든 테스트를 의미)

<br> 

- 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 도메인 모델과 알고리즘을 다룬다.
- 단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요하다.
- 비즈니스 시나리오의 엣지 케이스를 가능한 많이 단위 테스트로 확인하고,   
  통합 테스트는 하나의 해피 경로와 단위 테스트로 커버할 수 없는 모든 엣지 케이스를 다루는데 사용
- 대부분의 작업을 단위 테스트로 전환하고 동시에 비즈니스 시나리오 당 한 두개의 포괄적인 통합 테스트
    → 유지 보수 비용을 낮게 가져가면서도 시스템 전체의 정확성을 보장
    
- 통합 테스트는 더 많은 양의 코드를 통과하므로 회귀로부터 보호하는데 있어 단위 테스트보다 더 좋다.
- 또한 프로덕션 코드와 더 분리되어 있으므로 리팩토링에 해단 저항력이 강하다.

- 통합 테스트의 경우, 모든 프로세스 외부 종속성과의 상호 작용을 검증하기 위해 가장 긴 해피 경로를 선택한다.
    - 즉, 모든 상호 작용을 통과하는 단일 경로를 통합 테스트 한다.
    - 그런 단일 경로가 없다면 모든 외부 시스템과의 통신을 캡처하는데 필요한만큼 추가 통합 테스트를 작성한다.

<br>

**Fast Fail** 
- 예상치 못한 오류가 발생하는 즉시 현재 작업을 중단
- **피드백 루프 단축, 지속성 상태 보호**를 통해 어플리케이션을 더 안정적으로 만든다.
    - 피드백 루프 단축: 버그를 일찍 발견할수록 수정하기가 쉽다.
    - 지속성 상태 보호: 버그는 어플리케이션 상태를 손상시키므로 Fast Fail을 통해 손상이 확산되는 것을 방지한다.

```swift
guard let loginViewModel = DIContainer.shared.resolve(type: LoginViewModel.self) else {
    fatalError("loginViewModel 의존성이 등록되지 않았습니다.")
}
let loginView = LoginView(viewModel: loginViewModel)
self?.navigationController?.pushViewController(loginView, animated: true)
```

<br>

## 8.2 어떤 프로세스 외부 종속성을 직접 테스트 해야 하는가?  
- 모든 프로세스 외부 종속성은 두 가지 범주로 나뉜다.
    - 관리되는 종속성 (완전히 제어할 수 있는 프로세스 외부 종속성, ex. DB) → 구현 세부사항
    - 관리되지 않는 종속성 (완전히 제어할 수 없는 프로세스 외부 종속성, ex. SMTP 서버, 메시지 버스) → 관찰 가능한 동작의 일부

- 관리되는 종속성은 실제 인스턴스를 사용하고, 관리되지 않는 종속성은 모의로 대체한다.

<br>

## 8.3 통합 테스트: 예시

- 통합 테스트는 가장 긴 해피 경로와 단위 테스트로 실행할 수 없는 모든 엣지 케이스를 커버한다.  
- 엔드 투 엔드 테스트
    - 배포되고 완전히 작동하는 API 버전에 대해 실행되는 테스트로, 모든 프로세스 외부 종속성에 대한 모의가 없음을 의미
    - 통합 테스트와가 엔드 투 엔트 테스트와 대부분 동일한 수준의 보호를 제공하므로 사용할지 여부를 판단해서 정한다.

<br>

## 8.4 종속성 추상화를 위한 인터페이스 사용
- 종종 인터페이스를 과도하게 사용하는 경향이 있음
- 데이터베이스나 메시지 버스와 같은 프로세스 외부 종속성에 대해 단 하나의 구현만 가지고 있더라도 인터페이스를 도입하는 경우가 있다.
    - 추상화를 통해 느슨한 결합을 달성한다.
    - 기존 코드를 변경하지 않고 새로운 기능을 추가하여 OCP를 준수한다.
- BUT, 단일 구현을 가진 인터페이스는 추상화가 아니며, 더 느슨한 결합을 제공하지 않는다.
- **YAGNI (You aren’t gonna need it)** → 당장 필요하지 않은 기능에 시간을 투자하는 것을 반대한다.

- 근데 왜 프로세스 외부 종속성에 인터페이스를 사용할까 ??
    - mocking을 가능하게 하기 위해서 !! → 관리되지 않는 종속성에만 인터페이스를 사용하자
    - 인터페이스가 없으면 테스트 더블을 생성할 수 없음 ..
    - 만약 해당 종속성을 모의 처리해야 할 필요가 없다면 프로세스 외부 종속성에 대한 인터페이스를 도입하지 말자.

```swift
public final class NetworkService: NetworkServiceProtocol {
    private let networkProvider: NetworkProviderProtocol
    private let decoder = JSONDecoder()

    public init(networkProvider: NetworkProviderProtocol = URLSession.shared) {
        self.networkProvider = networkProvider
    }


public protocol NetworkProviderProtocol {
    func data(for urlRequest: URLRequest) async throws -> (Data, URLResponse)
}
```
 
<br>

## 8.5 통합 테스트 모범 사례
- 통합 테스트에 도움이 되는 지침
    - 도메인 모델 경계를 명시적으로 만들기
    - 애플리케이션의 계층 수 줄이기
    - 순환 종속성 제거하기

- 도메인 모델 경계를 명시적으로 만들기
    - 도메인 모델에 대해 항상 명시적으로 잘 알려진 위치를 갖도록 하자.
- 계층 수 줄이기
    - 간접 계층은 코드에 대한 추론 능력에 부정적인 영향을 미친다.
    - 과도한 수의 추상화는 단위 또는 통합 테스트에도 도움이 되지 않는다.
    - 가능한 간접 계층을 적게 가지도록 노력하자 !!
- 순환 종속성 제거하기
    - 순환 종속성: 직접 또는 간접적으로 서로 의존하는 둘 이상의 클래스
    - 코드를 읽고 이해하려고 할 때 엄청난 인지 부하를 추가한다. → 솔루션을 탐색하기 시작하는 명확한 시작점을 제공하지 않기 때문에 ..
    - 

테스트에서 여러 Act 섹션 사용하기
>
> - **Arrange** — 사용자를 등록할 데이터를 준비합니다.
> - **Act** — `UserController.RegisterUser()`를 호출합니다.
> - **Assert** — 데이터베이스를 쿼리하여 등록이 성공적으로 완료되었는지 확인합니다.
> - **Act** — `UserController.DeleteUser()`를 호출합니다.
> - **Assert** — 데이터베이스를 쿼리하여 사용자가 삭제되었는지 확인합니다.

각 Act를 별도의 테스트로 추출하여 테스트를 분할하는 것이 가장 좋다.


<br>

## 8.6 로깅 기능 테스트 방법  
- 로깅을 테스트 해야 하는가 ?
    - 로깅이 애플리케이션의 관찰 가능한 동작의 일부인가, 아닌 구현 세부사항인가
    - 만일 클라이언트, 또는 개발자 외 다른 사람에 의해 관찰되도록 의도한 경우는 로깅은 관찰 가능한 동작이므로 테스트 되어야 한다.
    - 하지만 로깅의 유일한 대상이 개발자인 경우 구현 세부사항이므로 테스트해서는 안된다.

- 그렇다면 로깅을 테스트 해야 한다면 어떻게 해야 할까 ?
    
    → mock 사용
