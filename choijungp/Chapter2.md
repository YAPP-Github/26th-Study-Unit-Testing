## 2장. 단위 테스트란 무엇인가

### 2.1 단위 테스트의 현재 상황

> 단위 테스트는 다음과 같이 자동화된 테스트이다.  
>  - 코드의 작은 조각(unit)을 검증하고
>  - 빠르게 실행되며
>  - 독립적으로 수행된다.

<br>

**격리 문제: 런던파의 관점**

**테스트 대상을 그 협력자들로부터 격리시키는 것**이라고 표현한다.        
즉, 어떤 클래스가 다른 클래스에 의존하고 있다면 **그 모든 의존성을 테스트 대역으로 대체**해야 한다.       
→ 외부의 모든 영향으로부터 해당 클래스의 동작을 분리함으로써 테스트 대상 클래스에만 집중할 수 있게 된다.     


장점
- 테스트가 실패했을 때 어떤 코드가 잘못되었는지 명확히 알 수 있다.
- 복잡하게 연결된 클래스들 사이의 관계를 잘게 나눠서, 문제를 작게 쪼개고 각각의 역할만 독립적으로 테스트할 수 있게 된다.
- 테스트 대역을 사용하면 직접적인 의존성만 대체하고 다른 의존성까지 다룰 필요가 없어지므로
재귀적인 연결 경로를 끊어 테스트 하기 쉬워진다.
- “한 번에 하나의 클래스만 테스트한다.” 라는 가이드 라인을 도입할 수 있게 된다.

<br>

**격리문제: 클래식 접근 방식**

클래식 방식에서는 코드  자체가 격리된 방식으로 테스트 되어야 하는 것이 아니라, **단위 테스트들 간의 실행이 서로 격리되어야 한다는 것**이다.

테스트 간의 격리는     
여러 클래스를 동시에 테스트해도 무방하지만, 이 클래스들이 모두 메모리 상에 존재해야 하고 테스트 간에 상호작용할 수 있는 공유 상태를 참조하지 않아야 한다.

각 테스트에서 새 인스턴스를 생성할 수 있다면 공유되는 것이 아니다.   
반면, 파일시스템이나 데이터베이스와 같은 것은 새로 만들 수 없기 때문에 테스트 사이에서 공유되거나 테스트 대역으로 대체되어야 한다.

<br>

**런던파와 클래식파의 테스트 방식**

런던파는 Store 실제 인스턴스를 생성하는 것이 아닌 **mock 대체 객체를 만들어 테스트를 진행**한다.

클래식파는 **mock 객체를 사용하는 것이 아닌 실제 사용 가능한 인스턴스를 사용**한다.
따라서 예시로 확인한 코드에서 Store에 버그가 존재한다면 Customer에게도 영향을 주기 때문에 Customer가 올바르게 동작하고 있더라도 이 테스트는 실패하게 된다.

<br>


<details>
<summary>mock과 stub의 차이점</summary>
<div markdown="1">

- mock은 테스트 대역의 하위 집합이다.
- 종종 test double과 mock을 동의어처럼 사용하지만, 기술적으로 다르다.
- test double은 프로덕션 수준이 아닌 의존성을 통칭하는 넓은 개념이고, mock은 그 중 한 종류이다.

</div>
</details>


<details>
<summary>AAA</summary>
<div markdown="1">

Arrange (준비) → Act (실행) → Assert (검증)

</div>
</details>

---

### 2.2 단위 테스트의 클래식 학파와 런던 학파

런던파와 클래식파의 차이점의 근본은 **“격리 (isolation)”** 속성에 있다. 
- 런던파는 이를 ‘**테스트 대상 시스템을 그 협력자들로부터 격리하는 것**’으로 본다면,
- 클래식파는 이를 ‘**개별 단위 테스트끼리 서로 영향을 미치지 않도록 격리하는 것**’으로 본다.

<br>

두 학파 간의 의견 차이는 다음과 같은 주제를 다룬다.
- 격리 요구사항
- 테스트 대상 코드가 무엇으로 구성되는지
- 의존성을 어떻게 다룰 것인지

| 구분 | **isolation of** (격리의 대상) | **a unit is** (단위란) | **uses test doubles for** (테스트 대역 사용 대상) |
| --- | --- | --- | --- |
| **London School** | 단위(유닛) | 클래스 하나 | 불변 의존성을 제외한 **모든 의존성**에 테스트 대역 사용 |
| **Classical School** | 단위 테스트 | 클래스 하나 또는 클래스들의 집합 | **공유 의존성**에만 테스트 대역 사용 |

---

### 2.3 클래식파와 런던파의 단위 테스트 비교

클래식파와 런던파의 가장 큰 차이는 단위 테스트 정의에서 “**격리 (isolation)**”을 어떻게 다루는지에 있다.        
    
이 차이는 결국 테스트 대상이 되는 단위를 어떻게 정의하고, 의존성을 처리하는 방식에도 영향을 미친다.

<br>

런던파의 장점
- 더 나은 세분화
    - 테스트가 미세한 단위로 이루어져 있어 한 번에 한 클래스만 검사한다.
    - 런던파는 단위 테스트에서 클래스를 단위(unit)로 본다.
    - 테스트가 단 하나의 행위 단위를 검사하는 한 좋은 테스트지만 더 나은 코드 세분화만을 목표로 하는 것은 큰 도움이 되지 않는다.
- 모든 협력 객체를 테스트 더블로 대체하므로 테스트 작성 시 고려해야 할 사항이 줄어든다.
    - 테스트 더블을 사용하면 클래스의 직접 의존성들을 대체할 수 있어 그래프를 줄일 수 있지만,
    - 근본적으로 클래스 그래프 자체가 생기지 않는 것에 집중해야 한다.
- 테스트 실패 시 어떠한 기능이 실패하였는지 확실히 알 수 있다.
    - 테스트를 규칙적으로 실행한다면 버그의 원인을 파악하기 어렵지 않다.

<br>

런던파와 클래식파의 차이점
- TDD에서의 시스템 설계 접근법
    - 런던파의 단위 테스트는 외부-내부 TDD를 이끈다.
- 과도한 명세의 문제
    - 테스트가 SUT의 구현 세부사항에 너무 결합된다.
    - 런던파는 클래식파보다 구현에 더 자주 결합된 테스트를 만드는 경향이 있다.

<br>


<details>
<summary>TDD</summary>
<div markdown="1">

- 실패하는 테스트를 작성하여 어떤 기능을 추가해야 하고 어떻게 동작해야 하는지 표시한다.
- 테스트가 통과할 만큼의 최소한의 코드를 작성한다.
- 코드를 리팩토링한다. 통과하는 테스트의 보호 아래 코드를 더 읽기 쉽고 유지보수하기 좋게 정리한다.

</div>
</details>


<details>
<summary>🤫 이 책의 저자의 선호 방식은 !!??</summary>
<div markdown="1">

이 책의 저자는 클래식파를 더 선호한다.     
(mock을 사용하는 테스트가 클래식파보다 더 깨지기 쉽기 때문에, 클래식파가 대체로 더 높은 품질의 테스트를 만들어낸다고 한다.)   

</div>
</details>

---

### 2.4 두 학파의 통합 테스트

런던파와 클래식파는 통합 테스트의 정의에서도 차이를 보인다.      

런던파는 **실제 협력 객체를 사용하는 모든 테스트를 통합 테스트**로 간주한다.

클래식파의 단위 테스트는     
- 하나의 동작 단위를 검증하고
- 빠르게 실행하며
- 다른 테스트와 분리되어 고립되어 실행된다.

클래식파의 통합 테스트는 **이 조건 중 하나라도 충족하지 않는 테스트**이다.

<br> 

즉, **통합 테스트는 코드가 공유 종속성, 프로세스 외부 종속성 혹은 조직 내 다른 팀이 개발한 코드와 통합하여 작동하는지 검증하는 테스트**이다.

end-to-end 테스트는 통합 테스트의 하위 집합으로 프로세스 외부 종속성과 코드가 어떻게 작동하는지 검증한다.     
end-to-end 테스트가 통합 테스트에 비해 훨씬 많은 종속성을 포함한다. (UI 테스트, GUI테스트, 기능 테스트 등)     

<br>

## 느낀점

클래식파와 런던파에 대해 처음 알았다 ….. ….. (쿠궁)

기존에 테스트를 진행할 때 Mock 객체를 만들어 테스트를 진행했었는데 알고보니 런던파의 방식으로 테스트를 진행했던 것이었다. ..

2장 초반부를 읽을 때에는 mock 객체는 확실히 의존 관계를 끊어내고 해당 기능만을 테스트하는 것이니까 좋은 테스트 방법이라고 생각했는데 후반부에서 클래식파의 테스트 방식에 약간 더 많은 관심이 갔다.

사실 아직 클래식파의 방식? 으로 테스트를 진행해 본 적이 없어서 1000% 이해했다고 말하긴 어렵지만,   

테스트를 진행한다면 꼭 mock 객체만을 고집하지 않고 의존성을 덜어내고 테스트를 진행할 수 있는 방안을 고려해봐야겠다는 생각을 했다.

[2장 해석본 (w/GPT)](https://www.notion.so/2-201a2bc44c1c8094a14ddd1ec38ed348?pvs=21)
