# 5장. Mock과 테스트 취약성

## 5.1 Mock과 Stub

### 테스트 대역
> 테스트에서 사용되는 모든 fake 의존성을 뜻한다.         
> 실제로 설정하거나 유지하기 어려운 의존성 대신, 테스트 대역을 통해 테스트를 용이하게 하는 것이 목적이다.

- 테스트 대역에는 dummy, stub, spy, mock, fake가 있다.
- Mock (mock, spy) / Stub (stub, dummy, fake)

  
- **Mock**
  - SUT와 의존성 간의 상호작용을 흉내내고 검증하는데 도움을 준다.
  - ex) email을 보내는 것
- **Stub**
  - 내부로 향하는 상호작용을 흉내내는데 사용된다. 
  - ex) 데이터베이스에서 데이터를 가져오는 것

- mock과 spy의 차이점은
  - spy는 수동으로 작성하고, mock은 mocking 프레임워크를 통해 생성된다.
      
- stub, dummy, fake의 차이는 얼마나 지능적인지에 있다.
  - dummy는 null이나 임의의 문자열처럼 단순 하드코딩된 값
  - stub은 시나리오에 따라 다양한 값을 반환하도록 구성할 수 있는 완전한 형태의 의존성
  - fake는 stub과 동일하지만 아직 존재하지 않는 의존성을 대체하기 위해 생성된다는 것에서 차이점이 있다.

<br>

### Stub과의 상호작용을 검증하지 마라

Stub은 내부 상호작용만 흉내낼 수 있고 이를 검증할 순 없다.    

stub은 단지 입력 값을 제공하고 sut는 그 입력을 바탕으로 결과를 생성한다.    

stub과의 상호작용을 검증하는 것은 대표적인 안티패턴이다.. 

ex) 이메일을 보내는 것은 실제 결과에 대한 검증이고 의미가 있지만, 유저의 수를 검증하는 것은 데이터를 수집하는 내부 구현 세부사항이지 이를 테스트할 필요 Xx (과도한 명세)

<br>

**커맨드-쿼리 분리 원칙 (CQS: Command Query Separation)**
- 모든 메서드는 커맨드이거나 쿼리 중 하나여야 하고 둘 다여서는 안된다.
- 커맨드는 사이드 이펙트를 발생시키고, 값을 반환하지 않는 메서드 (= mock)
    - 사이드 이펙트가 발생하면 Void 반환
    - 이메일을 보내는 것
- 쿼리는 이와 반대로 사이드 이펙트가 없고 값을 반환하는 메서드 (= stub)
    - 값을 반환한다면 사이드 이펙트가 없어야 함
    - `getNumberOfUsers()`
- 사이드 이펙트는 객체 상태를 변경하거나 파일 시스템의 파일을 수정하는 것 등 ..

---

## 5.2 관찰 가능한 행동 vs 구현 세부사항

테스트가 거짓 양성을 발생시키고 리팩터링 저항성을 갖지 못하는 주된 요인은 코드의 구현 세부사항에 결합되어 있기 때문이다.    
테스트는 어떻게가 아닌 '**무엇을**'에 집중해야 한다.      

**관찰 가능한 동작 vs 구현 세부사항**
- 관찰 가능한 동작의 일부가 되기 위해선
  - 클라이언트가 목표를 달성하는데 도움이 되는 연산이나 상태를 제공해야 한다.
  - 해당 코드는 적어도 하나의 목표와 직접적으로 연결되어 있어야 한다.
- 위 두 가지 중 어느 것도 하지 않는 것이 코드 구현 세부사항
  - 구현 세부사항은 private

public API에 구현 세부사항이 노출되면 안된다.   
캡슐화는 데이터를 함수와 함께 묶는 것과 구현 세부사항을 숨기기 위한 수단이다.    
구현 세부사항을 private으로 숨기면 테스트는 자연스럽게 관찰 가능한 동작만 검증하게 되며, 이는 리팩토링 저항성을 자동으로 향상시킨다.     

---

## 5.3 mock과 테스트 취약성 사이의 관계

- 도메인 계층
  - 애플리케이션의 핵심이기 때문에 다이어그램의 중앙에 위치한다. (비즈니스 로직)
  - 비즈니스 로직에만 집중, 모든 책임에서 제외
  - 애플리케이션 서비스 계층을 알 필요가 없음, 완전 격리
  - 애플리케이션의 도메인 지식 (how-to)

- 애플리케이션 계층
  - 도메인 계층 위에 위치하며, 도메인 계층과 외부 세계 간의 통신을 조율하는 역할
  - 외부 애플리케이션과의 통신이나, 데이터베이스 등은 애플리케이션 서비스 계층에 귀속
  - 도메인을 알고 있어야 함
  - 비즈니스 유즈케이스 (what-to)


관찰 가능한 동작은 바깥 계층에서 중심으로 흐른다.      
관찰 가능한 동작의 일부가 되기 위해서는 클라이언트가 목표를 달성하도록 도와야 한다.        


**시스템 내부 통신, 시스템 간의 통신**     
- 시스템 내부 통신
  - 애플리케이션 내부 클래스들 간의 통신
  - 구현 세부사항

- 시스템 간의 통신
  - 다른 애플리케이션과의 통신
  - 시스템 전체의 관찰 가능한 동작
  - 외부 애플리케이션과 시스템 간의 통신 패턴을 검증할 때는 mock을 사용하는 것이 유익하다.
  - 시스템 내부에서 어떤 리팩토링을 하더라도 외부 애플리케이션과 통신하는 방식은 항상 유지되어야 한다.

---

## 5.4 단위 테스트의 고전적 학파와 런던 학파 재검토

**런던파**는 대부분의 의존성에 대해 mock 사용을 권장하며, 시스템 내부 통신과 외부 통신을 구분하지 않는다.       
→ 무분별한 mock 사용은 테스트가 구현 세부사항에 결합되고 리팩토링에 취약한 경우가 자주 발생한다.     


**클래식파**는 테스트 간에 공유되는 의존성만 대체하도록 권장되기 때문에 잘 대처할 수 있다.       
공유되는 의존성은 피하도록 권장 (이런건 대부분 외부 프로세스 의존성)       

- 공유 의존성 : 테스트 간에 공유되는 의존성
- 외부 프로세스 의존성 :  애플리케이션 실행 프로세스 외부에서 호스팅 되는 의존성 (ex. 데이터베이스, SMTP 서비스)
- 프라이빗 의존성 : 공유되지 않는 모든 의존성

공유 의존성이 외부 프로세스 기반이라면 테스트가 복잡해진다. 이를 테스트 대역으로 대체해야 한다.

---

## 느낀점
 
5장을 통해 테스트 대역에 대한 개념을 조금 더 명확하게 알 수 있게 되었다.     
그 중에서도 mock과 stub 같은 테스트 대역 종류들도 자세히 알게 되어 시야가 넓어진 것 같다.        

이번 장을 읽으면서 **“테스트는 구현 세부사항이 아닌 관찰 가능한 동작을 검증해야 한다.”** 라는 점을 다시 한번 명심하게 되었다.      
테스트가 내부 동작 방식에 의존하게 되면 결과적으로 리팩토링 저항성에 취약해질 수 있다는 것을 잊지 말아야겠다 ..

또한 캡슐화의 중요성도 강조되었는데, private과 public이 단순히 접근 제한자가 아니라 테스트의 안정성과 유지보수에도 직결된다는 것을 알게 되었다.
