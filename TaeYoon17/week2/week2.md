# 단위테스트 2일차

https://www.notion.so/2-20a9343702b180f88efdfdbf153969e5?source=copy_link

# 3장 단위 테스트 구조

> 단위 테스트를 잘 구성하고 잘 사용하자
> 

`AAA 패턴` `Test Fixture` `회귀` 

## 3.1 단위 테스트를 구성하는 방법

### 1. AAA 패턴 사용

<aside>
✅

**AAA 패턴이란?**

1. Arrange - 준비
2. Act - 실행
3. Assertion - 검증

**장점** → Test Suite 내 모든 테스트가 단순하고 균일한 구조를 갖는데 도움이 된다.

모든 테스트를 읽는데 쉬워진다.

> AAA 패턴의 기본적인 구조
> 
- 준비 구절: 테스트 대상 시스템, 해당 의존성을 원하는 상태로 만든다.
- 실행 구절: SUT에서 메서드를 호출하고 준비된 의존성을 전달, 출력 값을 캡쳐한다.
- 검증 구절: 결과 값 반환, SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.
</aside>

<aside>
✅

**기본적인 테스트 지침**

> **여러 개의 준비, 실행, 검증 구절 피하기**
> 
1. 검증 구절로 구분된 여러 개의 실행 구절이 있다 => 여러 개의 동작 단위를 검증하는 테스트

> **테스트 내 if 문 피하기**
> 
1. 단위 테스트든 통합 테스트든 테스트는 분기가 없는 일련의 단계여야한다.
2. 분기가 있다면 한 번에 너무 많은 검증을 한다는 표시다.

> **각 구절은 얼마나 커야 하는가? + 준비 구절을 준비하기**
> 
1. 실행 구절이 하나 이상이다 → SUT 자체의 문제가 있다. (P.85 예제 3.3 참고)
2. 테스트가 커지면 같은 클래스 내 비공개 메서드 또는 별도의 팩토리 메서드로 빼는 게 좋다.

> 종료 단계는 필요한다.
> 
1. 데스트 작성한 파일, 데이터베이스 연결을 종료하고자 할 때 부분적으로 쓰인다.

> SUT 시스템 구별하기
> 

SUT와 의존성을 구분하는 것은 필요하다. SUT 변수 이름을 `sut` 로 획일화 해서 많은 테스트 간의 sut를 찾는 시간을 최소화해라

</aside>

<aside>
❓

**Test Suite?**
여러 테스트 케이스를 하나로 묶어 관리하고 실행하는 집합

- 목적별 그룹화가 가능해짐
- 순차적 실행이 가능해짐 → 결국 자동화와 반복 실행이 가능해짐
</aside>

### 테스트 간 테스트 픽스처 재사용

테스트 픽스처 생성의 두 가지 방법

1. 테스트 생성자에서 픽스처를 초기화하는 것 (P.92, 예제 3.7 참고)
    1. 두 가지의 단점 → 1. 테스트 간 결합도가 높아짐 / 2. 테스트 가독성이 떨어짐
2. 테스트 픽스처 생성을 비공개 팩토리 메서드로 진행한다.

<aside>
❓

**Test Fixture?**

소프트웨어 테스트에서 테스트를 실행하기 전에 미리 준비되어야 하는 고정된 상태의 환경이나 데이터, 리소스, 설정

즉, 테스트가 항상 동일한 조건에서 반복적으로 실행될 수 있도록 필요한 준비 작업을 미리 해두는 것

예시) SUT로 전달되는 하드 디스크 파일, 데이터베이스 데이터

</aside>

<aside>
✅

> **테스트 간 높은 결합도는 안티 패턴이다.**
> 

> **테스트 가독성을 떨어뜨리는 생성자 사용**
> 

> **더 나은 테스트 픽스처 재사용법**
> 

비공개 팩토리 메서드 사용

</aside>

### 단위 테스트 명명법

⇒ 구현 세부 사항에 집중하지 않게 하는 것이 중요하다.

테스트는 다른 사람이 이해하기 쉽게 명명하는 것이 중요하다.

> **단위 테스트 명명 지침**
> 
1. 엄격한 명명 정책을 따르지 않는다.
2. 비개발자에게 시나리오를 제공하는 것 처럼 명명한다.
3. _ 표시로 Spacing 구분한다.

➕ 테스트 이름에 SUT 이름을 포함하지 말라

➕ *Should be* 문구와 같은 욕구가 아닌 동작 단위의 원자적인 사실을 명시한다

> 단위 테스트 명명 예시
> 

**Bad Case**

`IsDeliberyValid_InvalidDate_ReturnsFalse()`

**Good Case**

`Devivery_with_a_past_date_is_invalid()` 

### 매개변수화된 테스트 리팩터링

테스트 하나로는 동작 단위를 완전히 설명하기 충분하지 않다.

동작간의 관리를 유용하게 하기 위해 단위 테스트 Framework는 매개변수화된 테스트를 사용해 테스트를 묶을 수 있는 기능을 제공한다.

⇒ Swift Testing

```swift
@Test(arguments: [18, 30, 50, 70], [77.0, 73, 65, 61])
func verifyNormalHeartRate(age: Int, bpm: Double) {
    let hr = HeartRate(bpm: bpm)
    let context = HeartRateContext(age: age, activity: .regular, heartRate: hr)
    #expect(context.zone == .normal)
}
```

> **매개변수화된 테스트를 위한 데이터 생성**
> 

**주의할 점 ⇒** 컴파일러가 이해할 수 있는 값만 사용해야한다. (이래서 Swift Testing인가?)

# 좋은 단위 테스트의 4대 요소

<aside>
✅

> **좋은 단위 테스트 스위트의 특성 (1장 참고)**
> 
1. 개발 주기에 통합되어 있다.
2. 코드베이스의 가장 중요한 부분만 핵심으로 본다.
3. 최소한의 유지비로 최대 가치를 끌어낸다.
    1. 두 가지를 할 수 있어야 한다.
        1. 가치 있는 테스트 식별
        2. 가치 있는 테스트 작성
</aside>

### 0. 4대 요소

> **회귀 방지**
> 

회귀 방지는 소프트웨어를 수정하거나 새로운 기능을 추가한 뒤, 기존에 잘 동작하던 기능이 갑자기 제대로 동작하지 않는 “회귀(Regression)” 현상이 발생하지 않도록 예방하는 것을 의미

### 1. 좋은 단위 테스트의 4대 요소 자세히 살펴보기

<aside>
✅

> 회귀 방지
> 
1. 회귀 방지 지표에 대한 테스트 평가
    
    💡 비즈니스 로직을 나타내는 코드가 가장 중요하다.
    
    1. 테스트 중에 실행되는 코드의 양 → 많을 수록 회귀가 나타날 가능성이 높다.
    2. 코드 복잡도
    3. 코드의 도메인 유의성

> 리팩토링 내성
> 

⇒ 테스트를 실패로 바꾸지 않고 기본 Application 코드를 리팩터링 할 수 있는지 척도

테스트의 거짓 양성을 줄이도록 해야한다.

**💡 지속 가능한 테스트의 두가지 장점과 거짓 양성의 문제점**

**지속 가능한 테스트의 장점**

1. 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공
2. 코드 변경이 회귀로 이어지지 않을 것이라는 확신이 준다.

**거짓 양성의 단점**

1. 테스트가 타당한 이유 없이 실패하면 코드 문제에 대응하는 능력, 의지가 많이 희석된다.
2. 거짓 양성이 빈번하면 테스트 스위트 신뢰거 떨어져 믿을만한 안전망으로 인식하지 않아 리팩터링 시도가 줄어든다.

> ⚠️ **거짓 양성의 원인**
> 

**⇒ 테스트 구성 방식과 직접적인 관련**

**⇒ SUT의 구현 세부 사항과 테스트가 많이 결합될 수록 허위 경보가 더 많이 발생할 수 있다.**

P.119 / 예제 4.1 참고 (배열의 순서에 의존함)

> 🙆 **구현 세부 사항 대신 최종 결과를 목표로 하기**
> 

⇒ 최종 사용자에게 의미 있는 결과를 방출, 해당 값을 Assertion

</aside>

<aside>
❓

**회귀**

소프트웨어 버그. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우

`2종 오류`  `거짓 음성`

</aside>

<aside>
❓

**거짓 양성**

실제로 기능이 의도한 대로 작동하지만 테스트는 실패를 나타내는 경우

`1종 오류` `거짓 양성`

</aside>

### 2. 회귀 방지와 리팩토링 내성의 본질적인 관계

회귀 방지와 리팩터리 내성 사이에는 본질적인 관게가 있다.

프로젝트 초기 단계는 `회귀 방지`를 훌륭히 갖추는 것이 중요한데 반해, 리팩토링 내성은 바로 필요하지 않다.

<aside>
✅

> 테스트 정확도 극대화
> 

> 거짓 양성과 거짓 음성의 중요성 + 역학 관계
> 

리팩터링은 시간이 지나면서 중요해진다. 시간이 흐를 수록 코드베이스는 나빠지기 때문이다.

이 리팩터링을 하는데 리팩터링 내성을 지키지 않으면 테스트에 대한 신뢰가 사라져 의미있는 피드백 자료로 쓰일 수 없다.

</aside>

### 3. 빠른 피드백과 유지 보수성

> **유지 보수성 → 유지비 평가 2가지 주요 요소**
> 
1. **테스트가 얼마나 이해하기 어려운가**
    1. 테스트의 크기와 관련
    2. 테스트는 코드 라인이 적을수록 읽기 쉬움 + 변경도 용이함
    3. 테스트 코드를 일급 시민으로 취급할 필요가 있다.
2. **테스트가 얼마나 실행하기 어려운가**
    1. 프로세스 외부 종속성 위에서 작동하면, 의존성 운영에 시간을 들여야한다.

### 4. 이상적인 테스트

<aside>


> ✅ **이상적인 테스트를 만들 수 있는가?**
> 

불가능하다.

회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다.

각각의 특성은 곱셉 법칙으로 가치가 정해지기 때문에 절충해서 테스트를 만들어야한다.

> **엔드 투 엔드 테스트 → 빠른 피드백에 취약점**
> 

⇒ 최종 사용자 관점에서 시스템을 테스트

모든 시스템 리소스를 사용하기에 빠른 피드백을 받을 수 없다.

> **간단한 테스트 ⇒ 회귀 방지가 없다**
> 

너무 간단해서 회귀 방지의 역할을 할 수 없다.

무조건 옳은 테스트들… 너무 자명한 결과를 만드는 테스트들…

> **깨지기 쉬운 테스트 → 리팩터링 내성을 약하게 하는 테스트**
> 

“어떻게”에 중점을 두는 테스트

P.135 예제 4.6 참고

> **결론**
> 

좋은 단위 테스트의 특성 중 3가지 (회귀 방지, 리팩터링 내성, 빠른 피드백)은 상호 배타적이다.

두 가지를 극대화하긴 쉽지만, 한 가지를 희생해야한다.

but, 리팩터링 내성을 포기할 순 없기에 회귀 방지, 빠른 피드백 사이에 절충안을 둬야한다.

❓리팩터링 내성을 포기할 수 없는 이유

⇒ 리팩터리 내성은 이진 선택이기 때문, 리팩터링 내성이 있거나 없거나

</aside>

### 5. 대중적인 테스트 자동화 개념

<aside>


> ✅ **테스트 피라미드 분해**
> 

⇒ 테스트 피라미드의 상단일 수록 회귀 방지에 강조, 하단일수록 실행 속도 강조한다.

---

✔️ 테스트 피라미드의 예외

애플리케이션이 비즈니스 규칙이나 복잡도가 없는 CRUD 작입이면 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형 (SDK..?)

---

- 단위 테스트는 알고리즘, 비즈니스 복잡도가 없는 환경에서는 유용하지 않음
- 통합 테스트는 데이터베이스와 같이 다른 하위 시스템이 잘 통합돼 작동하는지 확인하는 것이 중요

> **블랙박스 테스트와 화이트박스 테스트 간의 선택**
> 

기본적으로 화이트박스 테스트가 더 철저하다. ⇒ 특정 코드 구현과 결합

특정 코드 구현과의 결합은 리팩터링 내성을 저해시킬 요소임으로 기본적으로 블랙박스 테스트를 기본으로 설계해야한다.

➕ 도구 (코드 커버리지) 등을 이용해 블랙박스 테스트에서도 내부 구조를 확인할 수 있다.

</aside>

<aside>
❓

**테스트 피라미드**

테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념

</aside>
