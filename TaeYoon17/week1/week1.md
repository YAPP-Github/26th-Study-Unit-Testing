# 1장 단위 테스트의 목표

> **소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 만들자**



소프트웨어도 무질서도(엔트로피)가 증가하는 방향으로 간다. 이는 작업 소요 시간의 시간 소요가 기하 급수적으로 커지는 문제점이 발생하게 된다.



> 좋은 테스트 vs 좋지 않은 테스트

+ 좋은 테스트
+ 잘못된 테스트
+ 테스트 부재
+ 테스트가 좋지 못하면 프로젝트에서 더 많이 + 쏟아내도 단위 테스트의 목표를 달성할 수 없다.



#### 비용 요소의 필요한 시간에 따라 결정

1. 기반 코드를 리팩터링할 때 테스트도 리팩터링해라
2. 각 코드 변경 시 테스트를 실행하라
3. 테스트가 잘못된 경고를 발생시킬 경우 처리해라
4. 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자 하라


### 테스트 커버리지의 한계와 사용처
> 커버리지 지표는 괜찮은 부정 지표이지만, 좋지 않은 긍정 지표



#### ⚠️ 커버리지의 문제점
1. 테스트 대상 시스템의 모든 가능한 결과를 보장한다고 보기 어렵다.
2. 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.


## 단위 테스트의 목표
> 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 만들자

> 소프트웨어도 무질서도(엔트로피)가 증가하는 방향으로 간다. 이는 작업 소요 시간의 시간 소요가 기하 급수적으로 커지는 문제점이 발생하게 된다.

테스트가 좋지 못하면 프로젝트에서 더 많이 쏟아내도 단위 테스트의 목표를 달성할 수 없다.

#### 비용 요소의 필요한 시간에 따라 결정

1. 기반 코드를 리팩터링할 때 테스트도 리팩터링해라
2. 각 코드 변경 시 테스트를 실행하라
3. 테스트가 잘못된 경고를 발생시킬 경우 처리해라
4. 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자 하라


### 테스트 커버리지의 한계와 사용처
> 커버리지 지표는 괜찮은 부정 지표이지만, 좋지 않은 긍정 지표



### 커버리지의 문제점
1. 테스트 대상 시스템의 모든 가능한 결과를 보장한다고 보기 어렵다.
2. 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

# 2장 단위 테스트란 무엇인가

#### 의존성의 분류

|공유 의존성|설명|예시|
|------|---|---|
|공유 의존성|상태 값을 여러 군데에서 실시간으로 알아야 함 > Actor 보존이 안됨|싱글톤|
|프로세스 외부 의존성|의존하는 인스턴스에서만 사용함 but 외부 프로세스가 필요함|Read Only API 서비스|
|공유 의존성 & 프로세스 외부 의존성|상태 값을 여러 군데에서 실시간으로 반영, 외부에 존재함|데이터 베이스|


#### 고전파 vs 런던파

> 한 번에 한 클래스만 테스트 하기 vs 공유 의존성을 제거한 ( + 이에 특화된 인터렉터 구현체가 필요할 수도..?) 협력자도 같이 테스트 하여 하나의 **비즈니스 로직 단위** 수행

1. **고전파**
1-1. 격리 주체: 단위
1-2. 단위의 크기: 단일 클래스
1-3. 테스트 대역 사용 대상: 불변 의존성 외 모든 의존성