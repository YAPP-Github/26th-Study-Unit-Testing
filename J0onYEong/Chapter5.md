# 요약

## 개요

4장에서는 단위 테스트 방법을 분석하는 데 사용할 수 있는 기준틀을 학습했다.

5장에서는 해당 기준틀이 실제로 적용되는 것을 확인할 수 있다.

## 목과 스텁 구분

### 테스드 대역 유형

- Mock
    - 외부로 나가는 상화 작용을 모방하고 검사하는데 도움이 된다.
        
        상호작용이란, SUT가 상태를 변경하기 위한 의존성을 호출하는 행위를 의미한다.
        
- Stub
    - 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다.
        
        “내부로 들어온다”의 의미는 SUT가 입력데이터를 얻기 위한 의존성을 호출하는 행위를 의미한다.
        

목은 SUT와 의존성 간의 상호 작용을 모방하고 검사한다. 반면 스텁은 모방만 한다.

### 스텁으로 상호 작용을 검증하지 말라

목은 SUT에서 관련 의존성으로 **나가는 상호 작용을 모방하고 검사**하는 반면 스텁은 내부로 들어오는 상호 작용만 모방하고 검사는 진행하지 않는다.

스텁은 최종결과를 산출하기 위한 중간 수단일 뿐, 결과와 코드레벨적인 관계가 없다. 따라서 스텁으로 모방하는 동작에 대한 검증은 리팩토링 내성을 크기저하하는 안티패턴이다.

※ 동작 검증은 매서드 호출 횟수같은 것을 의미한다.

### 목과 스텁 함께 사용하기

목도 스텁처럼 인풋 데이터를 제공 기능을 모방할 수 있다.

그렇다면, 인풋데이터를 제공하는 목이 검증까지하면 안티패턴이 아닌가?라고 생각할 수 있다.

여기서 검증하는 매서드가 스텁을 통해 모방한 매서드가 아니라면 스텁과의 상호작용을 검증하는 것이 아니기 때문에 앞선 주제의 규칙에 위배되지 않는다.

위와 같은 상황에서 목이 스텁처럼도 활동하는데, 이 경우 스텁이 아니라 목이라고 칭한다.

### 명령, 조회와 목, 스텁의 연관성

명령 조회 분리 원칙

- 명령은 사이드 이펙트를 발생시키고 어떠한 값도 반환하지 않는다.
- 조회는 값을 반환하며, 어떠한 사이드 이팩트를 발생시키지 않는다.

명령을 대체하는 테스트 대역이 목이다. 조회를 대체하는 테스트 대역은 스텁이다.

## 식별할 수 있는 동작과 구현 세부 사항

### 식별할 수 있는 동작은 공개 API와 다르다

public API와 클라이언트 입장에서 식별할 수 있는 동작은 서로 다른 개념이다.

코드가 시스템의 식별할 수 있는 동작이라면 다음 중 하나를 해야한다.

- 클라이언트 목표를 달성하는 데 `도움이 되는 연산`을 노출해라, 연산은 계산을 수행하거 사이드 이팩트를 초례하는 매서드이다.
- 클라이언트가 목표를 달성하는 데 `도움이 되는 상태`를 노출하라, 상태는 시스템의 현재 상태이다.

**구현 세부 사항은 이 두가지중 아무것도 하지 않는다.**

코드가 식별할 수 있는 동작인 여부는 API를 사용하는 클라이언트가 누구인지, 해당 **`클라이언트의 목표`**가 무엇인지에 달려있다.

이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현의 세부사항은 클라이언트 눈에 보이지 않아야한다. (=private이어야한다.)

예를들어 클라이언트의 목표가 유저의 이름을 변경하는 것이라고 해보겠다. 그런데 유저의 이름은 특정 규칙에 따라 작성되야한다.

여기서 나올 수 있는 매서드는 다음과 같다.

1. 특정 문자열이 유저 이름 규칙에 부합하는지 확인하는 매서드
2. 저장소에서 유저정보를 가져오고 유저이름을 변경후 다시 저장하는 매서드

1번의 경우 클라이언트 목표와 아무런 관련이 없다. 따라서 클라이언트 해당 매서드에 노출되서는 안된다.

2번의 경우 클라이언트의 목표와 부합한다. 따라서 클라이언트는 해당 매서드를 사용해야한다.

그렇다면 이름에 대한 검증은 어떻게 진행되야 할까?

클라이언트는 상대적인 개념이다.

만약 User라는 객체가 있을 때 유저에 이름을 변경하는 2번 매서드는 User객체의 클라이언트이다.

2번 매서드의 목적은 User객체의 이름을 변경하는 것이다. 여기에 이름의 유효성 검증은 포함되지 않는다.

따라서 1번은 2번에도 노출되면 안된다.

```swift
struct User {
		
		var name: String {
				get { name }
				set {
						if checkNameIsValid(str: newValue) {
								
								...
						}
				}
		}
		
		private func checkNameIsValid(str: String) -> Bool {
				...
		}
}
```

이러한 상태를 잘 식별할 수 있는 규칙이 있다.

<aside>

단일한 목표를 달성하고자 클래스에서 호출해야하는 연산의 수가 1보다 크다면 해당 클래스는 구현의 세부사항을 노출할 가능성이 있다.

</aside>

위에서 언급한 이름 변경 함수가 만약 1번 함수를 내부적으로 호출하고 있다면 코드가 두줄 이상 필요하다.

- 이름의 유효성 검증
- 검증된 이름을 할당

이는 현제 주목하는 목적이 아닌 다른 코드가 노출된 상황이며 User객체의 구현 세부사항에 대한 노출이다.

### 잘설계된 API와 캡슐화

앞서 언급한 예제의 User이름에 대한 검증은 불변성(값이 항상 유효함)을 지키기위한 매서드이다. 하지만 해당 매서드가 외부로 노출되어 외부에서 검증이 필요하고 이름에는 어떠한 값도 할당할 수 있는 구조인 경우 오히려 불변성이 위배된다. 

검증되지 않은 값도 이름 값으로 할당되는 것이 가능하기 때문이다.

캡슐화가 잘 지켜지지 않았기에 헛점이 보인다, 허점이 많은 프로그램은 장기화되면 붕괴될 것이다.

따라서 실수할 가능성(검증되지 않은 이름을 할당 가능한 동작)을 최대한 없애는 것을 지향해야한다. 캡슐화를 올바르게 유지해 코드베이스에서 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것이다.

**묻지 말고 말하라, 구현 세부사항을 숨기고 데이터와 기능을 결합하는 것이 해당 목표를 달성하기 위한 수단이다.**

풀어서 말하자면, 어떤 데이터를 관리하는 코드(기능)를 해당 데이터와 동일한 객체로 격리하라는 의미이다.

이름에 대한 검증이라는 기능은 해당 데이터를 보유한 User객체로 격리시켜야한다.

**“이름의 검증 상태가 어떻게 되나요?, 아..” → “이름을 변경해!”**

### 결론

좋은 단위 테스트와 잘 설계된 API 사이에는 본질적인 관계가 있다. 모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 이외에는 다른 선택지가 없으며, 이로 인해 리팩토링 내성도 자동으로 좋아진다.

<aside>

API를 잘 설계하면 단위 테스트는 자동으로 좋아진다.

</aside>

## 목과 테스트 취약성 간의 관계

### 육각형 아키텍처

프로그램을 2가지 계층으로 분리한다.

- 애플리케이션 서비스 계층
    - 외부 환경과의 통신을 조정
        - 데이터베이스 조회 및 해당 데이터를 사용해 도메인 객체 생성
        - 해당 도메인 인스턴스에 연산 호출
        - 결과를 데이터 베이스로 다시 저장
- 도메인 계층

해당 계층분리에는 3가지 주요 관점이 있다.

- **도메인 계층과 애플리케이션 서비스 계층간의 관심사 분리**
- 애플리케이션 내부 통신
    - 의존성의 방향은 도메인 계층으로 한정, 도메인 계층이 애플리케이션 계층을 의존하지 않음
- 애플리케이션 간의 통신
    - 외부 애플리케이션은 도메인 계층을 직접 접근할 수 없다. 애플리케이션 서비스 계층을 통해서 접근해야 한다.

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타낸다. 예를들어 도메인 계층의 식별할 수 있는 동작은 이 계층의 연산과 상태이고, 해당 연산과 상태는 애플리케이션 계층의 목표를 수행하는데 필요하다.

계층마다 “클라이언트”가 누구인지 명확히 인식하고, 이 클라이언트 기준에서 봤을 때 감춰야 할 내부 구현을 적절히 숨기고 (캡슐화), 필요한 것만 API로 공개하는 것이 좋은 설계이며, 테스트도 이 경계를 넘지 않도록 설계해야 한다.

각계층의 API를 잘 설계하면 테스트도 프랙탈 구조를 가지게된다. 

최종적으로 달성하는 목표는 같지만 서로 다른 수준에서 동작을 검증한다.

서비스 계층은 도메인 계층의 클라이언트로써 검증(테스트)이 이뤄지고, 외부 애플리케이션은 서비스 계층의 클라이언트로써 검증이 이뤄진다. 

프렉탈 구조가 되는 것이다.

<img src="./images/chapter5_fractal_triangle.png" width=300 />

### 시스템 내부 통신과 시스템 간 통신

시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다.

시스템간 통신은 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다.

특정 연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항에 해당한다.

### 외부 의존성을 반드시 목으로 해야하는 것은 아니다.

특정 애플리케이션만 사용하는 데이터베이스가 있다.

해당 데이터베이스는 애플리케이션에 의해 사용되지만 외부 의존성이다.

하지만 단일 애플리케이션이 해당 데이터 베이스에 대해 완전한 통제권을 가지고 있다.

완전한 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다.

이 때는 데이터베이스와 애플리케이션을 하나의 시스템으로 취급해야한다.

완전한 통제권임으로 디비에 대한 접근은 식별가능한 동작이 아니라 구현의 세부사항으로 분류된다.

하지만, 이것은 테스트의 피드백 속도에 영향을 미칠 수 있다. 해당 내용은 추후 장에서 다룬다고 한다.

# 느낀점

테스트 더블즈의 다양한 종류를 알게되어 좋았으며, 가장 주요한 대역인 스텁과 목에 대해 깊이 알 수 있는 장이였다.

식별가능한 동작을 테스트 했을때 리팩토링 내성을 줄일 수 있다는 것을 알게되었다. 하지만 이는 테스트에 국한된 개념이 아니라 좋은 API 즉 유지보수성이 높고 안정적인 소프트웨어를 구현하기 위해서 필요한 규칙들이 수반됬을 때 자연스럽게 구현됨을 알 수 있었다.