# 요약

단위테스트에만 전적으로 의존하면, 시스템이 전체적으로 잘 작동하는지 확신할 수 없다.

내부 시스템이 외부 시스템과 잘 통합되는지 확인이 필요하다.

## 1. 통합테스트는 무엇인가?

단위테스트가 가져야할 3가지 전제는 아래와 같다.

- 단일 동작을 빠르게 검증
- 빠르게 테스트를 수행
- 다른 테스트와 독립적으로 동작가능

위 3가지중 하나라도 만족하지 못하는 테스트는 통합테스트 범주에 속한다.

대부분은 시스템과 외부 의존성이 어떻게 통합되는지를 다룸으로, 테스트 사분면중 컨트롤러 사분면에 속하는 부분의 코드를 다룬다.

(복잡하지 않으며, 협력자수가 많은 영역)

모든 테스트는 7장에서 살펴보았듯이 **컨트롤러 사분면 혹은 도메인 모델 및 알고리즘 사분면만**을 테스트 해야한다.

통합 테스트 코드는 테스트 피라미드에서 **중간 계층에 속한다.**

외부의존성을 다뤄야하고 해당 의존성 관리를 위해 추가적인 비용(시간)이 발생함으로 수가 너무 많으면 안된다.

하지만, 모든 동작시키는 코드가 많기 때문에 회귀 방지성이 높아 너무 적지 않은 것이 좋다.

### 통합 테스트와 빠른 실패

통합 테스트에서 프로세스 외부 의존성과의 상호작용을 모두 확인하려면, **가장 긴 주요 흐름**을 식별하는 것이 중요하다. 

모든 상호 작용을 거치는 주요 흐름이 없다면, 여러개의 흐름을 각각 테스트할 필요성이 있다.

**Precondition**실패와 같이 조건 미충족시 앱이 즉시 종료되는 케이스에 대해선 테스트 하지 않는 것이 좋다.

해당 실패로 인해 앱이 종료되면, 외부 데이터 손상을 유발하지 않기 때문에 테스트 가치가 낮다.

(Precondition실패전에 외부 데이터 조작이 발생하는 코드가 없다는 전제가 있다.)

## 2. 통합 테스트에서 어떤 프로세스 외부 의존성을 테스트 해야하는가?

프로세스 외부 의존성은 2가지 유형으로 분류할 수 있다.

- 관리 의존성
    - 내부 시스템에 의해서만 접근 가능한 의존성(애플리케이션이 독점적인 접근관을 가짐)
- 비관리 의존성
    - 애플리케이션 외부 공간에서도 접근(열람)가능한 의존성

관리 의존성과의 통신은 구현의 세부사항에 해당한다. 반면, 비관리 의존성의 경우 대부분 식별할 수 있는 동작임으로 목을 사용할 필요가 있다.

관리 의존성에 해당하는 내부 데이터 베이스라도, 때로는 관리 범위에서 벗어날 수 있다.

보안 정책이 있거나, 테스트를 위해 별도의 인스턴스를 유지하기 힘든 경우가 있다.

이 경우 관리 의존성에 대해서 목을 만들 빠엔 아얘 작성하지 않는 것이 좋다. 통합 테스트 입장에서 관리 의존성은 세부 사항에 해당하기 때문에 리팩토링 내성만 잃게 된다. 따라서 작성하지 않고 단위 테스트에 더 집중하는 편이 낫다.

## 3. 통합 테스트 예제

어떤 시나리오를 테스트할까?

단위 테스트로는 검증할 수 없는 가장 많은 예외 상황을 다루는 것이 중요하다. 즉, 외부 의존성과 통신시 발생하는 사이드 이팩트를 가장 많이 유발하는 흐름이 테스트하기 좋은 시나리오이다.

예를들어 7장의 CRM시스템을 예시로 든다면,

“일반 이메일을 기업 이메일로 변경한다.”

- 데이터 베이스에 회사에 대한 정보(회사 이메일의 수) 업데이트
- 데이터 베이스에 유저 정보 업데이트
- 메세지 버스로 변경을 알림(예, 이메일 서비스)

여기서 데이터 베이스는 관리 의존성에 해당하고, 메세지 버스는 외부에서 식별할 수 있는 로직으로 비관리 의존성에 해당한다.

### 엔드투 엔드 테스트

엔드 투 엔드 테스트는 테스트 진행시 모든 외부의존성을 그대로 사용한다.

해당 상태에서 비관리 의존성을 목으로 대채한 것이 통합테스트라고 할 수 있다.

저자는 비관리 의존성을 대체한 통합테스트 만으로도 충분하다고 생각하며, 엔드 투 엔드 테스트 통합테스트가 잘 마련되어 있다면 생략해도 무방하다고 한다.

## 4. 의존성 추상화를 위한 인테페이스 사용

https://enterprisecraftsmanship.com/posts/ocp-vs-yagni

대부분의 개발자들은 인터페이스를 습관처럼 사용한다.

아래 2가지 이유로 인해 대부분 인터페이스를 사용한다.

1. 구체적인 타입을 의존하지 않음으로 느슨한 결합을 만든다.
2. 기존 코드를 변경하지 않고 새로운 코드를 생성할 수 있음으로 OCP에 적합

*저자는 이 두가지 이유 모두 개발자들의 오해라고 한다.*

- **느슨한 결합에 대한 반박**
    
    단일 구현체를 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다. **인터페이스를 사용하려면 적어도 구현체가 2개는 있어야한다.**
    

- **OCP에 대한 반박**
    
    YAGNI, 현재 필요하지 않은 기능을 위해 시간을 낭비하지 말라
    

구체적인 이유는 아래와 같다.

- **기회 비용**
    
    지금 당장 필요한 기능이 아닌 후사를 상상한 구현은 시간을 허비하는 것은 좋지 못하다.
    
    특정한 기능을 개발할 때, 추후 확정성을 고려한 설계를 하여도, 비즈니스 담당자의 요구사항이 해당 구현을 무시할 정도로 클 수 있다. 따라서 처음부터 실제 필요한 기능을 구현하는 것이 더 현명하다.
    
- **불필요한 추상화는 코드베이스를 증대시킨다.**
    
    코드베이스의 증대는 결국 비용이다.
    

<aside>

코드를 작성하는 것은 문제를 해결하는 방법중 값비싼 방법에 속한다.

최대한 적게 작성하는 것이 좋다.

</aside>

### 프로세스 외부 의존성에 대한 인터페이스

해당 타입들에 대해서는 구현이 여러개가 아닐지라도 인터페이스가 필요할 수 있다.

단순히 목을 사용하기 위해서이다.

목을 사용하지 않는 경우는 외부의존성이라도 인터페이스는 불피요하다. 즉, 비관리 의존성에 대해서만 예외없이 인터페이스를 사용하도록 하자.

## 5. 통합 테스트 모범사례

통합 테스트를 최대한 활용하는 데 도움이 되는 몇가지 일반적인 지침이 있다.

- 도메인 모델 경계 명시하기
    - 명시적이고 알려진 위치에 도메인 모델을 위치시켜라
- 애플리케이션 내 계층 줄이기
    - 애플리케이션의 규모가 커지면, 계층수가 흔히 증가한다.
        
        이 경우, 특정 기능을 처리하는 계층을 찾기 어려워진다.
        
        모바일 개발로 치면, ViewModel, UseCase에 비즈니스 로직이 분산되는 경우를 예시로 들 수 있다.
        
- 순환 의존성 제거하기
    - 순환 의존성은 코드 가독성을 저해한다. 해결책을 찾기위한 출발점이 모호해지기 때문이다. (A, B가 순환 의존 중이라면, 어디가 진입점인가? 어디서 종료되는가?)
    - 인터페이스를 통해 구현체간 직접 참조를 막는 것은 별로 도움이 되지 않는다. 오히려 계층을 하나더 만들어 복잡성이 커진다.
    - 현실적으로, 모든 순환의존성을 없애는 것은 힘들다, 최소화를 목표로 하는 것이 좋다.

늘 그렇듯, 테스트를 좋게하는 방법은 결국 코드 베이스의 개선이다.

## 6. 로깅을 테스트해야한다고?

로깅은 2가지 분류로 나뉜다.

- 지원 로깅
    - 개발자외에 비즈니스 관계자가 확인할 수 있는 로깅. 즉, 외부에서 식별할 수 있는 비즈니스 로깅을 의미한다.
- 진단 로깅
    - 개발자가 동작 점검을 위해 내부적으로 사용하는 로깅

지원 로깅의 경우 식별가능한 동작임으로 앞선 테스트들과 같이 테스트가 필요하다.

(비관리 의존성을 다루는 것과 다르지 않다.)

도메인 모델 내부에 로깅 객체가 위치할 수 있는데, 앞선 장들에서 말했듯이 도메인 모델에 외부 의존성이 있는 것은 좋지 않다.

앞선 장에서 소개한 “도메인 이벤트”같은 기법을 사용하여 해당 문제를 해소할 수 있다.

가능하면, 진단 로깅역시 도메인 모델 내에서는 사용하지 않는 것이 좋다고 한다. 해당 내용은 다음 장에서 다룬다고 한다.

지원 로깅과 진단 로깅의 구현에는 차이를 둘 필요가 있다.

지원 로깅의 경우 비즈니스 로직이기에 좀 더 구조화된 로깅 처리가 필요하다, 따라서 DomainLogger라는 별도의 클래스를 둬 진단 로깅과는 다른 처리가 필요하다. (자세한 구현 사항은 도서 확인 필요 p298)

# 느낀점

외부의존성을 2가지 분류로 나눌 수 있는 점이 인상적이였다.

관리 의존성의 경우 통합테스트 입장에서는 세부사항에 해당하며, 해당 의존성에 대한 목처리는 오히려 리팩토링 내성을 저하한다는 점도 인상적이다.

인터페이스 사용에 대해서는 트레이드 오프가 있다고 생각해, 좀 더 생각과 경험이 필요할 것이라고 판단된다.

로깅이라는 예시를 통해 식별할 수 있는 것은 비즈니스 로직이라는 개념이 좀 더 명료해졌다.