# 요약

- [요약](#요약)
  - [단위 테스트를 구성하는 방법](#단위-테스트를-구성하는-방법)
    - [AAA패턴(Arrange, Act, Assert)](#aaa패턴arrange-act-assert)
    - [준비, 실행, 검증 구절이 여러개 존재하지 않도록 하기](#준비-실행-검증-구절이-여러개-존재하지-않도록-하기)
    - [테스트 내 if 문 피하기](#테스트-내-if-문-피하기)
    - [AAA구간은 얼마나 커야하는가](#aaa구간은-얼마나-커야하는가)
      - [준비 구절이 가장 큰 경우](#준비-구절이-가장-큰-경우)
      - [실행 구절이 한 줄 이상인 경우를 경계하라](#실행-구절이-한-줄-이상인-경우를-경계하라)
    - [검증 구절에는 검증문이 어마나 있어야 하는가](#검증-구절에는-검증문이-어마나-있어야-하는가)
    - [종료 단계](#종료-단계)
    - [SUT구별하기](#sut구별하기)
  - [테스트 간 테스트 픽스처 재사용](#테스트-간-테스트-픽스처-재사용)
    - [테스트 픽스처 공유시 주의할 점](#테스트-픽스처-공유시-주의할-점)
  - [단위 테스트 명명법](#단위-테스트-명명법)
    - [케이스 매서드](#케이스-매서드)
    - [테스트 객체](#테스트-객체)
  - [매개변수화된 테스트 리펙터링하기](#매개변수화된-테스트-리펙터링하기)
- [느낀점](#느낀점)
  - [생각해보기](#생각해보기)

## 단위 테스트를 구성하는 방법

- AAA패턴(Arrange, Act, Assert)
    
    단위 테스트 케이를 준비, 실행, 검증으로 이루어진 3단계로 구조화하는 템플릿이다.
    
    모든 테스트가 단순하고 균일한 구조를 갖는데 도임이 되며 이러한 일관성이 이 패턴의 가장 큰 장점이다.
    
    ※ 프로그래머들에게는 AAA패턴이 적합하지만, 비개발자들에거는 Given-When-Then구조가 조금더 읽기 쉬울 수 있기에 비개발자가 많은 프로젝트에서는 해당 구획법이 더 좋다.
    

- 준비, 실행, 검증 구절이 여러개 존재하지 않도록 하기
    
    안티패턴: 준비 → 실행 → 검증 → 실행 → 검증
    
    이러한 테스트는 더이상 단위 테스트가 아니라 통합 테스트에 가깝다.
    
    각 동작을 고유한 테스트로 도출하여, 하나로 이어지는 AAA구조로 리팩토링을 해야한다.
    
    ※ 통합테스트의 경우 특정 기능을 테스트하기 위한 준비 코드가 오버헤드가 큰 경우 두 실행을 검증하는 코드를 사용할 수도 있다.(시간과 복잡도의 트레이드 오프이다.)
    
- 테스트 내 if 문 피하기
    
    테스트는 분기가 없는 하나로 이어지는 단위여야한다.
    
    if문을 사용한다는 것은 하나의 테스트가 두가지 이상을 검증한다는 반증이다.
    
    반드시 여러 테스트로 나눠야한다.
    

### AAA구간은 얼마나 커야하는가?

- 준비 구절이 가장 큰 경우
    
    일반적으로 준비구절이 가장크다. 이 경우 팩토리 매서드를 클래스내에 생성하여 가독성을 높여줄 수 있다.
    
    반복되는 준비 코드를 줄이고 싶은 경우, 코드 재사용을 목적으로 아래 두가지 패턴을 활용하여 해결할 수 있다.
    
    - 오브젝트 마더
        - 테스트를 위해 객체를 생성하고 설정하는 방법을 정의하는 디자인 패턴
    - 테스트 데이터 빌더

- 실행 구절이 한 줄 이상인 경우를 경계하라
    
    실행 구절은 보통 한줄이다. 2줄 이상으로 구축된다는 것은 SUT에 문제가 있다는 신호이다.
    
    예시에서 Store인스턴스를 인자로 전달받는 Customer인스턴스는 구입을 진행한다.
    
    해당 구입에 대한 재고 관리를 Customer매서드가 아니라 별도의 Store매서드를 추가적으로 호출해야한다면, 이는 Customer매서드의 내부 구현에 대한 지식이 수반됨으로 **캡슐화를 깬다.**
    
    해당 경우 구매후 재고 관리를 위해 추가적인 매서드를 호출하지 않으면 상태에 모순이 생긴다.
    
    이러한 모순을 **불변 위반**이라고 하며, 잠재적 모순으로 부터 코드를 보호하는 행위를 캡슐화라고 한다.
    
    하지만 유틸리티나 인프라 코드는 한줄 사용제약이 덜 적용될 수 있다. 단순히 한줄에 주목하기 보다는 캡슐화를 준수하여 구현했는지가 더 중요하다.
    

### 검증 구절에는 검증문이 어마나 있어야 하는가

(고전)단위테스트는 코드단위가 아니라 동작단위이기 때문에, 검증문이 길어질 수 있다.

하지만 검증문이 길어지는 것은 경계해야한다.

예를들어 특정 객체의 상태를 판단하는 검증문이 있을때, 객체의 프로퍼티가 많다면 검증문도 그에 비례하여 길어진다.

이 경우 **Equatable**프로토콜을 활용하여 간소화할 수 있다.

### 종료 단계

AAA로 구성된 테스크코드 실행후 종료 단계가 추가적으로 더 필요하기도 하다.

대부분의 단위테스트는 프로세스 외부에 종속적이지 않기 때문에, 종료 단계의 경우 대부분 통합테스트에서 활용된다.

XCTest의 teardown은 종료 단계를 위한 매서드로 사용된다.

### SUT구별하기

AAA로 구성된 테스트는 준비단계에서 많은 객체를 필요로할 수 있다. 하지만, 실행을 위한 진입점은 하나임으로 많은 객체들 중 SUT를 가시적으로 표현하는 것이 좋다.

그렇기에 SUT이름을 sut로 명시적으로 지정하라.

## 테스트 간 테스트 픽스처 재사용

테스트 픽스처라는 단어는 두가지 의미가 있다.

- SUT에 전달되는 객체를 의미한다. 알려진 고정 상태로 생성되기 때문에 항상 동일한 결과를 발생시킨다. 픽스처란 이름은 여기서 파생된 것이다.

### 테스트 픽스처 공유시 주의할 점

테스트 픽처스는 초기상태만 고정적이지 테스트 진행중에는 내부 상태가 변할 수 있는 가변 객체이다.

따라서 테스트 픽처스 인스턴스를 여러 케이스에서 공유하는 것은 위험하다.

따라서 테스트 클래스의 프로퍼티를 통해 여러 테스트에서 인스턴스를 공유하기 보단, 팩토리 매서드를 공유하는 방법이 옳다. 

이 방식인 동일한 인스턴스를 각기다른 케이스에 생성하지만 별개의 인스턴스를 사용하기 때문이다.

## 단위 테스트 명명법

### 케이스 매서드

관습상 테스트 코드는 아래템플릿을 사용하여 명명한다.

`[테스트 대상 매서드]_[시나리오]_[예상결과]`

해당 템플릿은 읽기 어렵고, 동작 대신 구현의 세부사항을 노출시킬 수 있어 별로다.

간단한 문구로 테스트하려는 동작을 서술하는 것이 더 효율적이다.

`sum_of_two_numbers`, `Sum_twonumbers_returnsum` 두가지 명명법에 대해 전자가 훨씬 읽기 쉽다는 것을 알 수 있다.

실행시 사용되는 SUT매서드 명을 케이스 매서드명에 포함하는 것은 좋지않지만, 유틸리니나 인프라 객체를 테스트하는 경우는 예외로 사용을 허가한다.

테스트 명에 소망이나 희망을 나타내는 표현은 최대한 배제해야한다. 테스트는 펙트를 서술하는 것이기 때문이다.

[should be 특정 상태] 와 같은 표현은 피해야한다.

### 테스트 객체

대부분 `[클래스명]Tests` 형태를 사용한다. 테스트시 특정 클래스가 아니라 동작을 테스트하는 고전파에 따르면 사실 이는 잘못된 표기법이다.

따라서 고전파적 접근에는 해당 템플릿의 [클래스명]으로 단순히 **진입점이 되는 객체**의 타입을 작성해준다.

## 매개변수화된 테스트 리펙터링하기

하나의 동작을 검증하기위해 여러가지 데이터를 사용해야 하는 경우 보일러 플레이트가 많아지는 문제가 발생한다.

해당 데이터들을 매개변수화하여 동일한 테스트코드를 사용하도록 하여 개선할 수 있다.

하지만, 다양한 데이터에 대한 결과를 검증해야하기 때문에 테스트의 목적이 다소 일바적으로(general하게)변화는 문제가발생할 수 있다. 

따라서 테스트의 목적이 불투명해져 가독성을 떨어트리지 않는 선에서 매개변수를 활용해야한다.

예를들어 긍정 결과와 부정결과를 테스트하는 코드에서 매개변수로 데이터와 그 결롸를 모두 전달할 수 있다.

이것보다 그냥 긍정, 부정 각각이 서로다른 매서드를 사용하는 것이 가동성이 높다.

# 느낀점

그동안 테스트 케이스에 대한 명명이 항상 힘들었다.

이는 런던파 테스트 방식을 자주 사용했기 때문인 것 같다. 구체적인 매서드와 그에 응하는 결과역시 복잡했기 때문인 것 같다.

## 생각해보기

- 검증문 간소화?
    - Equtable등을 활용해 검증문을 간소화할 수 있다. 하지만, 검증하려는 상태가 어떤 것인지 숨겨진다는 점에서 상황에 따라 감소화 여부가 크게 달라질 것 같다.
- 통합테스트시, 공유 데이터 베이스 숨기기?
    - 책에서 테스트 픽스처를 공유하는 방법중 공통적으로 사용하는 데이터베이스를 공유하는 방법을 알려준다. 그리고 상속을 통해 그 생성을 가리는 방식을 사용했다. 의존성을 숨기는 해당 방식이 아무리 통합테스트여도 효율적인지는 잘 모르겠다.