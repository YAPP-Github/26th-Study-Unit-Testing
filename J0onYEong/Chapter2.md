# 요약

## 단위 테스트의 정의

단위 테스트의 정의는 아래와 같다.

- 작은 코드 조각
- 빠르게 수행하고
- 격리된 방식으로 처리하는 자동화된 테스트

단위 테스트는 접근법이 다른 2가지 분파인 고전파와 런던파로 나뉜다.

두 분파간의 모든 차이는 격리가 정확히 무엇인지에 대한 의견 차이로 시작됬다.

## 두 분파의 격리 문제

### 런던파

런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 목표로한다.

하나의 클래스가 다른 클래스에 의존하면 해당 의존클래스를 테스트 대역(Test double)로 교체해야한다.

해당 방식은 이점은 다음과 같다

- 테스트 실패시 코드베이스의 어떤 부분이 문제인지 정확하게 특정가능하다.
    - 의존성을 모두 대역으로 대체했음으로
- 객체그래프를 분할할 수 있다.
    - 객체 그래프는 클래스는 의존의 체인으로 볼 수 있다, 대역 사용시 이러한 의존체인으로 부터 자유롭다.

해당 이점들을 살려 한 번에 한 클래스만 테스트 하라는 지침을 도입하면 전체 단위 테스트 스위트가 간단해지는 장점역시 발생한다.

아래코드는 런던파와 대비된다. 2개 클래스를 한번에 사용하기 때문이다. 손님 클래스에 대한 검증이라면 Store의 오류에 종속적이게 된다. 따라서 Store를 대역으로 교체해야한다.

```swift
// 준비
let store = Store()
let customer = Customer()

// 실행
customer.buy(store, ..)

// 검증
```

모든 의존성을 대역으로 교체하지는 않는다. 위 코드의 Store처럼 런타임 상태변화를 발생시키는 객체가 아닌 불변 객체의 경우 교체하지 않아도 된다.

숫자나 문자열 같은 상수타입이도 불변 객체에 해당한다.

### 고전파

격리문제에 대한 고전파의 지침은 아래와 같다.

- 단위 테스트는 작은 코드 조각을 검증한다.
    - 고전파의 격리 방식을 준수한다면, 작은 코드 조각은 클래스 세트가 될 수도 단일 클래스가 될 수도 있다.하지만, 일반적으로 단일 클래스를 지향해야한다.
- 신속하게 수행한다.
- 격리된 방식으로 진행한다.

고전파에서 바라보는 격리는 테스트 코드간의 격리를 의미한다. 

여러 단위테스트의 SUT들이 동일한 공유상태를 가지는 상황을 방지하는 것이 고전파의 격리이다.

- 공유 의존성 격리를 필요로 하는 이유(=대역이 필요한 이유)
    - 공유 상태는 테스트 간의 간섭을 일으키기 때문에, 테스트 실패의 이유를 특정하기 어렵기 때문이다.
    - 공유 의존성은 일반적으로 내부 프로세스가 아닌 대부분 외부 프로세스이다. 따라서 일반적으로 응답이 상대적으로 매우 느리다. 테스트가 많아질 수록 치명적이며, 신속한 테스트에 영향을 미친다.

### 불변 외부의존성

대부분의 경우 외부 의존성은 공유 의존성으로 사용되는 경우가 많아 두 분파에서 모두 격리의 대상이다.

하지만, 외부의존성이 읽기 전용(불변)이며 그 응답 속도가 충분히 빠르다면, 대역 교체가 반드시 필요하지는 않다.

## 두 분파의 비교

두 분파의 차이는 단위 테스트 정의에서 격리 문제를 어떻게 다루는지에 있다.

격리를 어떻게 다루는 지는 테스트 단위에 대한 처리와 의존성을 취급에 대한 방법으로 이어진다.

런던파의 장점을 토대로 두 분파의 비교를 해보겠다.

### 한번에 한 클래스에 대한 테스트를 진행함으로 입자성이 높다.

테스트는 코드의 단위를 검증해서는 안된다. 중요한 것은 동작의 단위이다. 즉, 문제 영역에 비즈니스적인 의미가 있는 것을 테스트 해야한다.

좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다. 이 테스트가 무엇을 검증하는 것인지 정확히 표현하기 어려워 지기 때문이다.

테스트는 문제를 해결하기 위해 도움이 되는 이야기를 나타내야한다. 테스트 코드를 봤을 때 프로그래머가 아닌 일반 사용자에게도 그 의미가 전달되야 한다.

### 모든 협력자는 대역으로 교체되기 때문에, 서로 연결된 객체 그래프가 커져도 상관없다.

깊은 객체 그래프를 대체하는 것은 우선 힘들 수 있다.

깊은 객체 그래프를 대체하는 것에 장점을 느끼기 보단, 이러한 클래스 그래프를 갖지 않는 것이 더 중요하다. 대게 클래스 그래프가 커지는 것은 코드 설계 문제의 결과이다.

### 테스트가 실패하면 이유가 무엇인지 빠르게 특정할 수 있다.

좋은 장점이다.

하지만, 수정사항이 발생할 때마다 테스트를 수행하면 테스트 실패에 따른 문제 코드를 빠르게 특정할 수 있기에 큰 장점이라고는 볼 수 없다.

런던파는 테스트 대상의 구현에 테스트가 너무 의존적으로 변하게된다.

예를들어 특정 매서드의 호출을 트래킹하는 Mock객체가 있고 그것을 사용한 테스트를 진행할 때, 내구 구현이 바뀌면 테스트에 큰 영향을 끼치게 된다.

이러한 이유로 단위 테스트이 저자는 고전파 정의를 선호한다고 한다.

## 두 분파의 통합 테스트

두 분파는 통합 테스트의 정의에도 차이가 있다.

런던판의 경우 대역이 아닌 실제 협력 객체를 사용하는 모든 테스트를 통합 테스트라고 한다.

고전적인 관점에서 작성된 단위 테스트는 런던파 관점에선 통합 테스트로 인식될 수 있다.

해당 책에서는 고전적인 단위 테스트 정의를 따르기에 단위 테스트의 정의를 다음과 같이한다.

- 단일 동작을 검증
- 빠르게 수행
- 다른 테스트와 별도로 처리

통합 테스트는 위 단위 테스트의 3가지 기준중 하나를 충족하지 않는 테스트를 의미한다.

- 공유 의존성 접근
    - 테스트 실행 직렬화를 통해 제어가 필요하다.
- 둘 이상의 동작을 동시에 검증
- 외부 의존성을 사용하는 테스트
    - 외부 의존성 사용은 테스트 속도 저하로 분류됨으로 두번째 조건을 미충족한다.
- 다른 팀이 개발한 모듈과 함께 테스트
    - 세가지 기준을 모두 지키지 못하는 통합 테스트이다.

### 엔드 투 엔드 테스트

통합 테스트의 일부이다. 일반적으로 외부 의존성을 더 많이 포함하는 것이 특징이다.

시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다.

결제 시스템과 같이 다소 테스트를 진행하기 힘들 기능에 대해서만 일부 대역을 사용할 수 있다.

# 느낀점

지금까지 작성한 테스트 코드는 대부분은 런던파의 기준에 부합했던 것 같다.

가장 중요하게 생각한 점은 입자성으로 독립적으로 하나의 클래스가 검증된다면 시스템 안정성에 기여하는 것이라고 생각하였다.

하지만, 특정 클래스 구현에 너무 치중한 검증 방식에 의해 테스트 대상 클래스의 구현사항을 조작하기 힘들다.

런던파의 경우 대체로 객체 협력과정을 검증하기 때문에 실질적으로 시스템의 어떤 로직을 검증하는 것인지 파악하기 힘들다. (Mock객체 사용시)

따라서 고전파의 기준처럼 실제 비즈니스적 가치를 가지는 동작 단위를 테스트하는 것이 테스트의 효율성은 높을 것이라고 생각했다. 어떤 설계 방식을 도입했을 때 고전파적 코드를 작성할 수 있을지 기대된다.

테스트 코드 작성시 항상 외부 의존성을 분리하는 것이 옳다고 생각했다. 외부 상황에 따라 테스트 결과가 변경되기 때문이다. 하지만, 단순히 외부 환경의 변동성과 더불어 높은 시간적 리소스를 통한 테스트 코드 실행 지연이 문제로 제기된다는 점은 인상적이였다.